<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://romeo.vn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://romeo.vn/" rel="alternate" type="text/html" /><updated>2019-09-09T08:49:51-05:00</updated><id>https://romeo.vn/feed.xml</id><title type="html">Le Phuoc My</title><subtitle>A blog about technology and stuff related</subtitle><entry><title type="html">Xàm xí về Domain Driven Design - Part 4: Strategic Design - Context Maps</title><link href="https://romeo.vn/xam-xi-ve-ddd-part2-2/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 4: Strategic Design - Context Maps" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part2-2</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part2-2/">&lt;p&gt;Bài trước chúng ta đã thảo luận về một số khái niệm về Domain, SubDomain, BoundedContext….và phần nào hiểu được cách xác định chúng trong dự án của mình. Chúng ta đã biết Domain của chúng ta là gì, cần phãi giải quyết các SubDomain nào, ứng với các SubDomain sẻ có những Bounded Contexts nào. Vậy các Contexts đó có các quan hệ ra sao? Chúng ta sẻ tổ chức tích hợp chúng như thế nào?&lt;/p&gt;

&lt;p&gt;Trong bài viết này chúng ta cùng thảo luận về quan hệ và cách tích hợp các các Bounded Context, chúng ta sẻ cùng nhau trả lời một số câu hỏi quan trọng tồn tại trong quá trình phân tích dự án như sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Có những mối quan hệ nào giữa các Bounded Contexts?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để các Bounded Context phối hợp với nhau?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để Downstream Context đối phó với những thay đổi xãy ra ở Upstream Context? Làm thế nào để các Upstream Context không gây rắc rối cho các Downstream Context?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để tổ chức ánh xạ ngữ nghĩa các Domain Model giữa các Bounded Context cũng như làm thế nào để translate các thuật ngữ trong Ubiquitous Language sang các ngôn ngữ khác.&lt;/li&gt;
  &lt;li&gt;Các Principles trong việc tổ chức integrate các Bounded Context là gì?&lt;/li&gt;
  &lt;li&gt;Những giá trị lớn lao khi tổ chức, xây dựng tốt các Context Maps(Integrate chúng một cách dễ dàng, tính cohesion cao mà lại low coupling, dễ duy trì, mở rộng, tạo nguổn dữ liệu real time cho việc mining, phân tích,…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Câu trả lời cho các câu hỏi trên sẻ được tổng hợp trong một thứ gọi là Context Map, thứ được hình dung bằng hình minh hoạ dưới đây:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-20-xam-xi-ve-ddd-part2-2/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bây giờ chúng ta cùng tìm hiểu vì sao lại có hình minh hoạ trên.&lt;/p&gt;

&lt;h3 id=&quot;1-mối-quan-hệ-giữa-các-bounded-context&quot;&gt;1. Mối quan hệ giữa các Bounded Context:&lt;/h3&gt;
&lt;p&gt;Trong các hệ thống lớn và phức tạp, rất ít các Bounded Context tách biệt một cách hoàn toàn. Đa số Bounded Context sẽ có một hoặc nhiều mối quan hệ với các Bounded Context khác. Việc xác định các mối quan hệ này có tầm quan trọng không chỉ về mặt kỹ thuật(quyết định các sub-system giao tiếp phối hợp với nhau như thế nào) mà còn quyết định cả cách chúng được phát triển(các team sẽ phối hợp với nhau ra sao).&lt;/p&gt;

&lt;p&gt;Cách phổ biến nhất để xác định mối quan hệ giữa các Bounded Context là phân loại các Bounded Context thành các Upstream và Downstream Contexts. Tương tự như hình tượng các thành phố được đặt bên một dòng sông, các thành phố ở thượng nguồn(Upstream) sẻ đổ những gì muốn truyền cho các thành phố ở hạ lưu(Downstream) xuống sông, những thứ đó sẻ được đưa đến các thành phố ở hạ lưu và họ chỉ cần vớt lên từ dưới sông.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-20-xam-xi-ve-ddd-part2-2/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rõ ràng các Context đôi lúc có thể vừa được coi là Upstream Context lẫn Downstream Context tuỳ vào vị trí của chúng.&lt;/p&gt;

&lt;p&gt;Tuy nhiên việc chia thành các Upstream và Downstream contexts sẻ có ưu và nhược điểm riêng của nó. Một Upstream Context sẻ không phụ thuộc vào bất kỳ Context nào khác, nó sẻ tự do phát triển theo bất kỳ hướng nào. Tuy nhiên, hệ quả của bất kỳ thay đổi nào ở Upstream Context cũng có thể gây ảnh hưởng nghiêm trọng đối với các Downstream Context. Một Downstream Context bị hạn chế bởi sự phụ thuộc của nó vào Upstream Context nhưng lại không phãi quá lo lắng vì những thay đổi của nó sẻ gây ảnh hướng cho các Downstream Context, điều này giúp các nhà developer tại Downstream Context sẻ tự do hơn các developer tại Upstream Context muốn làm gì cũng phãi nhìn trước ngó sau.&lt;/p&gt;

&lt;p&gt;Chúng ta có thể hình dung các mối quan hệ giữa các Context một cách trực quan như hình dưới.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-20-xam-xi-ve-ddd-part2-2/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ok, chúng ta đã quyết định rằng các Context về cơ bản sẻ có mối quan hệ như trên, vậy chúng ta sẻ tổ chức giao tiếp phối hợp giữa chúng như thế nào? Có các mẫu integrate nào giữa chúng?&lt;/p&gt;

&lt;p&gt;Chúng ta cùng tham khảo các integrate parterns mà Evans đã giới thiệu.&lt;/p&gt;
&lt;h3 id=&quot;2-integration-patterns&quot;&gt;2. Integration Patterns:&lt;/h3&gt;
&lt;h4 id=&quot;partnership&quot;&gt;Partnership:&lt;/h4&gt;
&lt;p&gt;Hai Contexts có quan hệ partnership thì cả hai team thuộc hai contexts này phãi phối hợp chặc chẻ với nhau. Các interfaces, contracts, features giữa hai bên hay bất cứ thứ gì cần cho việc develop hai context này cần được plan và lên lịch chính xác nhằm tối thiểu hoá các ảnh hưởng xấu đến quá trình phát triển của chúng. Mỗi một sai lầm nào trong quá trình planning và scheduling đều có thể gây ra deadlock/bottleneck trong quản lí, ảnh hưởng đến việc delivery các modules tính năng.&lt;/p&gt;

&lt;h4 id=&quot;shared-kernel&quot;&gt;Shared Kernel:&lt;/h4&gt;
&lt;p&gt;Khi hai hay nhiều Contexts cùng dùng chung/chia sẻ nhau các thông tin như code base, service, model,…. chúng ta gọi đó là các thành phần Shared Kernel. Các Shared Kernel có thể bị thay đổi bởi bất cứ team nào với sự nhất trí của các bên nhằm đảm bảo không gây ảnh hưởng đến context nào đang dùng Shared Kernel này. Vì tính chất đó của share kernel code, để đảm bảo không có sai xót ảnh hưởng nào chúng ta cần phãi cover code bằng automation test.&lt;/p&gt;

&lt;h4 id=&quot;customer-supplier&quot;&gt;Customer-Supplier:&lt;/h4&gt;
&lt;p&gt;Khi hai team có mối quan hệ Upstream-Downstream, trong đó team ở Upstream có thể phát triển mà không phụ thuộc vào team ở Downstream. Trong lúc đó team ở Downstream đôi lúc phãi phụ thuộc vào Downstream context. Do đó các yêu cầu từ Downstream Context cần được xem như là các yêu cầu business và chuyển cho quá trình planning ở Upstream team.&lt;/p&gt;

&lt;h4 id=&quot;conformist&quot;&gt;Conformist&lt;/h4&gt;
&lt;p&gt;Các Bounded Context thường có mối quan hệ Upstream-Downstream. Tuy nhiên, team ở Upstream Context không có motivation để đáp ứng nhu cầu của team ở Downstream Context. Team ở Downstream Context phãi tuân thủ model của team Upstream Context bất kể điều gì xảy ra.&lt;/p&gt;

&lt;h4 id=&quot;anticorruption-layer&quot;&gt;Anticorruption Layer&lt;/h4&gt;
&lt;p&gt;Các Bounded Context thường có quan hệ Upstream-Downstream với nhau và team ở Upstream thườn không care đến nhu cầu của Team ở Downstream Context. Tuy nhiên, thay vì tuân thủ model hay bất cứ gì mà team ở Upstream Context define ra, team ở Downstream cần tạo ra một lớp trừu tượng nhằm bảo vệ logic trong Context này khỏi những thay đổi trong Upstream Context. Anticorruption Layer này cho phép các thành viên trong team có thể làm việc với một Domain Model ứng với Context của họ, trong khi vẫn tích hợp với Upstream Context. Khi Upstream Context thay đổi, Anticorruption Layer cũng phải thay đổi, nhưng về Domain Model, Business Logic của Downstream Context có thể không thay đổi.&lt;/p&gt;

&lt;h4 id=&quot;open-host-service&quot;&gt;Open Host Service:&lt;/h4&gt;
&lt;p&gt;Một Bounded Context có thể mở một hoặc nhiều protocol(có thể là Rest/gRPC hay cả message bus) để bất kì Bounded Context khác muốn tích hợp/sử dụng service của nó đều có thể access thông qua các protocol này, chúng được hiểu là Open Host Service.&lt;/p&gt;

&lt;h4 id=&quot;published-language&quot;&gt;Published Language:&lt;/h4&gt;
&lt;p&gt;Việc translate ngữ nghĩa giữa các model của hai hoặc nhiều Bounded Context đòi hỏi giữa chúng phãi có một ngôn ngữ chung. Các Bounded Context sẻ phãi đồng thuận với nhau trên một ngôn ngữ chung ví dụ như các XML schema, UML, DSL,…dựa vào các language đó các Bounded Context có thể tương tác với nhau một cách chính xác hiệu quả. Các language đó gọi là Published Language. Với tính chất được chia sẻ giữa các Bounded Context, Published Language gần giống với Open Host Service và thường được sử dụng đi kèm với Open Host Service.&lt;/p&gt;

&lt;h4 id=&quot;separate-ways&quot;&gt;Separate Ways:&lt;/h4&gt;
&lt;p&gt;Chúng ta phải cứng rắn hơn và đôi lúc phãi tàn nhẫn hơn khi define các requirements. Nếu hai bộ chức năng không có mối quan hệ đáng kể thì chúng phãi được tổ chức tách biệt hoàn toàn. Integration luôn luôn có một cái giá rất đắt cho việc coupling trong lúc đôi khi chỉ mang lại một lợi ích nhỏ. Việc define, phân tách hoàn toàn các Bounded Context làm cho chúng không dính với các Bounded Context khác do đó cho phép Developers phát triển một cách đơn giản hơn, chuyên biệt hơn trong phạm vi nhỏ, dễ dàng optimize hơn và đở rối rắm hơn.&lt;/p&gt;

&lt;p&gt;Có hai quan điểm rất mâu thuẩn ở đây đó là:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Khi muốn thay đổi gì đó từ một Context chúng ta phãi biết nó ảnh hưởng đến những Context nào và mức độ ảnh hưởng của nó đối với các Context đó ra sao để ra quyết định cho hợp lí.&lt;/li&gt;
  &lt;li&gt;Mỗi Context nên được coi là một thế giới độc lập, không biết và không cần biết bất cứ Context nào khác.
    &lt;ul&gt;
      &lt;li&gt;Úpstream và Downstream có liên quan đến luồn dữ liệu.&lt;/li&gt;
      &lt;li&gt;Schedule, responsiveness to external request.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion:&lt;/h3&gt;
&lt;p&gt;Vấn đề phức tạp mà Context Mapping giải quyết cho các architect và manager là:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Các Context Maps có thể được sử dụng cho một góc nhìn toàn cảnh về cách chúng ta tổ chức, phát triển các thành phần trong một enterprise system. Nhìn vào đó chúng ta có thể thấy được những hạn chế về mặt architecture như kiến ​​trúc như các bottleneck trong việc integrate chẳng hạn. Các Context Maps giúp chúng ta có thể xác định được các vấn đề làm block quá trình phát triển hệ thống cũng như các vấn đề trong management mà chúng ta khó phát hiện ra nếu sử dụng các phương pháp khác.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UPDATING ….&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Bài trước chúng ta đã thảo luận về một số khái niệm về Domain, SubDomain, BoundedContext….và phần nào hiểu được cách xác định chúng trong dự án của mình. Chúng ta đã biết Domain của chúng ta là gì, cần phãi giải quyết các SubDomain nào, ứng với các SubDomain sẻ có những Bounded Contexts nào. Vậy các Contexts đó có các quan hệ ra sao? Chúng ta sẻ tổ chức tích hợp chúng như thế nào?</summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - Part 3: Strategic Design - SubDomain - Bounded Context</title><link href="https://romeo.vn/xam-xi-ve-ddd-part2-1/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 3: Strategic Design - SubDomain - Bounded Context" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part2-1</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part2-1/">&lt;p&gt;Ở các bài trước chúng ta đã phần nào thảo luận về What and Why Domain Driven Design trong việc phát triển các Enterprise System. Trong bài viết này chúng ta sẻ cùng thảo luận về công cụ mà cá nhân mình thấy là quan trọng và thiết yếu nhất của DDD - Strategic Design. Strategic Design thực sự powerful khi phát triển các dự án lớn, phức tạp. Tuy nhiên nếu áp dụng tốt Strategic Design chúng ta cũng sẻ thu được những lợi ích đáng kể đối với các dự án nhỏ dù mặc dù chúng ta không sử dụng bất kì ideas/concepts còn lại trong DDD. Chúng ta sẻ cùng tìm hiểu về approach để xử lí một hệ thống phức tạp, để chia nhỏ hệ thống. Bên cạnh đó phần nào làm rõ các khái niệm như Ubiquitous Language, Bounded Context, Subdomain,….&lt;/p&gt;

&lt;p&gt;Như chúng ta đều biết, chia để trị là nghệ thuật của quá trình phát triển phần mềm. Cho dù không có hiểu biết về DDD thì gặp phãi vấn đề lớn chúng ta cũng nghĩ đến việc chia hệ ra thành nhiều phần, tụi mình cũng đã làm như vậy để rồi tiếp cận với Microservices Architecture một cách quán tính. Việc chia hệ thống ra thành các Sub-System với ít kiến thức về Domain Driven Design dẫn đến một hiện trạng là các software/domain concerns không được tách biệt một cách rõ ràng, phân chia trách nhiệm và mối quan hệ giữa chúng cũng diễn ra nhùng nhằn, rối ren. Kiến thức về Strategic Design sẻ phần nào tháo gỡ một số hiện trạng đó.&lt;/p&gt;

&lt;p&gt;Với DDD approach chúng ta tiếp cận vấn đề với hai bước chính:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Trả lời câu hỏi What?&lt;/li&gt;
  &lt;li&gt;Trả lời câu hỏi How?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“What?”: Chúng ta sẻ giải quyết domain gì? Gồm các vấn đề nào? Các vấn đề đó đại diện cho khái niệm Problem Space.&lt;/p&gt;

&lt;p&gt;“How?”: Khi xác định được vấn đề lớn và chia thành các vấn đề nhỏ rồi, chúng ta tập trung tháo gỡ từng vấn đề. Chúng ta sẻ giải quyết các vấn đề đó như thế nào? Triển khai hiện thực hoá chúng ra sao? Tất cả chúng đại diện cho khái niệm Solution Space.&lt;/p&gt;

&lt;h3 id=&quot;1-problem-space-và-sub-domain&quot;&gt;1. Problem Space và Sub Domain:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
Từ một khía cạnh nào đó chúng ta có thể định nghĩa Domain là các problems mà hệ thống của chúng ta sẻ giải quyết, do đó có thể gọi tập hợp các problems đó là Problem Space.&lt;/p&gt;

&lt;p&gt;Để làm cho một Domain trở nên cụ thể và dễ phân tích đánh giá hơn chúng ta thường chia nhỏ Problem Space của Domain đó ra thành các problem nhỏ hơn, chúng có thể được hiểu là các Sub Domain. Sub Domain được chia thành ba loại sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Core Domain: Core Domain là những gì mang đến giá trị cốt lõi cho business của bạn, là những gì thể hiện xứ mệnh tổ chức của bạn. Core Domain phãi chứa những gì làm cho tổ chức của bạn trở nên khác biệt so với các tổ chức khác trong cùng lĩnh vực, một công ty không thể nào trụ được và thành công nếu không có gì đặc biệt so với các công ty khác.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Supporting Sub Domain: Đôi lúc một hệ thống cần phãi giải quyết một số vấn đề chuyên biệt để hổ trợ cho các core business của hệ thống, các vấn đề đó là cần thiết nhưng không phãi là cốt lõi của hệ thống, nó được gọi là Supporting Sub Domain. Một ví dụ như phần Suggestion của TIKI, nó không là phần quan trọng nhất nhưng là phần hổ trợ cực mạnh mẻ cho Core business của Tiki. Nó được gọi là Supporting Sub Domain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Generic Sub Domain: Là một Sub Domain chung chung hoạt động nhiều nơi trong hệ thống, không chứa bất cứ gì chuyên biệt cho hệ thống nhưng vẫn cần thiết để hệ thống có thể hoạt động.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để hiểu hơn về việc chia tách thành các Subdomains, chúng ta hãy nghĩ về việc design một hệ thống e-commerce như TIKI chẳng hạn. Những yêu cầu cơ bản tối thiểu để người mua hàng và người bán hàng có thể sử dụng được là phãi có một danh mục sản phẫm cho cả hai,  quản lí kho bãi, cho phép người ta đặt hàng, thanh toán, vận chuyển….như vậy về cơ bản chúng ta sẻ có một số subdomains chính đó là Product Catalog, Inventory, Order, Payment, Shipping, Suggesting, Forecasting, Event….&lt;/p&gt;

&lt;p&gt;Cái nhìn cá nhân của mình thấy rằng rõ ràng Core Domain của họ là giải quyết các vấn đề của người mua và người bán dựa trên một Marketplace gồm Product Catalog, Product Listing, Buying…, đó là giá trị cốt lõi của TIKI mà mọi người nhìn thấy và nhớ đến.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó có thêm các thành phần Supporting Sub Domain như Suggesting, Forecasting về cơ bản nó không quan trọng bằng Marketplace tuy nhiên lại bổ trợ cực kì mạnh mẻ cho Core Business của hệ thống. Hệ thống suggestion hoạt động thông minh mang lại trải nghiệm mua sắm tốt cho người dùng. Hệ thống dự báo hoạt động thông minh có thể giúp các nhà cung cấp nhận thức đánh giá được thị trường, đưa ra các quyết định kinh doanh đúng đắn hơn, giảm thiểu rủi ro trong kinh doanh.&lt;/p&gt;

&lt;p&gt;Các Supporting Sub Domain đó gián tiếp mang lại thành công cho core business. Ngoài ra còn có một số Generic Sub Domain ví dụ như user identity, authorization/authentication là những thứ cần thiết cho hệ thống&lt;/p&gt;

&lt;p&gt;Một điều đáng chú ý là một Sub Domain có thể thuộc hai loại Sub Domain khác nhau, nếu một marketplace đặt trải nghiệm người mua hàng lên hàng đầu, muốn xây dựng một hệ thống suggestion system nhằm tạo ra sự khác biệt, lợi thế đối với các tổ chức khác thì Suggestion cũng sẻ có thể coi Core Sub Domain.&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta có thể thấy rằng Problem Space cuối cùng cũng là các phần của Domain cần được phát triển để tạo nên core Domain. Đồng nghĩa với việc đánh giá, phân tích Problem Space của một domain lớn sẻ liên quan đến việc phân tích các Sub Domain đã hiện hữu hay chưa và sự hiện hữu của các Sub Domain đó có thực sự cần thiết đối với hệ thống hay không. Sub Domain cho phép chúng ta có cái nhìn vừa bao quát vừa chi tiết các thành phần vấn đề khác nhau của Domain lớn, do đó Sub Domains là một công cụ rất hữu ích trong việc đánh giá, phân tích Problem Space.&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã phần nào rõ ràng các khái niệm về Problem Space và SubDomain. Vậy làm sao để tiếp cận một dự án phức tạp và lèo lái dự án đi đúng hướng? Chúng ta phãi trả lời các câu hỏi sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Core Domain của chúng ta là gì?&lt;/li&gt;
  &lt;li&gt;Tầm nhìn mục tiêu chiến lược về Core Domain đó là gì?&lt;/li&gt;
  &lt;li&gt;Những thành phần nào nên được coi là một phần của Core Domain?&lt;/li&gt;
  &lt;li&gt;Các Supporting Subdomains và Generic Subdomains nào là cần thiết đối với hệ thống?&lt;/li&gt;
  &lt;li&gt;Trong từng khu vực của hệ thống sẻ có những nhân tố nào(engineer, domain expert…)?&lt;/li&gt;
  &lt;li&gt;Mỗi nhân tố đó sẻ đóng góp ra sao?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Một khi đã xác định rõ ràng được tầm nhìn và mục tiêu chiến lược của Core Domain và các thành phần cần thiết để hỗ trợ, bổ trợ cho Core Domain, chúng ta sẻ có được chiến lượt tốt nhằm tập trung ưu tiên nguồn lực, sức mạnh, tầm nhìn, bí quyết để phát triển Core Domain. Đồng thời đảm bảo rằng tất cả các bên liên quan trong hệ thống có được sự liên kết chặc chẻ và cam kết hợp tác dựa trên một tầm nhìn chung. Không quá lang mang bởi những thành phần không quan trọng nhưng lại chiếm nhiều effort. Các team ở supporting domain cần nhận thức được mình đang làm gì, biết mình đang phục vụ core domain như thế nào, đóng góp ra sao…..&lt;/p&gt;

&lt;h3 id=&quot;2-solution-space-và-bounded-context&quot;&gt;2. Solution Space và Bounded Context:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta đã xác định Problem Space với các Sub Domain được chia nhỏ, ứng với từng Sub Domain chúng ta sẻ có một hoặc nhiều Solution/Bounded Context để giải quyết nó. Tập hợp chúng gọi là Solution Space.&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta tạm định nghĩa có phần chưa hoàn chỉnh rằng Solution Space là nơi các vấn đề được giải quyết trong thực tế và Bounded Context là mỗi câu trả lời cho mỗi problem trong Problem Space, là một giải pháp cụ thể, một quan điểm hiện thực hóa, được sử dụng để hiện thực hóa một giải pháp.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó chúng ta cũng có thể hình dung rằng mỗi một Bounded Context xác định cách nhìn nhận về một phần của domain business. Một thành phần business có thể có mặt ở nhiều nơi trong một hệ thống tuy nhiên tại mỗi khu vực, mỗi context của hệ thống có thể nhìn nhận thành phần đó một cách khác nhau đó cũng chính là nguyên nhân vì sao họ gọi đó là Bounded Context.&lt;/p&gt;

&lt;p&gt;Theo lẻ thông thường, chúng ta luôn có một quan hệ 1-1 lí tưởng cho một câu hỏi và một câu trả lời, do đó để đơn giản hoá chúng ta nên cố gắng chia các Subdomain và Bounded Context sao cho chúng luôn có sự liên kết 1-1 giữa một Subdomain và một Bounded Context.&lt;/p&gt;

&lt;p&gt;Tuy nhiên trong thực tế ta nên linh động trong việc define các Subdomain và Bounded Context cho hợp lí. Một hệ thống phức tạp có rất ít Domain nhỏ và đơn giản, khi mà chỉ có một Ubiquitous Language và một model duy nhất biểu diễn mọi thứ về một Sub Domain, đồng thời luôn có một liên kết đẹp đẻ 1-1 giữa Sub Domain và Bounded Context như vậy.&lt;/p&gt;

&lt;p&gt;Các business rule thường chống chéo, conflict, rối rắm rất nhiều. Cũng là một thuật ngữ nhưng có thể mang nhiều nghĩa khác nhau ở các context khác nhau, và cũng có thể hai từ khác nhau như lại cùng mang một ý nghĩa ở các context khác nhau.&lt;/p&gt;

&lt;p&gt;Thông thường sẻ có nhiều solution cùng phối hợp để giải quyết một problem trong Problem Space tuỳ thuộc vào cách bạn nhìn nhận nó. Mỗi một Bounded Context là một trong nhiều solution để giải quyết một problem, do đó một Sub Domain có thể có nhiều Bounded Context.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó, bạn cũng có thể dễ dàng tìm thấy một Bounded Context trãi dài qua nhiều Sub Domain, trong trường hợp đó giữa các Bounded Context và các Sub Domain sẻ có các thuật ngữ, đối tượng cụ thể theo từng Bounded Context, cho nên chắc chắn sẻ xãy ra việc xung đột chồng chéo ý nghĩa các thuật ngữ tại các Bounded Context khác nhau.&lt;/p&gt;

&lt;p&gt;Lấy ví dụ trong một marketplace, thuật ngữ User trong context khách hàng duyệt catalog thì User mang ý nghĩa một Object biểu diễn những thông tin như hạng khách hàng(vàng, bạc, bạch kim…), mức giảm giá đối với khách hàng này, tuy nhiên trong context khách hàng order thì User lại phãi là một Object biểu diễn thông tin như địa chỉ, thông tin thanh toán,…. điều đó sẽ làm tăng nguy cơ quá tải các thuật ngữ do quá nhiều Subdomain sẽ được thể hiện thông qua cùng một Ubiquitous Language.&lt;/p&gt;

&lt;p&gt;Một khi toàn bộ Domain của một của tổ chức đã được chia ra thành các SubDomain, các Bounded Contexts rồi thì chúng ta chỉ cần tập trung vào một khu vực cụ thể thay vì toàn bộ business domain. Tuy nhiên cũng có những trường hợp không thể chia được khi đó bắt buộc chúng ta phãi tách một số domain code ra(shared kernal) để chia sẻ cho nhiều khu vực muốn sử dụng.&lt;/p&gt;

&lt;p&gt;Hãy nhớ rằng Problem Space là sự kết hợp giữa Core Domain, các Supporting Domain và Generic Domain. Khi bạn đã hiểu rõ về Problem Space, bạn sẻ đưa  ra được Solution Space. Solution Space sẽ bị ảnh hưởng mạnh mẽ bởi hệ thống, công nghệ hiện có và những hệ thống mới sẻ được tạo ra. Ở đây chúng ta cần phải phân tích về các Bounded Context, do đó hãy cân nhắc những câu hỏi quan trọng sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hệ thống hiện tại đang có những gì?&lt;/li&gt;
  &lt;li&gt;Những thứ đó có thể được tái sử dụng hay không?&lt;/li&gt;
  &lt;li&gt;Những gì cần được thêm vào để thoả mãn mục tiêu cuối cùng?&lt;/li&gt;
  &lt;li&gt;Làm thế nào tất cả những thứ có sẳn và những thứ mới được thêm vào có thể kết nối với nhau, tích hợp với nhau?&lt;/li&gt;
  &lt;li&gt;Xác xuất mà mỗi quyết định chiến lượt đó sẻ thành công, thất bại, làm delay quá trình phát triển như thế nào?&lt;/li&gt;
  &lt;li&gt;Chúng ta phãi quản lí hệ thống các thuật ngữ của các Ubiquitous Languages giữa các context như thế nào? Quản lí sự khác nhau về mặt ngữ nghĩa các mỗi khái niệm/thuật ngữ, sự chồng chéo, xung đột ngữ nghĩa giữa các bounded context khác nhau ra sao?&lt;/li&gt;
  &lt;li&gt;Quyết định độ lớn của một Bounded Context như thế nào? Trong một Bounded Context nên chứa bao nhiêu Modules, Aggregates, loại Event, Services?&lt;/li&gt;
  &lt;li&gt;Trong một Boundex Context nào sẻ chứa các concepts giải quyết Core Domain? Các Tactical Parterns nào sẻ được sử dụng cho việc model chúng?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-size-của-bounded-context&quot;&gt;3. Size của Bounded Context:&lt;/h3&gt;
&lt;p&gt;Xác định độ lớn của một Bounded Context như thế nào là hợp lí? Trong một Bounded Context nên chứa bao nhiêu Modules, Aggregates, loại Event, Services?&lt;/p&gt;

&lt;p&gt;Thực sự không có một câu trả lời cho con số chính xác cho câu hỏi trên. Một bouded context cần đủ lớn để thể hiện đầy đủ một Ubiquitous Language trong chính nó.&lt;/p&gt;

&lt;p&gt;Các khái niệm không thực sự liên quan đến Core Domain thì nên được cân nhắc mức độ quan trọng mới được đưa vào Ubiquitous Language. Nếu một khái niệm không có trong Ubiquitous Language của bạn, thì không nên đưa nó vào model ngay từ đầu. Nếu một hoặc nhiều khái niệm ngoại lai chen vào hãy loại bỏ chúng ra, chúng có thể thuộc về một Supporting hoặc Generic Subdomain hoặc không thuộc model nào cả.&lt;/p&gt;

&lt;p&gt;Hãy cẩn thận để không nhầm lẫn các yếu tố là thành phần thực sự của Core Domain. Model của bạn phải thể hiện sự phong phú của Ubiquitous Language trong context, không để xót thứ gì thiết yếu cũng như không có quá nhiều thứ nhỏ nhặt rối rắm khiến chúng ta khó hình dung được thứ gì là cốt lõi cần tập trung, thứ gì là nhỏ nhặt không đáng đề cao. Các công cụ như Context Map(sẻ giới thiệu sau) có thể giúp chúng ta đánh giá những tiêu chí đó một cách tốt hơn.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó cũng sẻ có một số nguyên nhân dẫn đến việc chúng ta tạo ra một Bounded Context với một kích thước sai lầm. Những điều gì có thể dẫn chúng ta tạo ra một Bounded Context có kích thước sai?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Chúng ta có thể sai lầm khi chấp nhận các ảnh hưởng đến từ kiến ​​trúc thay vì Ubiquitous Language dẫn lối chúng ta. Trong quá trình phát triển phần mềm, các engineer có xu hướng chuyển một Bounded Context thành một Fake Context ứng với mục tiêu phát triển của họ, Fake Context đó đôi lúc bị phụ thuộc vào một platform, framework hoặc một vài thành phần infrastructure giúp ích cho việc implement, vô hình chung khiến các engineer không thể tập trung nhìn nhận các Bounded Context như với mục đích ban đầu, họ cân nhắc các ranh giới kĩ thuật thay cho ranh giới ngôn ngữ mà các Bounded Context bám víu vào, làm méo mó tầm nhìn đến từng Bounded Context và gây ra quyết định sai.&lt;/li&gt;
  &lt;li&gt;Một sai lầm nữa là thay vì dùng Bounded Context để phân chia trách nhiệm thì các manager dùng việc chia Bounded Context để chia task, quản lí task cho Engineer Team, họ có xu hướng coi các Bounded Context là Fake Context của họ nhằm áp dụng các mục tiêu quản lí. Vì một số chiến lược về mặt quản lí mà họ có thể thêm bớt nhiều nhu cầu, thành phần dẫn đến việc không còn nhìn nhận đúng bản chất, kích thước cũng như méo mó tầm nhìn đến từng Bounded Context.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-conclusion&quot;&gt;4. Conclusion:&lt;/h3&gt;
&lt;p&gt;Với cá nhân mình đánh giá một số kiến thức về Strategic Design kể trên thực sự rất thiết yếu cho việc design cũng như phát triển Enterprise Application:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mang lại chiến lược phát triển rõ ràng: Vượt phạm vi dự án(Scope Creep) là vấn đề nhan nhản trong các dự án phần mềm. Không chỉ làm tốn nhiều chi phí mà còn gây khó chịu cho đội ngủ phát triển, là nguyên nhân làm các developer mất đi sự vui vẻ hạnh phúc khi làm việc. Việc xác định rõ ràng các SubDomain, các Bounded Context và ranh giới giữa chúng giúp chia nhỏ dự án nhằm tập trung vào những phần nhỏ theo thứ tự ưu tiên từ đó hạn chế tối đa ảnh hưởng xấu từ Scope Creep.&lt;/li&gt;
  &lt;li&gt;Nên chia nhỏ các model và đặt vào từng context cụ thể thay vì design một model lớn chứa mọi thứ. Điều đó giúp chúng ta có thể tập trung đào sâu và xác định đúng bản chất của mỗi vấn đề tại mỗi khía cạnh thay vì quá ôm đồm mọi thứ dễ gây ra quá tải.&lt;/li&gt;
  &lt;li&gt;Strategic Design giúp bạn có cái nhìn bao quát đến từng giá trị mà hệ thống bạn mang lại. Đánh độ ưu tiên cho từng SubDomain mà ưu tiên lớn nhất cho Core Domain nhằm tối thiểu hoá effort nhưng mang lại tổng giá trị tối đa.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Ở các bài trước chúng ta đã phần nào thảo luận về What and Why Domain Driven Design trong việc phát triển các Enterprise System. Trong bài viết này chúng ta sẻ cùng thảo luận về công cụ mà cá nhân mình thấy là quan trọng và thiết yếu nhất của DDD - Strategic Design. Strategic Design thực sự powerful khi phát triển các dự án lớn, phức tạp. Tuy nhiên nếu áp dụng tốt Strategic Design chúng ta cũng sẻ thu được những lợi ích đáng kể đối với các dự án nhỏ dù mặc dù chúng ta không sử dụng bất kì ideas/concepts còn lại trong DDD. Chúng ta sẻ cùng tìm hiểu về approach để xử lí một hệ thống phức tạp, để chia nhỏ hệ thống. Bên cạnh đó phần nào làm rõ các khái niệm như Ubiquitous Language, Bounded Context, Subdomain,….</summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - Part 1: Quá trình giác ngộ</title><link href="https://romeo.vn/xam-xi-ve-ddd-part1-1/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 1: Quá trình giác ngộ" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part1-1</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part1-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/5.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Có bao giờ bạn làm việc trong một hệ thống thực sự lớn, nơi mà bạn phãi trăn trở đấu tranh với bản thân làm sao để tổ chức một lượng lớn business logic sao cho phù hợp? Business thì luôn luôn thay đổi cùng với sự chồng chéo rối rắm khiến bạn stress, hiệu xuất làm việc của bạn đi xuống, làm thế nào để lường trước và tránh tình trạng đó xãy ra?&lt;/p&gt;

&lt;p&gt;Có bao giờ bạn làm việc trong một codebase mà cứ hể thêm code vào là thấy một nùi phức tạp lòi ra? Hơn nữa mỗi một thay đổi bạn không thể biết nó sẻ đụng chạm đến những thứ nào khác hay không, làm sao để tránh tạo ra một code base kiểu đó?&lt;/p&gt;

&lt;p&gt;Thử đứng dưới góc độ của một người quản lí, làm sao chúng ta control việc phát triển của một ứng dụng phức tạp một cách mượt mà trơn tru. Nơi mà sự phức tạp cứ luôn luôn tăng, luôn luôn ập đến? Điều đó cũng kéo theo quá nhiều rủi ro, vậy chúng ta phãi quản lí, đối phó với những rủi ro đó như thế nào?&lt;/p&gt;

&lt;p&gt;Làm sao chúng ta chia một hệ thống lớn thành nhiều phần và giao chúng cho các team khác nhau cùng phối hợp phát triển và tích hợp chúng lại một cách mượt mà, nhịp nhàng và hiệu quả?&lt;/p&gt;

&lt;p&gt;Mình từng may mắn có cơ hội tham gia vào một dự án khá lớn với vài chục modules mà trong mỗi module là rất nhiều sự phức tạp khác nhau, điều đó phần nào giúp mình nếm trãi được sự đắng cay của complexity. Domain Driven Design chính xác là bài thuốc đã phần nào giúp mình thoát khỏi những nổi ám ảnh đó. Nó là bài thuốc gần như là tốt nhất dành cho các Enterprise System phức tạp.&lt;/p&gt;

&lt;p&gt;Với hơn 15 năm phát triển kể từ khi được giới thiệu từ năm 2003, DDD bây giờ không chỉ là một phương pháp, cách tiếp cận trong thiết kế phần mềm nữa. DDD thực sự cần thiết trong mọi ngóc ngách của quá trình phát triển phần mềm. Từ khâu tiếp nhận requirement, thảo luận làm rõ domain knowledge đến khâu decouple, design cho đến tổ chức quản lí phối hợp các đội nhóm, quản lí risk và planning. DDD thực sự powerful đối với dân chúng ta.&lt;/p&gt;

&lt;p&gt;Trong chuỗi bài xàm xí này mình sẻ cố gắn tập trung ghi lại kiến thức bản thân về Domain Driven Design, bạn đọc nếu có thấy bất cứ sai lầm thiếu sót nào mong rằng sẻ comment ở dưới để mình cũng cố thêm.&lt;/p&gt;

&lt;p&gt;Mở đầu cho chuổi xàm xí này mình sẻ điểm nhanh trãi nghiệm bản thân qua các dự án với các mẫu kiến trúc.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;MVC Architecture&lt;/li&gt;
  &lt;li&gt;Database Centric Approach với mô hình 3-Layers và Transaction Script&lt;/li&gt;
  &lt;li&gt;Anemic Domain Model vs Rich Domain Model&lt;/li&gt;
  &lt;li&gt;Conclusion&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-mvc-architecture&quot;&gt;1. MVC Architecture:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi bắt đầu đi làm, mẫu thiết kế đầu tiên mình được tiếp cận đó là MVC. Nhìn chung với ứng dụng nhỏ đơn giản thì mô hình này khá ổn.&lt;/p&gt;

&lt;p&gt;Code được tổ chức riêng biệt thành các thành phần Model - View - Controller tách bạch rõ ràng, bước đầu tương đối dễ quản lí và phát triển dự án. Code base khá đơn giản, đáp ứng yêu cầu về tốc độ phát triển. Người mới có thể nhanh chóng nắm được bộ source.&lt;/p&gt;

&lt;p&gt;Tuy nhiên, với đội ngủ có chuyên môn chưa cao, chưa thật sự cứng với các mô hình, principles như SOLID chẳng hạn thì thật sự khó quản lí một cách lâu dài. Với đội ngủ chuyên môn chưa cao thì làm việc với MVC sẻ mãi là MVC, không có khả năng ứng phó với sự phức tạp và refactor cho hợp lí. Vì logic quá tập trung đóng gói trong Data model lẫn Business Model, các model của chúng ta có xu hướng phình to và rất khó có thể chia nhỏ cả bề ngang lẫn bề dọc. MVC thật sự là không còn khả dụng với các ứng dụng vừa và lớn.&lt;/p&gt;

&lt;h4 id=&quot;2-database-centric-approach-với-mô-hình-3-layers-và-transaction-script&quot;&gt;2. Database Centric Approach với mô hình 3-Layers và Transaction Script&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Đa số các dự án mình tham gia trước đó đều dựa trên Database Centric Approach với mô hình 3-Layers và Transaction Script.&lt;/p&gt;

&lt;p&gt;Với Database-Centric Approach, database luôn là trung tâm của ứng dụng, mọi thứ sẻ phãi phụ thuộc vào database. Với approach này business logic có xu hướng dính chặt với data access logic, thường đi đôi với Transaction Script partern. Với Transaction Script chúng ta sẻ rất khó để chia thành các layer. Trong trường hợp chúng ta sử dụng Relational Database thì Business Logic thường chứa các lệnh thủ tục với database luôn, do đó việc phát triển ứng dụng thường được bắt đầu bằng việc design  database.&lt;/p&gt;

&lt;p&gt;Database-Centric Approach cùng với Transaction Script thật sự tốt khi ứng dụng chúng ta chỉ có CRUD đơn giản và chứa ít Business Rules.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với cách tiếp cận này để có thể reuse code chúng ta thường dùng database làm điểm tích hợp giữa các thành phần. Bằng việc sử dụng các thư viện, helper liên quan đến Database như CrudRepository với Java Bean trong Spring chẳng hạn, với cơ chế auto implement rất tiện lợi sẻ giúp chúng ta tiết kiệm rất nhiều effort trong việc phát triển ứng dụng. Trong Go và Nodejs ngày trước mình cũng sử dụng luôn các thư viện ORM cho việc implement data access logic, chúng thực sự hữu ích và tiện lợi đối với ứng dụng nhỏ.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên với Database Centric approach, vì Business Logic có xu hướng dính chặt với Data Access Logic đâm ra lúc Business cần thay đổi, mở rộng hoặc gở bỏ thường làm Dev rất vất vã do mọi thứ dính chùm với nhau. Tương tự việc optimize cũng diễn ra thực sự nhọc nhằn.&lt;/p&gt;

&lt;p&gt;Cùng với đó là sự gia tăng của complexity gây áp lực lên ứng dụng dựa trên Database Centric approach. Mình có cơ hội thấy hồi kết của approach này với một ứng dụng thực sự phức tạp. Sau một thời gian nhất định, mọi nổ lực để thêm mới Business Rules hoặc thay đổi một thứ gì đó gần như là không thể.&lt;/p&gt;

&lt;p&gt;Với cách tiếp cận này mình cũng có một trãi nghiệm cay đắng đó là khi phát triển một service dựa trên code base có sẳn với mô hình 3 lớp như trên. Về bản chất 3-Layered Architecture thực sự mạnh mẻ và có khả năng mở rộng cao, điều đó được chứng minh qua thời gian bởi đã có rất nhiều project thành công với lối kiến trúc này.&lt;/p&gt;

&lt;p&gt;3-Layered Architecture đã tách bạch các concerns với 3 tầng Presentation Layer, Business Layer và Data Layer. Điều đó gíup chúng ta đạt được tính linh hoạt và khả năng mở rộng cao cho một hệ thống phần mềm. Tuy nhiên khi làm việc cùng Database Centric Approach, các engineer thường vướng một sai lầm, mình cũng đã tiếp nối sai lầm của các engineer trước đó của một bộ source. Đó là việc dùng Transaction Script partern.&lt;/p&gt;

&lt;p&gt;Transaction Script biểu diễn business logic bằng code thủ tục với database, dễ dàng sử dụng cũng như giúp chúng ta tránh được những vấn đề performance với Database tuy nhiên sẻ làm cho Data Access Layer và Business Layer dính chặt với nhau.&lt;/p&gt;

&lt;p&gt;Khi bước vào với dự án mình đã cảm giác có gì đó không ổn và muốn chia thêm layer theo hướng Clean Architecture, nhưng với Database Centric approach, với Anamic Model approach và Transaction Script thì việc chia tầng là điều không thể làm đối với một lượng logic lớn. Bên cạnh đó việc thiếu khả năng thuyết phục cấp trên một khoản upfront cost cho một kiến trúc phức tạp ngay từ ban đầu với Domain Centric approach và Clean Architecture, cùng với đó là các yêu cầu business ập đến bắt buộc phãi sống chung với lũ, do đó technical debt liên tục tăng lên đến một thời điểm dường như không nhúc nhích được.&lt;/p&gt;
&lt;h4 id=&quot;3-anemic-domain-model-vs-rich-domain-model&quot;&gt;3. Anemic Domain Model vs Rich Domain Model&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/6.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Có một thực tế rằng trước khi nghiêm túc với DDD và apply nó vào dự án thì cho dù sau một số dự án lớn nhỏ dù đã biết những ý tưởng về Clean Architecture đi chăng nữa mình vẫn chưa nhận thức được tính thiết yếu của Rich Domain Model đối với một ứng dụng phức tạp.&lt;/p&gt;

&lt;p&gt;Một cách vô tình hay quán tính thì tất cả dự án trước đó mình tham gia đều sử dụng Anemic Domain Model. Đây chỉ là các Enitity model được biểu diễn bởi các class/struct chỉ chứa cấu trúc dữ liệu và mối quan hệ giữa chúng với các Entity khác. Với việc các Entity Model này ít khi chứa logic nghiệp vụ dẫn đến bắt buộc tụi mình phãi đẩy hết logic nghiệp vụ vào tầng service(đối với mô hình ba lớp) và đẩy vào tầng usecases(Clean Architecture).&lt;/p&gt;

&lt;p&gt;Cũng theo một lẻ tự nhiên, các Entity đó lập tức được ánh xạ quán tính 1:1 với một Table trong Database ngay. Lúc đó việc quản lí persisting của các Entity trở nên rối rắm.&lt;/p&gt;

&lt;p&gt;Hai tình huống xãy ra đó lúc đó: Một là chấp nhận việc lỏng lẻo trong consystency. Hai là dùng transaction script giữa nhiều Entity(đại diện cho nhiều Table) để quản lí transaction. Rõ ràng hãy thử tưởng tượng với một lượng logic khổng lồ xem nó sẻ rối như thế nào khi dùng transaction script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DDD đến cùng với cách tiếp cận hoàn toàn khác về việc chia code theo từng layer và model hoá dựa trên Rich Domain Model thay vì Anemic Model đã giúp giảm đi sự gia tăng phức tạp theo thời gian.&lt;/p&gt;

&lt;p&gt;Rich Domain Model vừa mô tả Domain Data Structure vừa mô tả các bihaviour của chúng. Các domain service/usecases chỉ cần chỉ định các Object Model thực thi domain logic(bihaviour trong chúng). Do đó giảm tải domain logic lên các service, usecases đồng thời giúp chúng ta dễ mở rộng hơn.&lt;/p&gt;

&lt;h4 id=&quot;4-conclusion&quot;&gt;4. Conclusion&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Một architecture tốt có giá trị cực kì to lớn trong việc tạo tiền đề, thúc đẩy những điều mới mẻ, hay ho hơn vào hệ thống của chúng ta thay vì làm chúng ta mất quá nhiều effort để lo những thứ mà architecture không tốt gây nên. Do đó, với tầm nhìn xây dựng một hệ thống phần mềm phức tạp, chúng ta nên ưu tiên một khoản upfront cost ban đầu cho việc xây dựng một kiến trúc tốt, mặc dù chi phí khởi tạo có vẻ đắt đỏ hơn so với các kiến trúc đơn giản khác nhưng về lâu về dài lại tối thiểu hoá được chi phí phát triển, vận hành và duy trì hệ thống.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Đối&lt;/em&gt; &lt;em&gt;với&lt;/em&gt; &lt;em&gt;các&lt;/em&gt; &lt;em&gt;hệ&lt;/em&gt; &lt;em&gt;thống&lt;/em&gt; &lt;em&gt;phức&lt;/em&gt; &lt;em&gt;tạp&lt;/em&gt; bằng việc sử dụng những kĩ thuật mà DDD refer như Domain Centric Approach với Rich Domain Model, sử dụng Value Object Type thay vì Primitive Type và nhiều kĩ thuật trong DDD mình chưa liệt kê, chúng sẻ giúp hệ thống của chúng ta mạnh mẻ hơn trước sự phức tạp, đáp ứng yêu cầu cho một kiến trúc tốt.&lt;/li&gt;
  &lt;li&gt;Bên cạnh đó các kiến thức về hoạch định chiến lượt mà DDD mang lại cũng có giá trị to lớn đối với các nhà quản lí. DDD không là viên đạn bạc cho mọi trận chiến nhưng là vũ khí cực kì tối tân cho các ứng dụng lớn và phức tạp.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html"></summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - What? and Why Domain Driven Design?</title><link href="https://romeo.vn/xam-xi-ve-ddd-part1-2/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - What? and Why Domain Driven Design?" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part1-2</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part1-2/">&lt;p&gt;Bài trước mình đã chia sẻ những cơ duyên mình đến với DDD và coi DDD như một kim chỉ nam để sống vui vẻ hạnh phúc trong việc phát triển phần mềm. Bài viết này chúng ta sẻ cùng thảo luận những nội dung chính sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;What is Domain?&lt;/li&gt;
  &lt;li&gt;What is Domain Driven Design?&lt;/li&gt;
  &lt;li&gt;Why we need Domain Driven Design?&lt;/li&gt;
  &lt;li&gt;What is the Ubiquitous Language?&lt;/li&gt;
  &lt;li&gt;Big picture about Domain Driven Design&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-what-is-domain&quot;&gt;1. What is Domain?&lt;/h3&gt;
&lt;p&gt;Ngày trước mình cũng lùng bùng bên tai khi nghe từ này, chẳng hiểu chính xác nó là gì. Đơn giản không thể hiểu vì bản chất từ này mang một ý nghĩa rất rộng, Domain là tất cả những gì mà một tổ chức đã, đang và sẻ làm và thế giới mà tổ chức đó thuộc về.&lt;/p&gt;

&lt;p&gt;Như chúng ta đều biết, các doanh nghiệp/tổ chức sẻ xác định thị trường và bán sản phẩm, dịch vụ của họ. Mỗi tổ chức, doanh nghiệp sẻ có các bí quyết và cách thức riêng biệt để thực hiện các thứ liên quan đến thị trường và sản phẩm dịch vụ của họ. Ví dụ như KFC sinh ra để cung cấp cho người tiêu dùng những bữa ăn nhanh, nhằm thoả mãn nhu cầu ăn uống cho những người bận rộn. Tiki hướng đến việc cung cấp một Marketplace để phục vụ người mua và người bán. Grab cung cấp một giải pháp kinh tế chia sẻ giữa tài xế, cửa hàng tiện ích, người đi mua hàng, người bán dịch vụ, người có nhu cầu đi lại….nhằm tối ưu hoá các hoạt động đi lại, mua sắm, vận chuyển….&lt;/p&gt;

&lt;p&gt;Tổng hợp của sự hiểu biết về thị trường hiểu biết về người dùng, quan hệ giữa các loại thực thể trong thế giới mà các doanh nghiệp đó muốn xây dựng nên, cộng với các phương pháp cách thức mà các doanh nghiệp đó tạo ra sản phẩm dịch vụ của họ sẻ được gói gọn bằng từ Domain.&lt;/p&gt;

&lt;h3 id=&quot;2-what-is-domain-driven-design-why-we-need-domain-driven-design&quot;&gt;2. What is Domain Driven Design? Why we need Domain Driven Design?&lt;/h3&gt;
&lt;p&gt;Việc phát triển một hệ thống lớn và phức tạp thật sự là một quá trình khó khăn và đau đơn. Từ phía đội ngủ quản lí, phía các engineers lẫn các stackholders liên quan khác đều có các vấn đề nan giải riêng.&lt;/p&gt;

&lt;h4 id=&quot;a-đứng-dưới-góc-độ-là-một-nhà-quản-lí&quot;&gt;a. Đứng dưới góc độ là một nhà quản lí:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Vấn đề Bottleneck: Việc decouple một Team lớn không hợp lí sẻ gây ra các hệ luỵ các tình huống thắt cổ chai trong việc phân chia trách nhiệm, nhiệm vụ hay đối phó với rủi ro ở những điểm tập trung.&lt;/li&gt;
  &lt;li&gt;Khó khăn trong việc đảm bảo tính hiệu quả trong việc phối hợp giữa các team: Trong quá trình phát triển một phần mềm lớn thì việc collaboration giữa các technical team, domain experts lẫn stakeholders thật sự diễn ra phức tạp, và một khi size của project tăng lên thì tính hiệu quả trong collaboration thực sự khó kiểm soát.&lt;/li&gt;
  &lt;li&gt;Quản lí risk và planning: Risk và planning thực sự là các vấn đề lớn trong việc phát triển các hệ thống lớn. Các rủi ro từ technical issues, management, internal lẫn external thực sự là ác mộng với các lãnh đạo. Việc cân bằng các yếu tố urgent và important chưa bao giờ có một lời giải chính xác tuyệt đối.&lt;/li&gt;
  &lt;li&gt;Vấn đề giao tiếp giữa technical team và business team: Trong việc phát triển một hệ thống lớn, phức tạp thì việc truyền tải thông tin, yêu cầu giữa Domain Expert hay BA team đến Dev team thường có một số rào cản nhất định về ngôn ngữ, context, cũng mindset giữa các team dẫn đến một số thiếu xót về domain knowledge. BA/Domain Expert thực sự khó chịu với Technical Team khi họ không có chung một tiếng nói. BA/Domain Expert luôn dựa trên các nhìn business trong lúc Dev thì áp đặt cái nhìn technical trong quá trình tiếp cận thông tin.&lt;/li&gt;
  &lt;li&gt;Phãi deliver các business goal một cách bền đều đặn, bền vững cùng với trãi nghiệm người dùng tốt nhất có thể: Các mục tiêu business cần được deliver một cách đều đặn, bền vững nhưng phần mềm thì ngày một giảm đi tính maintainable do nhiều nguyên nhân. Một trong các nguyên nhân lớn nhất đó là một architecture không tốt, ban đầu có thể deliver nhanh nhưng theo thời gian thì khả năng deliver giảm dần và chạm ngưỡng bằng 0. Business mở rộng như hệ thống thì ngày một mất đi khả năng mở rộng cũng như đáp ứng những yêu cầu cao hơn từ người dùng.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b-đứng-dưới-góc-độ-là-một-architecttechnical-expert-lẫn-engineer&quot;&gt;b. Đứng dưới góc độ là một Architect/Technical Expert lẫn engineer:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Bottom-Up và Top-Down approach: Đây là căn bệnh thường gặp trong việc phát triển các start-up, nơi mà đôi lúc Founder họ còn không biết họ đang muốn gì, họ muốn giải quyết gì cho khác hàng nhất. Việc tiếp nhận yêu cầu một cách lắc nhắc rơi vãi thay vì có một cái nhìn tổng quát trước dẫn đến nhiều sai lầm, hệ luỵ trong việc đưa ra quyết định cho các system design.&lt;/li&gt;
  &lt;li&gt;Vấn đề của kiến trúc monolith: Trong việc phát triển phần mềm chúng ta thường có thể có ý tưởng rằng nên tạo một model duy nhất, gắn kết chặt chẻ, bao gồm toàn bộ business domain của tổ chức, giống như một mô hình hoàn chỉnh của doanh nghiệp. Tuy nhiên bất kỳ nỗ lực nào để define business của một tổ chức vừa và lớn trong một model duy nhất bao gồm tất cả mọi thứ sẽ là rất khó khăn và thường sẽ thất bại vì quá rối rắm. Cùng với đó là việc phát triển một hệ thống monolith khổng lồ là nguyên nhân dẫn đến cơn đau đầu vô cùng nặng và dai dẳng, làm trì trệ tốc độ cũng như khó có thể linh hoạt được trong quá trình phát triển cũng như scale hệ thống.&lt;/li&gt;
  &lt;li&gt;Vấn đề Coupling: Như chúng ta đều biết thì chia để trị là một nghệ thuật trong phát triển phần mềm, một hệ thống được chia thành các component thực loosely-coupled sẻ mang lại giá trị scalable cũng như maintainable cao. Tuy nhiên một hệ thống phức tạp với quá nhiều quan hệ logic phức tạp không hề dễ cho chúng ta chia. Việc thiếu kĩ luật, thiếu xót hiểu biết về các phương pháp, principle cũng như nhận thức trong quá trình phát triển dẫn đến hệ thống của chúng ta dễ có xu hương dính lại với nhau gây ra nhiều chồng chéo rối rắm về mặt kiến trúc, gây ra nhiều hệ luỵ phãi trả giá đắt đỏ. Một khi chúng vượt khỏi tầm kiểm soát thì dù tăng quy mô số lượng dev gấp mấy cũng chỉ kéo tốc độ phát triển đi xuống mà thôi.&lt;/li&gt;
  &lt;li&gt;Thiếu xót kiến thức về Domain: Dev thiếu xót domain knowledge cũng dẫn đến nhiều hệ luỵ đớn đau. Thay vì tập trung đào sâu vào domain knowledge, Dev thường bị che mắt bởi data, infrastructure,…việc thiếu domain knowledge và có quá nhiều nhiều &lt;a href=&quot;https://en.wikipedia.org/wiki/God_object&quot;&gt;God object&lt;/a&gt; thực sự là cản trở lớn cho việc chia nhỏ hệ thống, làm chúng ta không biết nên chia như thế nào.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c-what-is-root-cause&quot;&gt;c. What is root cause?&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/9.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Các vấn đề liệt kê trên chỉ là một số ít thử thách trong quá trình phát triển phần mềm thôi. Trong thực tế còn nhiều thứ đáng lo hơn nhiều. Vậy tất cả chúng đa số bắt nguồn từ đâu?&lt;/p&gt;

&lt;p&gt;Thực tế các thử thách khó khăn đa phần đến từ complexity, đến từ chuyện có quá nhiều concerns quá nhiều thứ làm chúng ta distract.&lt;/p&gt;

&lt;p&gt;Để giải quyết các vấn đề trên bắt buộc chúng ta không còn cách nào khác là phải liên tục giảm độ phức tạp, tăng cường đàm phán loại bỏ các yếu tố gây nên sự phức tạp dựa trên nguyên tắc 80-20. Đồng thời đào sâu làm rõ kiến thức về Domain. Đó cũng là triết lý đầu tiên mà tác giả Eric Evans giới thiệu trong cuốn sách của ông ấy từ năm 2003.&lt;/p&gt;

&lt;h4 id=&quot;d-domain-driven-design&quot;&gt;d. Domain Driven Design&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/11.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DDD về cơ bản là một tập hợp các principles, parterns hướng đến việc thấu hiểu domain và khám phá các giá trị business. Từ đó tạo ra các model giàu ý nghĩa của domain đó đồng thời liên tục làm giàu và tôi luyện Ubiquitous Language, tự nhiên ắt sẻ giúp chúng ta thoả mãn các vấn đề kể trên sống vui vẻ hạnh phúc trong ngành phần mềm:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DDD yêu cầu Domain Expert/BA team làm việc với Dev team cũng như các bên liên quan khác dựa trên một tiếng nói chung(The Ubiquitous Language), khi đó việc translate requirement giữa Domain Expert/BA với các bên liên quan gần như bằng không, việc học hỏi củng cố domain knowledge sẻ dễ dàng và chính xác hơn.&lt;/li&gt;
  &lt;li&gt;DDD cung cấp cho chúng ta cả strategic lẫn tactical để mô model hoá phần mềm: Bounded context cho chúng ta một modeling boundary mà trong đó chúng ta sẻ tạo ra một solution cho một business problem cụ thể. Trong mỗi một Bounded Context là Ubiquitous Language được xây dựng bởi team, Ubiquitous Language được dùng cho giao tiếp trong Team. Mỗi team khác nhau đôi khi sẻ chịu trách nhiệm cho các Bounded Context khác nhau, DDD sẻ cung cấp một công cụ gọi là Context Map, sử dụng Context Map để phân tách các Bounded Context một cách có chủ đích có chiến lượt đồng thời hiểu các mối quan hệ giữa các Bounded Context và integrate giữa chúng. Trong mỗi Bounded Context chúng ta có thẻ sử dụng tactical, building block partern để model như Aggregates, Entities, Value Objects, Services, Domain Events, từ đó chúng ta có được một kiến trúc đảm bảo tính mở rộng cũng như maintainable.&lt;/li&gt;
  &lt;li&gt;Các Bounded Context được tổ chức một cách rõ ràng và các context map tổ chức tốt cũng như domain knowledge được cũng cố vững chắc sẻ giúp chúng ta tránh được sự bội thực về mặt ngữ nghĩa giữa các thuật ngữ, khái niệm, đối tượng. Các concepts sẻ được chia nhỏ, đổi tên, custom sao cho hợp lí sẻ giúp chúng ta tránh được việc đưa ra các God object. Đảm bảo hệ thống sẻ được chia nhỏ thành các phần đơn giản hơn đi theo các nguyên tắc Isolation, Low coupling, Comprehensibility, High cohesion, Parallelisation/Autonomy, do đó engineer team dễ dàng đáp ứng các yêu cầu logic lúc design ban đầu, logic ít chồng chéo đỡ nặng đầu hơn cũng như tổ chức code tốt hơn, có tầm nhìn tốt về hướng phát triển code base để dễ bảo trì, thay thế, bổ sung cũng như improve về sau. Các manager cũng dễ dàng quản lí phân công trách nhiệm cũng như đánh độ ưu tiên, đưa ra quyết định.&lt;/li&gt;
  &lt;li&gt;Việc các phần được chia ra đạt được tính Isolation, Parallelisation/Autonomy sẻ giúp chúng ta tăng tốc độ phát triển một cách tối đa nhất, loại bỏ tối đa các dấu hiệu quản lí tập trung, các dependencies trong dự án rõ ràng và dễ kiểm soát hơn giúp chúng ta tránh được các vấn đề coupling và bottlenecks trong development cũng như management. Microservice approach cũng chỉ là một cách tiếp cận trên con đường DDD mà thôi.&lt;/li&gt;
  &lt;li&gt;Về trãi nghiệm cá nhân, nếu có kiến thức về DDD sớm hơn và tốt hơn thì có thể các sai lầm về design trong các dự án đã phần nào tránh được, các approach như microservices, event sourcing, reactive system sẻ được nhìn nhận đúng đắn hơn đồng thời xử lí các business logic rối rắm phức tạp, các vấn đề scale, concurrency, consistency…đã được giải quyết một cách đơn giản, hiệu quả hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-what-is-the-ubiquitous-language&quot;&gt;3. What is the Ubiquitous Language?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để có thể phát triển một phần mềm cho một Domain cụ thể ít nhất chúng ta cần một cách mô tả Domain này. Viêc chỉ có một relational data model truyền thống hay thứ gì đó tương tự thực sự là không đủ. Chúng ta cần có khả năng mô tả không chỉ các đối tượng và mối quan hệ của chúng mà phãi mô tả những thứ khác linh động hơn như events, event flow, processes, business invariants, cách mà các đối tượng thay đổi theo thời gian… Chúng ta cần có thể thảo luận và phản biện về Domain với cả các developer lẫn các domain expert/BA. Những gì mà chúng ta cần đó được là Ubiquitous Language.&lt;/p&gt;

&lt;p&gt;Ubiquitous Language là một ngôn ngữ thống nhất được cả Domain Expert và Developers sử dụng để mô tả và thảo luận về Domain. Ngoài code ra thì Ubiquitous Language là trọng nhất của Domain Driven Design proccess. Chúng ta có thể document lại Ubiquitous Language theo nhiều cách khác nhau, ban đầu là phãi tạo ra các thuật ngữ thống nhất giữa developer mà domain expert. Các Business Logic, relationship có thể được mô tả bằng các domain specific languages, diagrams and flow charts, UML, Finite state machine, Data Flow, Event Storming….Đôi lúc có một số nhu cầu nhỏ, nhanh gọn chúng ta có thể sử dụng các domain specific languages build sẳn, cá nhân bản thân mình thấy đối với một team nhỏ tầm 6-9 người thì một Domain Specific Language như DSL của &lt;a href=&quot;https://goa.design/extend/dsls/&quot;&gt;GOA&lt;/a&gt; thì cũng đủ sài cho các bên liên quan.&lt;/p&gt;

&lt;h3 id=&quot;4-big-picture-about-domain-driven-design&quot;&gt;4. Big picture about Domain Driven Design:&lt;/h3&gt;
&lt;p&gt;Về DDD chủ yếu giúp chúng ta giải quyết sự complexity dựa trên ba công cụ chính:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Strategic Modeling&lt;/li&gt;
  &lt;li&gt;Tactical Modeling&lt;/li&gt;
  &lt;li&gt;Các Parterns/Architectures&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a-strategic-modeling&quot;&gt;A. Strategic Modeling:&lt;/h4&gt;
&lt;p&gt;Thiết kế các Enterprise Software cần được thực hiện một cách khôn ngoan và hợp lí, Strategic Modeling là tập hợp các cách tiếp cận nhằm giúp chúng ta mô hình hoá một hệ thống cho phép chúng ta có khả năng chia để trị domain lớn, lập kế hoạch cho tương lai cũng như đưa ra quyết định phù hợp với sứ mệnh và giá trị cốt lõi của domain mà chúng ta muốn làm.&lt;/p&gt;

&lt;p&gt;Strategic Modeling tập trung vào việc define cũng như sử dụng các Bounded Context, SubDomain, quản lí ngữ nghĩa của các concepts giữa các context khác nhau… đồng thời rất hữu ích để trong việc cung cấp các khía cạnh phản biện, tranh luận để tìm ra một strategic architecture tốt phù hợp với domain chúng ta hướng tới.&lt;/p&gt;

&lt;p&gt;Việc có một bản Context Map và các khái niệm cốt lõi chung giúp chúng ta dễ dàng improve bức tranh tổng quan của toàn hệ thống. Đặc biệt đối với Microservices approach, Strategic Modeling giúp chúng ta define và kết nối các service một cách đúng đắn tuân theo nguyên tắc low coupling, high cohesion bằng cách xác định các Bounded Context, Subdomain một cách phù hợp.&lt;/p&gt;

&lt;h4 id=&quot;b-tactical-modeling&quot;&gt;B. Tactical Modeling:&lt;/h4&gt;
&lt;p&gt;Đây sẻ là cách mà chúng ta mô hình hoá một cách có đường hướng chiến thuật trong các Bounded Context bằng cách sử dụng các building block partern của DDD như Aggregate, Repository, Factory, Services, Domain Event và các khái niệm liên quan như Entity, Value Objects,… để design các module một cách đúng đắn nhất&lt;/p&gt;

&lt;h4 id=&quot;c-các-parternsarchitectures&quot;&gt;C. Các Parterns/Architectures:&lt;/h4&gt;
&lt;p&gt;Có chiến thuật, có model rồi, chúng ta cần nhạy bén tuỳ vào các yêu cầu mục đích cụ thể mà chọn các mẫu architecture phù hợp ví dụ như Clean Architecture, CQRS/Event Sourcing,… sao cho vừa thoả mãn business đồng thời dễ dàng mở rộng thêm tính năng cũng như tối thiểu hoá chi phí maintain.&lt;/p&gt;

&lt;h3 id=&quot;5-conclusion&quot;&gt;5. Conclusion:&lt;/h3&gt;
&lt;p&gt;Tin học mà, tin rồi mới học. Nếu bạn tin rằng chúng ta sẻ có thể sống vui vẻ hạnh phúc trong ngành phần mềm nhờ vào DDD rồi thì ngại gì không đào sâu nó nào.&lt;/p&gt;

&lt;p&gt;Bài tiếp theo mình sẻ nói về công cụ đầu tiên và quan trọng nhất của Domain Driven Design - Strategic Modeling.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Bài trước mình đã chia sẻ những cơ duyên mình đến với DDD và coi DDD như một kim chỉ nam để sống vui vẻ hạnh phúc trong việc phát triển phần mềm. Bài viết này chúng ta sẻ cùng thảo luận những nội dung chính sau: What is Domain? What is Domain Driven Design? Why we need Domain Driven Design? What is the Ubiquitous Language? Big picture about Domain Driven Design</summary></entry><entry><title type="html">Introduce to Kafka</title><link href="https://romeo.vn/introduce-to-kafka/" rel="alternate" type="text/html" title="Introduce to Kafka" /><published>2018-09-16T21:10:00-05:00</published><updated>2018-09-16T21:10:00-05:00</updated><id>https://romeo.vn/introduce-to-kafka</id><content type="html" xml:base="https://romeo.vn/introduce-to-kafka/">&lt;p&gt;Trong các hệ thống Microservices và Reactive System, một trong những thứ không thể thiếu đó là các message broker/stream. Hiện tại team mình đang dùng Kafka cho mục đích chính cho integration, decouple hệ thống cũng như implement Event Sourcing partern.&lt;/p&gt;

&lt;p&gt;Với bài viết này mình sẻ ghi lại một chút kiến thức cũng như kinh nghiệm trong thời gian ngắn vừa rồi làm việc với Kafka. Mình sẻ giới thiệu hai nội dung chính sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Why Kafka? Các usecase của Kafka?&lt;/li&gt;
  &lt;li&gt;Kiến trúc của Kafka&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-why-kafka&quot;&gt;A. Why Kafka?&lt;/h3&gt;
&lt;p&gt;Trong thực tế Kafka có rất nhiều lợi ích, mình chỉ liệt kê ra một số usecases mà tụi mình đã và đang dùng cho dự án.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dùng làm message queue&lt;/li&gt;
  &lt;li&gt;Là công cụ thiết yếu cho việc Decouple hệ thống và Integration&lt;/li&gt;
  &lt;li&gt;Dùng cho việc implement các RPC function và Reactive System/Event Driven System&lt;/li&gt;
  &lt;li&gt;Là công cụ cực kì mạnh mẻ cho Data Streaming và xử lí Data Realtime&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-dùng-kafka-làm-message-queue&quot;&gt;1. Dùng Kafka làm message queue&lt;/h4&gt;
&lt;p&gt;Chúng ta bắt đầu bằng việc có một bài toán như sau: Nếu có 1 triệu người đặt hàng trên trang web của bạn cùng lúc, nó có thể tạo ra một số vấn đề concurrency như deadlock, race condition,…. lúc đó ý tưởng về việc sử lí các yêu cầu theo thứ tự ngay lập tức mang lại hiệu quả. Chúng ta sẻ sắp xếp các order vào một message queue để có thể đảm bảo thứ tự của chúng và kiểm soát được số lượng order được xử lí đồng thời, Kafka với một kiến trúc scalable là một trong những lựa chọn tốt giúp chúng ta xử lí được bài toán trên.&lt;/p&gt;

&lt;h4 id=&quot;2-là-công-cụ-thiết-yếu-cho-việc-decouple-hệ-thống-và-integration&quot;&gt;2. Là công cụ thiết yếu cho việc Decouple hệ thống và Integration&lt;/h4&gt;
&lt;p&gt;Khi làm việc với các hệ thống phức tạp chúng ta bắt buộc phãi thiết kế thành một hệ thống Low Coupling, High Cohesion. Kafka là công cụ cực kì mạnh mẻ cho việc decouple hệ thống, nó cho phép chúng ta phân tách các thành phần của hệ thống thành các thành phần độc lập, low coupling đồng thời đảm bảo High Cohesion.&lt;/p&gt;

&lt;p&gt;Trong một hệ thống lớn chúng ta thường sử dụng nhiều ngôn ngữ và công nghệ khác nhau tuỳ thuộc vào mục đích từng thành phần, hơn nữa việc duy trì dependencies cứng nhắc giữa các thành phần đôi lúc không cần thiết và đôi lúc phãi trả một cái giá lớn cho dependencies. Bằng cách giao tiếp thông qua kafka giữa các services với các format hợp lí bạn có có thể tách biệt được dependencies giữa các service, mỗi thành phần của hệ thống đều có thể phát triển, mở rộng một cách độc lập.&lt;/p&gt;

&lt;p&gt;Đặc biệt đối với Microservice Approach, chúng ta thường đối mặt với các vấn đề liên quan đến Internal Communication và xử lí lỗi trong communication giữa các services. Những dạng giao tiếp thường thấy có thể là call trực tiếp(thông qua http rest/gRPC/thrift….), giao tiếp thông qua việc sử dụng Asynchronous Messaging. Tuy nhiên đối với các hệ thống phãi xử lí một lượng lớn request trên kiến trúc Microservices cũng như kiến trúc Monolic truyền thống thì những lỗi như lỗi mạng, timeout, lỗi do bug….là điều không thể tránh khỏi. Message Streaming nói chung và Kafka nói riêng giúp hệ thống của chúng ta xử lí các lỗi trên một cách hiệu quả bằng cách implement các Circuit Breaker, một cách đơn giản nhất đó là lưu lại trạng thái các request lúc nào xử lí xong mới xoá request đó đi bất cứ lỗi nào xãy ra thì chúng ta đều có thể xử lí lại request đó.&lt;/p&gt;

&lt;h4 id=&quot;3-dùng-cho-việc-implement-các-rpc-function-và-reactive-systemevent-driven-system&quot;&gt;3. Dùng cho việc implement các RPC function và Reactive System/Event Driven System&lt;/h4&gt;
&lt;p&gt;Các ngôn ngữ lập trình truyền thống thường dựa trên thread và threadpools để xử lí các tác vụ đồng thời đơn cử như là Java theo mặc định mỗi thread thường chiếm 1MB trong stack size(trên JVM 64bit) và chúng ta có thể config stack size tuỳ ý. Việc cấp phát một thread thường khá đắt đỏ trong CPU cho nên chúng ta thường sẻ phãi config size của threadpools trước, mỗi khi có request tới, web server sẻ pick một thread trong threadpools và kêu nó xử lí reuqest, các thread trên sẻ xử lí các tác vụ một cách song song. Nếu bạn giữ các giá trị như mặc định thì nếu config 1k thread trong thread pool đồng nghĩa với việc bạn sẻ dùng hết gần 1G Ram.&lt;/p&gt;

&lt;p&gt;Đối với hệ thống lớn chúng ta sẻ gặp phãi hai vấn đề về thread đó là stack size và threadpools size. Nếu config stack size mỗi thread nhỏ xuống thì sẻ tiết kiệm được nhiều bộ nhớ nhưng khi một thread nào đó đòi hỏi tính toán nhiều thì dễ gây ra stack overflow. Cũng như vậy đối với threadpools size, khi chúng ta giữ một lượng lớn thread trong threadpool thì memory cost và switching context cost sẻ là rất cao và hệ thống sẻ trở nên khó kiểm soát, ngược lại khi giữ một số lượng thread nhỏ hơn thì lại làm giảm tính available của hệ thống.&lt;/p&gt;

&lt;p&gt;Nếu hệ thống chúng ta có các tác vụ tính toán mất thời gian, tốn tài nguyên, khó thể ước tính thời gian và tài nguyên cho mỗi yêu cầu nhưng lại không nhất thiết phãi response ngay lập tức thì chúng ta có thể sử dụng mô hình RPC.&lt;/p&gt;

&lt;p&gt;Các hệ thống ngày càng phát triển đòi hỏi một tốc độ phản hồi cao, đối mặt tốt với các lỗi cũng như đòi hỏi mức downtime = 0, đồng thời đáp ứng khả năng mở rộng tuyệt vời với không một điểm thắt cổ chai. Đó là mục tiêu người ta xây dựng nên Reactive System với mọi thứ hướng theo Event.
Kafka với khả năng mở rộng tuyệt vời và đáng tin cậy do đó là một lựa chọn khá tốt để xử lí các event trong mô hình này.&lt;/p&gt;

&lt;h4 id=&quot;4-đối-với-stream-proccessing-data-realtime&quot;&gt;4. Đối với Stream Proccessing data realtime.&lt;/h4&gt;
&lt;p&gt;Trong các hệ thống hướng Data, các yêu cầu report một con số gì đó trong thời gian ngắn để make một decision là rất phổ biến. Trong một hệ thống lớn với lượng Data khổng lồ thì việc xử lí một lượng lớn Data như vậy bằng Batch Proccessing là điều rất tốn thời gian cũng như tài nguyên. Do đó sử dụng Kafka đổ reduce ra một kết quả sẻ giúp chúng ta dễ hiện thực tính năng đó hơn.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó cũng sẻ có những yêu cầu về việc phân tích Data Realtime, đưa ra report gần như chính xác tại mỗi thời điểm,…lúc đó những Message Stream như Kafka cùng với các tool liên quan đến Big Data như Hadoop, Spark là giải pháp tuyệt vời.&lt;/p&gt;

&lt;h3 id=&quot;b-kiến-trúc-kafka&quot;&gt;B. Kiến trúc kafka:&lt;/h3&gt;
&lt;p&gt;Cơ chế hoạt động cơ bản của Kafka hình dung đơn giản giống như Logs system, các log record được lưu lên đĩa và sắp xếp theo thứ tự thời gian, Kafka tổ chức phân loại các messages theo khái niệm Topic hình dung giống như tag trong việc quản lí Log của chúng ta.&lt;/p&gt;

&lt;p&gt;Mỗi khi cài đặt Kafka một trong những việc ta cần làm là setup nơi mà log sẻ được lưu xuống-url của log.dir, mỗi topic sẻ được map với thư mục con bên trong thư mục log của chúng ta và cũng có thêm nhiều thư mục con nữa đó là các thư mục topic partitions với tên thư mục format là topic-name_partition-number, bên trong mỗi thư mục sẻ là file log nơi mà message tới sẻ được append vào.&lt;/p&gt;

&lt;p&gt;Mỗi Topic có một hoặc nhiều Partitions và mỗi Partition là một list các messages, khi một message được chia sẻ lên Kafka theo Topic, message sẻ được gửi vào một Partition của Topic, việc lưu message xuống Partition nào được quyết định bởi các producers. Nếu ta muốn message xuống Partition cụ thể nào đó thì ta phãi set partition_key cho message đó ứng với Partition ta muốn message xuống, nếu không mặc định message sẻ được phân phối theo giải thuật round-robin.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicA_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Như trên chúng ta có thể thấy rằng topic A có 1 partition, topic B có 2 partitions và C có 3 partitions. Vậy partition đó là gì, dùng để làm gì?&lt;/p&gt;

&lt;p&gt;Partitions là một phần quan trọng trong thiết kế của kafka. Các partitions chia luồng message đến một topic vào các luồng song song và đó là chìa khoá giúp Kafka đạt được một lượng message khổng lồ. Tuy nhiên thứ tự message đến từ các partitions khác nhau không được đảm bảo, Kafka chỉ đảm bảo thứ tự message trong cùng một partition, do đó trong trường hợp chúng ta cần đảm bảo thứ tự message cho nhiều tác vụ nào đó, chắc chắn các message xử lí các tác vụ đó phãi được sắp xếp vào cùng 1 topic và cùng một partion_key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mỗi Partition có thể được phân tán trên nhiều máy và mỗi máy như thế được gọi là một Broker, mỗi Broker có thể có 0 1 hoặc nhiều Partitions của cùng 1 Topic hoặc thậm chí các topic khác nhau.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka hổ trợ Replication để đảm bảo tính high-availability và tính fault-tolerance. Mỗi partition có thể có nhiều bản replicas tuỳ thuộc vào số replication factor mà ta config.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ có các leader partitions mới được nhận message, leader partitions nhận message sau đo mới đồng bộ lên các replicas partitions khác. Trong trường hợp một leader partition chết thì một trong những replica của partition được chọn để làm leader partition. Đến khi partition kia sống lại thì nó trở thành replica và phãi fetch lại tất cả data chưa đồng bộ được trong quá trình chết đi từ các partition khác. Kafka dùng ZOOKEEPER để handle chuyện đó, Kafka dùng nó để thực hiện việc leadership electron các kafka broker và các cặp Topic Partition, ZOOKEEPER cũng đứng vai trò là Service Discovery cho các Kafka Brokers từ các cluster, xử lí các trường hợp broker nào join vào, broker nào chết đi, topic nào được add vào topic nào bị remove đi….&lt;/p&gt;

&lt;p&gt;Rõ ràng nhìn vào kiến trúc của Kafka chúng ta thấy rằng nó hoàn toàn thoã mãn hai đặc điểm đó là High-availability và Durability.&lt;/p&gt;

&lt;p&gt;Cách hoạt động của Kafka producers khá đơn giản, ban đầu các producers phãi fetch các metadata lên ví dụ như chúng cần biết có các topics nào đang tồn tại? có bao nhiêu partition mỗi topic đang có? leader broker hiện tại của mỗi partition là node nào? host và port của mỗi broker đó là sao? Sau đó chúng làm việc trực tiếp với các broker khác nhau mà không có một sự điều phối nào.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế đó kafka producers đã loại bỏ triệt để vấn đề write-bottleneck, đồng thời giúp cho mỗi broker nhận được một số lượng messages hợp lí, dễ dàng mở rộng một cách tuyến tính, khi muốn mở rộng chỉ cần thêm partition và broker vào.&lt;/p&gt;

&lt;p&gt;Như vậy nhìn chung thì Kafka producers tương đối đơn giản tuy nhiên đối với Kafka consumers thì phức tạp hơn nhiều. Cũng giống như Kafka producer, Kafka consumers bắt đầu các hoạt động của chúng bằng việc fetch các metadata, mỗi consumer có thể kết nối tới nhiều brokers và đọc từ nhiều replicas. Mỗi broker xử lí một tập hợp các partition của các topics mà consumer subsribe tới cùng lúc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nhờ thiết kế đó mà workload giữa các broker được cân bằng đồng thời giảm thiểu vấn đề read-bottleneck. Hơn nữa mỗi consumer có nhiều replicas để đọc giúp tăng tính availability và cân bằng workload giữa các consumer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ với thiết kế đó thì vẫn chưa đảm bảo tính scalable, khái niệm consumer group sinh ra giúp chúng ta dễ dàng scale các consumers. Theo đó mỗi consumer sẻ thuộc về một consumer group hay nói cách khác một consumer group sẻ chứa các consumer và message sẻ được phân phát đến tất cả consumer group, mỗi member của group sẻ xử lí message từ một hoặc nhiều partitions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế này, mỗi consumer có thể xử lí message từ nhiều partitions, đảm bảo cover hết tất cả các partition cũng như thứ tự xử lí message trong mỗi partition đồng thời cân bằng tải giữa các consumers trong cùng một group. Khi chúng ta muốn scale lên chỉ cần tăng số brokers, tăng số partitions và tăng số consumers. Nhìn lại một lần nữa vào ví dụ trên, chúng ta có thể thấy rằng thiết kế trên cho phép mỗi consumer có thể xử lí nhiều partitions cùng lúc chứ không cho phép nhiều consumers cùng lúc xử lí một partition cho nên giả dụ như chúng ta có 5 partitions nhưng có đến 6 cunsumers thì hiển nhiên 1 consumer ngồi chơi làm phí phạm tài nguyên hệ thống, cho nên khi scale thì nên lưu ý rằng số consumers luôn bé hơn hoặc bằng số partitions mà tốt nhất là bằng nhau thì hơn.&lt;/p&gt;

&lt;p&gt;Updating….&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="kafka" /><category term="event-driven" /><category term="microservice" /><summary type="html">Trong các hệ thống Microservices và Reactive System, một trong những thứ không thể thiếu đó là các message broker/stream. Hiện tại team mình đang dùng Kafka cho mục đích chính cho integration, decouple hệ thống cũng như implement Event Sourcing partern.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/2018-07-16-nhung-van-de-kafka-giai-quyet/1.png" /></entry><entry><title type="html">Introduce To GoKit</title><link href="https://romeo.vn/introduce-gokit/" rel="alternate" type="text/html" title="Introduce To GoKit" /><published>2018-08-06T20:15:00-05:00</published><updated>2018-08-06T20:15:00-05:00</updated><id>https://romeo.vn/introduce-gokit</id><content type="html" xml:base="https://romeo.vn/introduce-gokit/">&lt;h3 id=&quot;1-sơ-lược-về-gokit&quot;&gt;1. Sơ lược về Gokit&lt;/h3&gt;
&lt;p&gt;Golang là ngôn ngữ tuyệt vời cho việc phát triển hệ thống Microservices,  Go thực sự mang lại những trãi nghiệm tốt về hiệu xuất lẫn sự đơn giản thân thiện đối với Developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất hữu ích, đồng thời giúp cho việc phát triển phần mềm với Go trở nên dễ dàng hơn.&lt;/p&gt;

&lt;p&gt;Gokit là một bộ toolkit tuyệt vời cho việc xây dựng các Microservices với Go. Gokit cung cấp cho chúng ta các quy tắc, ý tưởng về kiến trúc nhằm giúp Developer tập trung hơn vào việc phát triển Business Logic, tránh khỏi các mối quan tâm về Operational lẫn Infrastructural.&lt;/p&gt;

&lt;p&gt;Gokit là bộ toolkit nhẹ nhàng nhưng cung cấp gần như đầy đủ các thư viện đồ chơi cho một hệ thống service mesh, từ Logging, Metrics, Tracing, Rate-Limiting, Circuit Breaking cho đến Service Discovery, Pub/Sub…&lt;/p&gt;

&lt;p&gt;Tuy ban đầu Gokit được giới thiệu là thích hợp cho việc build các Microservices nhưng trong quá trình làm việc cá nhân mình thấy Gokit phù hợp với Monolith không kém. Với Gokit, Developer cần tuân theo một số nguyên tắc sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Phãi nắm bắt và tuân thủ các nguyên tắc thiết kế như SOLID, DDD, Clean Architecture và áp dụng chặt chẻ.&lt;/li&gt;
  &lt;li&gt;Các Interfaces được sử dụng như các quy ước.&lt;/li&gt;
  &lt;li&gt;Đảm bảo hạn chế sử dụng global state.&lt;/li&gt;
  &lt;li&gt;Các component, dependencies nên được tổ chức một cách rõ ràng và declarative composition trong hàm main.&lt;/li&gt;
  &lt;li&gt;Ưu tiên composition hơn inheritance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-kiến-trúc-của-gokit&quot;&gt;2. Kiến trúc của Gokit:&lt;/h3&gt;
&lt;p&gt;Gokit được chia làm ba Layer chính đó là&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Transport Layer&lt;/li&gt;
  &lt;li&gt;Endpoint Layer&lt;/li&gt;
  &lt;li&gt;Service Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;service-layer&quot;&gt;Service Layer:&lt;/h4&gt;
&lt;p&gt;Đây là tầng quan trọng nhất, nơi mà Developer cần chú trọng quan tâm nhất, là nơi chứa các domain của ứng dụng cũng như implementation của tất cả Business Logic cho ứng dụng. Service Layer được tổ chức tách biệt hoàn toàn với các phần còn lại.&lt;/p&gt;

&lt;h4 id=&quot;hai-tầng-transport-và-endpoint&quot;&gt;Hai tầng Transport và Endpoint:&lt;/h4&gt;
&lt;p&gt;Hai tầng này nằm ở tầng Interface của Clean Architect như bài trước mình đã giới thiệu về Clean Architecture https://romeo.vn/clean-architecture/.&lt;/p&gt;

&lt;p&gt;Tầng transaport được liên kết với các transaport protocol cụ thể như Http, gRPC, Pub/Sub nhằm lấy request từ client và encoding/decoding request.&lt;/p&gt;

&lt;p&gt;Trong Gokit thì RPC là giao thức chính được ưu tiên nhất, mỗi service method trong Gokit sẻ được chuyển đổi thành một RPC Endpoint để giao tiếp giữa client và server. Mỗi endpoint sẻ expose một service method ra ngoài bằng cách sử dụng Transport liên kết với một giao thức Transport cụ thể như Http Rest/gRPC hay Pub/Sub.&lt;/p&gt;

&lt;h3 id=&quot;các-middlewares&quot;&gt;Các Middlewares:&lt;/h3&gt;
&lt;p&gt;Giống như các ngôn ngữ OOP như Typescript, Java, C#. Việc tổ chức các Cross-Cutting Concern components( ví dụ như Logger, Circuit Breakers, Rate Limiting, Load Balancing, hay Distributed Tracing…) chúng ta thường dùng các Decorator. Với Gokit nói riêng và Go-lang nói chung chúng ta cũng dùng các Decorator. Tuy nhiên cách implement Decorator Patterns trong Golang có chút khác so với các ngôn ngữ khác, nhìn giống Middleware hơn.&lt;/p&gt;

&lt;p&gt;Gokit Middlewares cho phép chúng ta bọc các Endpoints/Services bằng các hàm nhằm handle các Cross-Cutting Concern.&lt;/p&gt;

&lt;p&gt;Dưới đây là một hình ảnh mô tả kiến trúc của Gokit mình copy từ trang web chính thức của Gokit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gokit.io/faq/onion.png&quot; alt=&quot;Atom&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;note&quot;&gt;Note&lt;/h3&gt;
&lt;p&gt;Việc phụ thuộc vào một thư viện, tool kit là điều không nên khi xây dựng kiến trúc một phần mềm. Tuy nhiên việc tận dụng những gì sẳn có mà một thư viện toolkit nào đó cung cấp, những thứ khớp với mục đích của chúng ta có thể giúp chúng ta đẩy nhanh được tiến độ dự án. Bên cạnh đó với nhận thức về cái giá của dependencies thì chúng ta cũng có thể dễ dàng gở bỏ, thay thế những thư viện toolkit này một cách nhanh chóng và đơn giản trong tương lai.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="golang" /><category term="gokit" /><category term="microservices" /><summary type="html">1. Sơ lược về Gokit Golang là ngôn ngữ tuyệt vời cho việc phát triển hệ thống Microservices, Go thực sự mang lại những trãi nghiệm tốt về hiệu xuất lẫn sự đơn giản thân thiện đối với Developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất hữu ích, đồng thời giúp cho việc phát triển phần mềm với Go trở nên dễ dàng hơn.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Introduce To Clean Architecture</title><link href="https://romeo.vn/clean-architecture/" rel="alternate" type="text/html" title=" Introduce To Clean Architecture" /><published>2018-07-20T09:01:00-05:00</published><updated>2018-07-20T09:01:00-05:00</updated><id>https://romeo.vn/clean-architecture</id><content type="html" xml:base="https://romeo.vn/clean-architecture/">&lt;p&gt;Trong bài viết này chúng ta sẻ cùng thảo luận về một loạt các patterns, principles, paradigms nhằm tạo ra một kiến trúc tốt hơn nhằm thay thế cho các approaches không thực sự còn hợp thời nữa, đặc biệt là các concepts trong Clean Architecture. Bài viết này mình sẻ thảo luận về một số mục chính sau:&lt;/p&gt;

&lt;p&gt;I. Software Architecture là gì? Tại sao chúng ta cần tìm hiểu chúng?&lt;/p&gt;

&lt;p&gt;II. Những gì cấu nên Software Architecture&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Các promgramming paradigms&lt;/li&gt;
  &lt;li&gt;Các design principles&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;III. Một architecture tốt sẻ trông như thế nào?&lt;/p&gt;

&lt;p&gt;IV. Clean Architecture&lt;/p&gt;

&lt;p&gt;Trước khi bắt đầu thảo luận về các mục chính, mình xin chia sẻ một chút về quá trình tiếp xúc với các mẫu kiến trúc của mình.&lt;/p&gt;

&lt;p&gt;Điểm xuất phát của mình dường như nó không đi theo con đường “chính đạo” như các bạn các anh chị đi trước. Đa số các tiền bối đi trước thường xuất phát với Java, C#, Scala,…. Việc xuất phát với các ngôn ngữ framework dựa trên các ngôn ngữ đó phần nào mang lại lợi ích nhất đích định dựa vào sự trưởng thành của ecosystem ứng với ngôn ngữ đó, dựa vào cộng đồng lớn cùng với các kiến thức cực kì cần thiết trong OOP cũng như Design parterns, do đó mang lại cái nhìn sớm hơn, đúng đắn và đầy đủ hơn về architecture cũng như system design.&lt;/p&gt;

&lt;p&gt;Mình thì ngược lại, mình bắt đầu sự nghiệp coder với một dự án startup với công nghệ chính là Node.js, code không theo một paradigm cụ thể nào cả, OOP cũng không hẳn là OOP, Functional cũng không hẳn là Functional, Functional Reactive cũng không ra Functional Reactive, qua một thời gian thì mọi thứ gần như out of control và không có cơ hội cứu chữa trừ khi đập đi làm lại. Và thực tế là dự án đó đã đập đi làm lại rất nhiều lần tuy nhiên không có một kiến trúc vững trãi thì sau một thời gian lại đâu vào đấy, out of control.&lt;/p&gt;

&lt;p&gt;Sau một thời gian dài code quán tính thì không những không xây dựng được tư duy kiến trúc, tư duy tổ chức và làm mình khó nhồi nhét tư duy design sau này. Thật may lúc đó mình có cơ hội cho công việc mới dù kết thúc sớm vì một số lí do nhưng nhờ chính cơ hội đó đã mở ra cho mình một số kiến thức hay ho, mang lại lợi ích to lớn sau này.&lt;/p&gt;

&lt;p&gt;Yêu cầu công việc của mình thời điểm đó là tìm hiểu và áp dụng Clean Architecture vào dự án với Golang với một tài liệu duy nhất là bài viết này &lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;The Clean Architecture&lt;/a&gt;. Một task với description cực kì ngắn gọn nhưng không hề đơn giản tí nào cho một con gà tại thời điểm đó. Với tư duy tổ chức kém, hỏng kiến thức về OOP lẫn design partern thì quả thực Clean Architecture là một thứ gì đó quá xa vời.&lt;/p&gt;

&lt;p&gt;Clean Architecture yêu cầu phãi xâu chuổi tất cả kiến thức tổ chức code, từ sự hiểu biết và kinh nghiệ về các Programming paradigms, các Design Parterns ở OOP cũng như ở các paradigms khác, tiếp đến mới là các Design Principles như SOLID Principles, Component Principles rồi mới đến các nguyên tắc, các mẫu kiến trúc cho phần mềm. Thực tế thì không chỉ là Clean Architecture mà tất cả các kiến trúc khác đều dựa trên những nguyên tắc chung đó mà xây dựng nên.&lt;/p&gt;

&lt;p&gt;Sau một thời gian với nhiều may mắn được làm việc với các dự án từ Golang đến Typescript mình tóm tắt lại quá trình mình tiếp cận với Clean Architecture nói riêng và các quy tắc lập trình, tổ chức code nói chung cũng và cũng là dịp để mình ôn lại kiến thức, kĩ năng lẫn thói quen nhằm ghi nhớ sâu hơn hoặc ai đó đang tìm hiểu hoặc đang implement Clean Architecture vô tình đọc bài này có thể cảm nhận và phản biện giúp mình cũng cố kiến thức hơn.&lt;/p&gt;

&lt;h3 id=&quot;i-software-architecture-là-gì-tại-sao-chúng-ta-phãi-tìm-hiểu-chúng&quot;&gt;I. SOFTWARE ARCHITECTURE LÀ GÌ? TẠI SAO CHÚNG TA PHÃI TÌM HIỂU CHÚNG?&lt;/h3&gt;
&lt;p&gt;Như chúng ta đều biết thì với yêu cầu của việc phát triển phần mềm thì việc phát triển đội ngủ về số lượng luôn là điều hiển nhiên. Tuy nhiên sự phát triển của số lượng chưa hẳn sẻ kéo theo sự phát triển chất lượng và tốc độ phát triển phần mềm.&lt;/p&gt;

&lt;p&gt;Một sự thật đớn đau là theo các con số thống kê, đa số phần mềm khi phát đến một mức nào đó thì cho dù tăng thêm số lượng engineer đến bao nhiêu cũng không thể kéo tốc độ cũng như chất lượng lên được nữa, cũng có thể là tốc độ và chất lượng lại đi xuống. Tức nhiên là chẳng ai muốn điều đó xãy ra, ai cũng luôn luôn cố gắn phát triển cả. Nhưng với việc tổ chức kém code base ban đầu, việc out of control chất lượng code, độ phình to của software mà không có một chiến lược tái cấu trúc hợp lí….tất cả các nguyên nhân đó tạo ra một đống hổn độn mà không một cá nhân nào trong đó không muốn “đập đi làm lại cmn đi”.&lt;/p&gt;

&lt;p&gt;Các Software Architecture sinh ra để giải quyết bài toán đầu tiên về tổ chức cũng như độ dễ của việc duy trì một code base sạch sẻ gọn gàn, nhằm giảm tối đa resource để xây dựng phát triển cũng như maintain đồng thời tăng khả năng mở rộng về mặt hệ thống lẫn số lượng engineer.&lt;/p&gt;

&lt;h3 id=&quot;ii-các-programming-paradigms&quot;&gt;II. CÁC PROGRAMMING PARADIGMS:&lt;/h3&gt;

&lt;p&gt;Như chúng ta đều biết thì các Architectures đều bắt đầu từ code, do đó các Paradigms sẻ cho chúng ta biết cách tổ chức nào sẻ được sử dụng. Đến nay thì mình chỉ mới tiếp cận được 3 Programming Paradigms nên có thể nêu lên quan điểm cá nhân của mình như sau:&lt;/p&gt;

&lt;h4 id=&quot;1object-oriented-programmingoop&quot;&gt;1.Object Oriented Programming(OOP):&lt;/h4&gt;

&lt;p&gt;Đây dường như đây là Paradigm thịnh hành nhất hiện tại với các ưu điểm đáng kể.&lt;/p&gt;

&lt;p&gt;Việc hiểu rõ các tính chất cũng như các nguyên tắc design trong OOP giúp chúng ta dễ tổ chức, phát triển và maintain, dễ module hoá, tính reusable cao và cũng như cho phép chúng ta dễ dàng phát triển các module một cách song song.&lt;/p&gt;

&lt;p&gt;Tuy nhiên OOP cũng có nhiều hạn chế. Về coding style, OOP nhìn chung là quá imperative, tập trung trả lời câu hỏi “How?”(làm sao để làm điều đó) hơn là câu hỏi “What?”(chúng ta muốn gì ở đây), khi đọc code chúng ta khó nhanh chóng hiểu được người viết muốn gì.&lt;/p&gt;

&lt;p&gt;Nhược điểm thứ hai đó là về vấn đề race condition, trong concurrent programming đây là vấn đề thường gặp và rất tốn công giải quyết, việc chia sẻ trạng thái trong lập trình hướng đối tượng là một trong các nguyên nhân chủ yếu dẫn đến race condition và khiến ta khó debug cũng như fix bug.&lt;/p&gt;

&lt;h4 id=&quot;2functional-programmingfp&quot;&gt;2.Functional Programming(FP):&lt;/h4&gt;
&lt;p&gt;Những năm gần đây FP nổi lên như một xu hướng mà các lập trình viên đang theo đuổi và dần chuyển đổi, không chỉ mang lại những trải nghiệm mới mà FP xử lí một số vấn đề hạn chế của OOP.&lt;/p&gt;

&lt;p&gt;Về coding style nhìn chung FP theo trường phái declarative, tập trung trả lời câu hỏi “What?”(chúng ta muốn gì), giúp chúng ta nhanh chóng hiểu code trong lúc maintain, fix bug.&lt;/p&gt;

&lt;p&gt;Việc sử dụng các pure functions mang lại cho chúng ta các functions đáng tin cậy hơn, hạn chế tối đa side effect có thể xãy ra do đó các hàm luôn luôn chỉ trả đúng kết quả mà chúng ta mong đợi.&lt;/p&gt;

&lt;p&gt;Về mặt Architecture, tính IMMUTABILITY là tính chất rất quan trọng mà chúng ta cần xem xét. Đứng ở vị trí là một Backend Engineer ngoài các vấn đề thuật toán, design hay architectures thì các engineer thường coi trọng nhất các vấn đề về concurency như race condition, deadlock conditions và concurrent update. Tất cả chúng sinh ra do đâu? chỉ có thể là do tính mutable của biến.&lt;/p&gt;

&lt;p&gt;Chúng ta sẻ không dính bất cứ race condition hoặc concurrent update nào khi không có một biến/shared memory nào được cập nhật. Chúng ta sẻ không dính bất cứ deadlocks nào nếu không có mutable locks. Hay nói cách khác tất cả vấn đề concurrency, tất cả vấn đề chúng ta đối mặt trong hệ thống multiple threads/multiple processors sẻ không bao giờ xãy ra nếu không có bất cứ mutable variables nào.&lt;/p&gt;

&lt;p&gt;Ở vị trí Backend Enginner chúng ta luôn muốn thiết kế một hệ thống mạnh mẻ với sự có mặt của multi threads multi processors sau đó câu hỏi mà chúng ta tự hỏi chính mình đó là tính immutability có luôn được thực hiện được hay không? Câu trả lời tức nhiên sẻ là không rồi, tuy nhiên chúng ta sẻ có những kĩ thuật nhằm phân tích các thành phần mutable và các thành phần immutable sau đó tách biệt chúng ra. Các thành phần immutable bắt buộc chúng ta phãi implement một cách purely functional và các thành phần mutable bắt buộc chúng ta phãi cân nhắc sử dụng một số loại transaction memory để tránh khỏi vấn đề concurrent updates và race conditions.&lt;/p&gt;

&lt;p&gt;Tuy nhiên nó vẫn chưa được bảo vệ hoàn toàn khỏi vấn đề concurrent updates và deadlocks khi có quá nhiều biến phụ thuộc xuất hiện, khi đó chúng ta lại phãi cân nhắc tách và chuyển các thành phần mutable thành các thành phần immutable nhiều nhất có thể và tập trung đẩy càng nhiều tài nguyên nhất có thể vào các thành phần immutable. Ngoài ra việc thay đổi, tận dụng sức mạnh xử lí của hệ thống máy tính hiện đại kết hợp cùng các kĩ thuật xử lí theo event, cron job,…. có thể giúp chúng ta giải quyết phần nào hiệu quả các vấn đề trên.&lt;/p&gt;

&lt;h4 id=&quot;3-reactive--functional-reactive-programmingfrp&quot;&gt;3. Reactive &amp;amp; Functional Reactive Programming(FRP):&lt;/h4&gt;

&lt;p&gt;Đối với hầu hết các lập trình viên Javascript thì đây là một Paradigm không quá xa lạ, là sự hợp thành của 2 Paradigms Functional và Reactive(Events/Data stream Driven, Push, Asynchronous).&lt;/p&gt;

&lt;p&gt;Đây là một Paradigm giúp chúng ta code Declarative hơn, dễ hiểu hơn theo hướng event, giúp đơn giản hoá việc xử lí bất đồng bộ đồng thời tránh đi việc gọi quá nhiều callback gây callback hell hoặc dùng promise/async-await mà quên đi tính event driven khi code. Ngoài ra đây cũng là một Paradigm giúp engineer xử lí concurent với một mô hình khác(event driven) ở mức low-level thông qua các khái niệm như observables, observers, operators, scheduler….&lt;/p&gt;

&lt;h3 id=&quot;iiicác-design-principles&quot;&gt;III.CÁC DESIGN PRINCIPLES:&lt;/h3&gt;
&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng việc clean code, nó cũng giống như việc xây nhà, khi bắt đầu điều tiên quyết chúng ta cần có đó là những viên gạch tốt. Những viên gạch đã không tốt thì cho dù kiến trúc tổ chức tốt đến nhừng nào cũng chỉ là trên bản vẻ mà thôi, khi xây nên hoàn toàn dễ dàng sụp đổ. Mặt khác khi bạn đã có các viên gạch đủ tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn.&lt;/p&gt;

&lt;p&gt;Để cấu nên một toà nhà lớn chúng ta nên chia nhỏ phát triển từng components bằng cách abstract hoá lên rồi lại separate ra một cách thích hợp để tạo thành các components nhỏ dễ cho việc quản lí, tái sử dụng cũng như gỡ bỏ khi không cần nữa.&lt;/p&gt;

&lt;p&gt;Các Design Principles sinh ra nhằm giúp chúng ta thực hiện việc đó ở mức độ hight-level/mid-level/low-level như việc tổ chức tốt các thành phần từ đơn vị nhỏ như ghép nối các viên gạch thành cấu trúc từng bức tường.&lt;/p&gt;

&lt;p&gt;Các design parterns cho chúng ta biết cách xắp xếp các hàm, các cấu trúc dữ liệu vào các class, struct và kết nối chúng lại với nhau để xây dựng nên các module hoàn chỉnh dễ dàng thay đổi, dễ hiểu cho người mới và đồng thời dễ tái sử dụng code, tiết kiệm effort hơn.&lt;/p&gt;

&lt;p&gt;Các Principles chúng ta nên tham khảo và áp dụng như Component Principles, SOLID Principles,… Các bạn có thể xem lại &lt;a href=&quot;https://romeo.vn/solid-principle/&quot;&gt;SOLID Principles&lt;/a&gt; .&lt;/p&gt;

&lt;h3 id=&quot;iii-một-architecture-tốt-sẻ-trông-như-thế-nào&quot;&gt;III. MỘT ARCHITECTURE TỐT SẺ TRÔNG NHƯ THẾ NÀO?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Architecture có thể được xem như cấp độ cao hơn code mà chúng ta đã viết. Nó là structure của ứng dụng, là cách mà các thành phần được tổ chức, sắp xếp và liên kết với nhau. 
Architecture thường bao gồm các lớp được triển khai theo trục dọc và ngang của hệ thống đồng thời phãi kết nối các thành đó lại với nhau để chúng work một cách gọn ghẽ.&lt;/p&gt;

&lt;p&gt;Software architecture phãi được design với mục đích chính là phục vụ developer, cải thiện hiệu năng làm việc của họ chứ không phãi thoả mãn các architect hay optimize hiệu suất làm việc cho phần cứng.&lt;/p&gt;

&lt;p&gt;Người thiết kế kiến trúc phần mềm phãi đặt mục tiêu thấu hiểu những vấn đề của dev, hiểu được gì họ cần để làm việc một cách vui vẻ hạnh phúc, hiểu được những khó khăn của họ trong quá trình phát triển cũng như duy trì hệ thống từ đó đưa ra những gì tốt nhất, tiện lợi nhất cho developer.&lt;/p&gt;

&lt;p&gt;Khi nói rằng software architecture không sinh ra mục đích optimize hiệu suất làm việc cho phần cứng không có nghĩa là chúng ta không optimize hiệu suất phần cứng, ở đây chúng ta sẻ chỉ optimize cho phần cứng khi chi phí cho vấn đề performance lớn hơn lợi ích của một kiến trúc sạch cho developer mà thôi. Nói tóm lại chúng ta nên tránh optimize quá sớm, nên đặt trọng tâm vào design một architecture phục vụ developer trước tiên.&lt;/p&gt;

&lt;p&gt;Đứng về phía developer chúng ta có thể thấy rằng một architecture tốt sẻ thoả mãn các tiêu chí sau đây:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Simple, Understandable and Emergent: Quá hiển nhiên, một kiến trúc đơn giản, rõ ràng và dễ thẩm thấu sẻ giúp người mới tiếp cận code base một cách nhanh hơn, giảm effort khi transfer cũng như trainning.&lt;/li&gt;
  &lt;li&gt;Flexible: Đây cũng là một đặc điểm quan trọng, một kiến trúc linh hoạt, dễ thay đổi để đáp ứng các yêu cầu business sẻ phần nào giúp developer vui vẻ hạnh phúc hơn mỗi lúc có sự thay đổi diễn ra về mặt business.&lt;/li&gt;
  &lt;li&gt;Testable: Một architecture giúp developer dễ test hơn sẻ mang lại rất nhiều giá trị về việc duy trì cũng như refactor sau này. Họ có thể tự tin refactor phần nào đó mà vẫn dám đảm bảo business vẫn chạy đúng hoặc hạn chế tối đa bug khi refactor.&lt;/li&gt;
  &lt;li&gt;Maintainable: Rõ ràng rồi, thời gian và chi phí của việc maintain luôn chiếm hơn gấp đôi so với việc xây dựng mới, do đó một architecture không đảm bảo được tính Maintainable thì quả thực là nổi ám ảnh cho developer khi duy trì nó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;v-clean-architecture&quot;&gt;V. CLEAN ARCHITECTURE:&lt;/h3&gt;
&lt;p&gt;Trãi qua một quá trình dài tiến hoá và phát triển với các mẫu Architecture khác nhau. Cụ Bob giới thiệu cho chúng ta một tập hợp các Principles, Design Parterns nhằm separate các components, các dependencies, các concerns, chia phần mềm thành nhiều lớp và tổ chức các lớp đó sao cho thoả mãn các yêu cầu chung của một kiến trúc có thể gọi là tốt, nó được cụ Bob giới thiệu đầy đủ trong cuốn Clean Architecture, một cuốn sách mình thực sự nghiền ngẫm. Trong đó mô tả một kiến trúc Clean là một kiến trúc đáp ứng những tiêu chí sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Độc lập với các Frameworks: Kiến trúc phần mềm là không phụ thuộc vào bất cứ Framework/Tool-kit nào, các Frameworks có sẳn sinh ra nhằm giúp chúng ta một phần nào đó trong việc tổ chức hệ thống chứ không nhất nhất là chúng ta cần gì cũng kéo Framework vào để rồi phãi nhồi nhét nhiều thứ quy tắc rối rắm mà mỗi Framework yêu cầu.&lt;/li&gt;
  &lt;li&gt;Dễ test: Các thành phần trong phần mềm của chúng ta phãi dễ test mà không phãi phụ thuộc vào interface(UI/console UI), database hay bất cứ thành phần nào.&lt;/li&gt;
  &lt;li&gt;Độc lập với UI hay bất cứ interface nào: Các interface hổ trợ người dùng có thể thay đổi một cách dễ dàng mà không ảnh hưởng đến phần còn lại của hệ thống. Chẳng hạn, một giao diện web có thể được thay đổi thành giao diện command mà không làm ảnh hưởng đến các business rule.&lt;/li&gt;
  &lt;li&gt;Độc lập với Database, bạn có thể thay đổi từ Oracle hoặc Sql Server thành Mongo, BigTable, CouchDB, Cassandra hoặc bất kỳ hệ quản trị cơ sở dữ liệu nào mà không làm ảnh hưởng đến Business Rule ban đầu.&lt;/li&gt;
  &lt;li&gt;Độc lập với các thành phần third-party: Phần mềm của chúng ta sẻ không phụ thuộc vào bất cứ libraries/frameworks hay bất cứ thành phần third-party nào, chúng ta phãi có một tư duy rằng các frameworks/libraries sinh ra để chúng ta chọn cho việc phục vụ nhu cầu nghiệp vụ của chúng ta chứ không phãi chúng ta phụ thuộc vào các thứ đó để implement các logic nghiệp vụ của mình.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để đạt được những điều trên, tác giả Uncle Bob đề ra các ý tưởng, quy tắc được mô tả trong hình dưới:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và để dễ dàng tiếp cận chúng ta sẻ cùng phân tích các thành phần của một ứng dụng đơn giản để làm rõ những mục tiêu nguyên tắc của Clean Architect. Giả sử chúng ta có một ứng dụng đơn giản với một mô hình data-flow đơn giản như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi đó chúng ta sẻ đặt các thành phần lên các vòng tròn cơ bản như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nhìn theo mức độ tổng quát chúng ta sẻ có hai tầng abstract như sau:&lt;/p&gt;

&lt;h4 id=&quot;tầng-interface&quot;&gt;Tầng Interface:&lt;/h4&gt;
&lt;p&gt;Hai vòng tròn ngoài cùng mình tạm đặt nó vào tầng Interface. Đây là tầng chứa các  cổng giao tiếp:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Giao tiếp từ client đến hệ thống(Controller vs Presenter), tuỳ thuộc vào yêu cầu của hệ thống mà chúng ta sẻ implement các cổng Interfaces cụ thể để phục vụ client, có thể là giao tiếp dựa trên Rest/gRPC/TCP…. từ đó chúng ta có thêm các quyết định separate tầng này ra thành các tầng nhỏ dựa vào các lớp endpoints, transports cụ thể.&lt;/li&gt;
  &lt;li&gt;Giao tiếp với các thành phần infrastructure như Database System, Log System, Message Queue System, Search Engine,…. . Đây là nơi chứa các implementations của các Infrastructure Interfaces(Repository Interfaces, Search Interfaces, Message Interfaces…) mà Domain Layer yêu cầu để thực hiện. Tuỳ vào yêu cầu cũng như loại infrastructure mà chúng ta implement và separate tầng này một cách phù hợp dựa vào các parterns và toolkit(DAO, Repository, Data mapper, ORM, Query builder…..).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domain-layer&quot;&gt;Domain Layer:&lt;/h4&gt;
&lt;p&gt;Domain Layer là layer chứa hai vòng tròn trong cùng, hai vòng tròn này về cơ bản sẻ gồm các Entities, các Use cases và các Infrastructure Interfaces.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Các Entities sẻ encapsulate các business rules. Một Entity có thể là một class/struct với các phương thức hoặc có thể là một tập hợp các cấu trúc dữ liệu và hàm, miễn là nó có thể được sử dụng bởi nhiều ứng dụng khác nhau trong toàn bộ hệ thống. Nếu chúng ta chỉ viết một ứng dụng đơn lẻ, thì các Entities chính là các business object của ứng dụng. Chúng encapsulate các quy tắc chung và cao cấp nhất. Các Entities ít có khả năng thay đổi do ảnh hưởng từ những thay đổi từ bên ngoài như UI, security hay kể cả việc thay đổi công nghệ, language, framework.&lt;/li&gt;
  &lt;li&gt;Các Use Case: Domain Layer sẻ chứa các business rules cụ thể của ứng dụng. Nó đóng gói và implement tất cả các use cases của hệ thống. Các use cases này sẽ điều chỉnh luồng dữ liệu đến và đi từ các Entities và chỉ đạo Entities thể đó sử dụng các business rules của doanh nghiệp để đạt được các mục tiêu của mỗi use case.&lt;/li&gt;
  &lt;li&gt;Chúng ta không cho phép những thay đổi trong các use cases ảnh hưởng đến các Entities, và cũng không muốn lớp use cases bị ảnh hưởng bởi những thay đổi của các yếu tố bên ngoài như cơ sở dữ liệu, giao diện người dùng hoặc bất kỳ framework nào, lớp này phãi cô lập với những thành phần đó.&lt;/li&gt;
  &lt;li&gt;Các Infrastructure Interfaces: Ở đây là các Repository Interfaces, Search Engine Interface,… mà các Use Cases cần để phục vụ việc vận hành business logic. 
Đây là layer vô cùng quan trọng, chứa nhiều logic do đó chúng ta phãi chú trọng tổ chức một cách hợp lí để không bị rối sau quá trình phình to. Tuỳ vào mục đích và tình huống cụ thể mà chúng ta có thể lựa chọn các partern cho phù hợp. 
Với tất cả hệ thống thì thành phần quan trọng nhất của nó luôn là Domain Layer, đây là nơi tập trung các Domain, các Use Cases, là nơi sẻ quyết định hệ thống này làm gì cho khách hàng, quyết định giá trị gì mà chúng ta tạo ra, quyết định sống còn của hệ thống. Mọi thứ bên ngoài như Databases, Frameworks, Protocols,…. đó có thể quy chung lại là các thành phần infrastructures giúp chúng ta implement và vận hành business logic mà thôi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Về cách tổ chức code chúng ta cũng sẻ dễ dàng tuỳ chỉnh dựa trên tư tưởng đó:&lt;/p&gt;

&lt;p&gt;Với Golang mình thường tổ chức theo mô hình sau:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── domain
│   ├── models
│   │   ├── ..
│   ├── repositories
│   │   ├── ..
│   ├── usecases
│   │   ├── ..
├── endpoints
├── interfaces
│   ├── httpsv
│   ├── grpcsv
│   ├── elasticsearch
│   ├── mysql
├── cmd
├── vendor
└── ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Với Typescript trên nền tảng Nodejs mình thưởng tổ chức như sau:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── src
│   ├── domains
│   │   ├── entities
│   │   ├── interfaces
│   │   ├── use_cases
│   │   ├── ...
│   ├── delivery
│   │   ├── http
│   │   ├── grpc
│   ├── infrastructure
│   │   ├── data_access_layer
│   │   │   ├── cassandra_implementation
│   │   │...
│   └── ...
├── node_modules
├── package.json
└── ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;quy-tắc-về-dependencythe-dependency-rule&quot;&gt;Quy tắc về Dependency(The Dependency Rule)&lt;/h4&gt;
&lt;p&gt;Chính sự phân cấp về độ quan trọng của các thành phần của hệ thống, chúng ta phãi có một quy tắc để tổ chức chúng quy tắc về Dependency(The Dependency Rule)&lt;/p&gt;

&lt;p&gt;Quy tắc này yêu cầu chúng ta phãi tổ chức code làm sao mà chúng chỉ có thể hướng vào bên trong, tức là những thứ ở bên trong không cần biết về những thứ ở bên ngoài, những thứ ở bên ngoài sinh ra nhằm phục vụ việc hiện thực business logic bên trong.&lt;/p&gt;

&lt;p&gt;Cụ thể, tên của một cái gì đó khai báo trong một vòng tròn bên ngoài không được tham chiếu đến hoặc sử dụng bởi mã nguồn trong một vòng tròn bên trong bao gồm, các hàm, các class, biến, hoặc bất kỳ thực thể phần mềm khác. Cũng giống như vậy, các định dạng dữ liệu(Class/Struct/….) được sử dụng trong vòng ngoài không nên được sử dụng bởi những thứ ở vòng tròn bên trong, đặc biệt nếu các định dạng đó được tạo ra bởi một framework trong vòng tròn bên ngoài. Chúng ta không muốn bất cứ điều gì trong một vòng tròn bên ngoài tác động vào vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;OK! Vậy phãi làm sao khi mà các thứ nằm trong vòng tròn bên trong không hề biết việc tồn tại các thứ ở bên ngoài lại có thể sử dụng được những thứ được implement bên ngoài. Ví dụ như các Use Cases nằm ở tầng Domain cần database implementation ở tầng bên ngoài cho việc hiện thực Use Case. Lúc này thay vì chúng ta sử dụng trực tiếp các Repository implementation thì chúng ta sẻ sử dụng Repository Interface/Abstraction ở tầng domain. Đây cũng là một ví dụ về nguyên tắc Dependency Inversion trong SOLID về việc phân tách các layers, các modules. Các high-level modules sẻ không phụ thuộc vào các low-level modules mà cả hai nên phụ thuộc vào các Abstractions nằm tại các hight-level modules.&lt;/p&gt;

&lt;h4 id=&quot;interface-adapters&quot;&gt;Interface Adapters&lt;/h4&gt;

&lt;p&gt;Một thành phần không kém phần quan trọng trong hệ thống  phần mềm của chúng ta đó là Interface Adapters. Đây là một bộ các adapters có nhiệm vụ chuyển dữ liệu từ đầng này sang  tầng khác. Ví dụ như adapter chuyển đổi dữ liệu từ các use cases và Entities/Domain Model thành dữ liệu cho Database(Database Model) và ngược lại(Data Mapper). Hoặc đối với các bạn quen thuộc với Gokit sẻ thấy đó là các Endponts, chuyển đổi các cấu trúc dữ liệu từ định dạng của request sang cấu trúc dữ liệu đầu vào cho các Use Case Logics hoặc domain model. Và các Presenters sẻ encode response với định dạng phù hợp cho client.&lt;/p&gt;

&lt;h4 id=&quot;framework-và-driver&quot;&gt;Framework và Driver&lt;/h4&gt;

&lt;p&gt;Đây là một số thành phần có thể nằm trong các vòng tròn ngoài cùng, nói chung bạn không viết nhiều code trong layer này ngoại trừ code để connect với các vòng tròn ở bên trong. Layer này là nơi tập trung của các chi tiết. Chúng ta sẻ giữ những thứ này ở bên ngoài, nơi chúng khó có thể gây ảnh hưởng đến các phần ở vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;Tuân theo các quy tắc đơn giản trên không phải là một việc quá khó khăn nhưng nó sẻ giúp chúng ta tiết kiệm được nhiều thời gian trong tương lai. Bằng việc tách hệ thống thành các layer, đồng thời tuân theo Dependency Rule, chúng ta sẽ xây dựng được một hệ thống dễ test, cùng với những lợi ích kèm theo như đã đề cập ở trên. Khi bất kỳ bộ phận bên ngoài của hệ thống trở nên lỗi thời, chẳng hạn như database, hoặc web framework, bạn hoàn toàn có thể thay thế chúng với một effort tối thiểu.&lt;/p&gt;

&lt;h3 id=&quot;chỉ-chừng-đó-là-đủ-ư&quot;&gt;Chỉ chừng đó là đủ ư?&lt;/h3&gt;
&lt;p&gt;Tất nhiên đó chỉ là những thứ cơ bản, chỉ là một mẫu đơn giản, nhiều lúc bạn cần nhiều hơn 4 vòng tròn đó hoặc mỗi vòng tròn chúng ta phãi chia nhỏ thành các vòng tròn khác nữa để đảm bảo sự rõ ràng và “CLEAN” tuỳ thuộc vào sự tiến hoá của code base, hơn nữa không có quy tắc nào nói rằng bạn luôn phải có chỉ 4 vòng tròn, có thể có chừng đó layer, có thể nhiều hơn và cũng có thể ít hơn, nhiều hơn khi kiến trúc monolith của bạn ngày càng phình to và trở nên phức tạp, ít hơn khi bạn đã chia chúng được thành các microservices một cách mượt mà, chỉ tập trung là logic và loại bỏ đi những thứ rườm rà không đáng quan trọng, và có thể chia thêm layer cho phù hợp với độ tiến hoá. Cũng có thể bạn tách ra thành miroservices nhưng vẫn giữ nguyên kiến trúc với đầy đủ ban bệ của mẫu monolith củ, tuỳ vào việc bạn muốn quản lí một củ hành bự hoặc một rỗ hành hoặc một rỗ các tép hành mà thôi. Nhưng một điều mà chúng ta phãi ghi nhớ nếu không muốn bị ăn hành đó là Dependency Rule luôn phãi được áp dụng, sự phụ thuộc luôn phãi được hướng vào những thứ quan trọng nhất. Khi chia các layer theo các vòng tròn chúng ta nhìn sâu vào tâm vòng tròn thì mức độ abstract phãi tăng lên, vòng tròn trong cùng chỉ chứa những gì chung nhất, khó có thể chia nhỏ được nữa như các interface chẳng hạn. Các vòng tròn ngoài cùng phãi là các chi tiết được implement cụ thể ở mức thấp nhất và không ngại phãi thay đổi.&lt;/p&gt;

&lt;p&gt;Clean Architecture hay các Architectures mục tiêu lớn nhất vẫn là hướng Engineer vào thứ quan trọng nhất của phần mềm là các Domain, Business Rules và là tập hợp các quy tắc, để giữ cho source code hệ thống phần mềm của chúng ta luôn được “Clean”.&lt;/p&gt;

&lt;h3 id=&quot;implement-clean-architecture&quot;&gt;Implement Clean Architecture:&lt;/h3&gt;
&lt;p&gt;Đây là hai ví dụ nhỏ mình implement Clean Architecture với Golang và Typescript các bạn có thể tham khảo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lephuocmy668/daily-problems-solving/tree/master/golang/workspace/tiktok-clean-microservice&quot;&gt;Golang Clean Microservice&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lephuocmy668/nodejs-typescript-clean-architecture&quot;&gt;Typescript Clean Microservice&lt;/a&gt;&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><category term="functional programming" /><category term="functional reactive programming" /><category term="declarative programming" /><category term="clean architecture" /><category term="concurrency" /><summary type="html">Trong bài viết này chúng ta sẻ cùng thảo luận về một loạt các patterns, principles, paradigms nhằm tạo ra một kiến trúc tốt hơn nhằm thay thế cho các approaches không thực sự còn hợp thời nữa, đặc biệt là các concepts trong Clean Architecture. Bài viết này mình sẻ thảo luận về một số mục chính sau:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">What and Why Golang?</title><link href="https://romeo.vn/introduce-to-golang/" rel="alternate" type="text/html" title="What and Why Golang?" /><published>2018-03-28T21:20:00-05:00</published><updated>2018-03-28T21:20:00-05:00</updated><id>https://romeo.vn/introduce-to-golang</id><content type="html" xml:base="https://romeo.vn/introduce-to-golang/">&lt;p&gt;Gần đây Golang nổi lên mạnh mẻ như một ngôi sao trong làng lập trình hệ thống với các lợi ích, chức năng cực kì powerful. Bài viết này mình sẻ lược qua một số điểm đáng chú ý sau của Golang, để các bạn có thể phần nào xem xét chọn Go cho dự án của mình nhé:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xét về khía cạnh technical:
    &lt;ul&gt;
      &lt;li&gt;Mức độ trưởng thành, hoàn thiện của Golang&lt;/li&gt;
      &lt;li&gt;Tốc độ của Golang&lt;/li&gt;
      &lt;li&gt;Concurrency Model và mức độ sử dụng memory resource của Golang&lt;/li&gt;
      &lt;li&gt;Error Handling trong Golang&lt;/li&gt;
      &lt;li&gt;Các Paradigms và Design Parterns mà Go hổ trợ&lt;/li&gt;
      &lt;li&gt;Code transparency&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Xét về khía cạnh business:
    &lt;ul&gt;
      &lt;li&gt;Mức độ hạnh phúc của developers&lt;/li&gt;
      &lt;li&gt;Tốc độ phát triển&lt;/li&gt;
      &lt;li&gt;Khía cạnh Human Resource&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Conclusion:&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;a-xét-về-khía-cạnh-technical&quot;&gt;A. Xét về khía cạnh technical:&lt;/h3&gt;
&lt;h4 id=&quot;1-mức-độ-trưởng-thành-ổn-định-của-golang&quot;&gt;1. Mức độ trưởng thành, ổn định của Golang:&lt;/h4&gt;
&lt;p&gt;Để make một decision chọn một ngôn ngữ, công nghệ cho việc build một hệ thống, một service có thể chạy ổn định từ năm này qua tháng nọ thì mức độ trưởng thành, hoàn thiện của công nghệ đó là một khía cạnh đáng xem xét.&lt;/p&gt;

&lt;p&gt;Go tuy là một ngôn ngữ còn khá trẻ, được phát triển bởi Google bắt đầu từ năm 2007 và ra phiên bản đầu tiên vào tháng 12 năm 2012. Tuy nhiên lại có độ trưởng thành và ổn định cao. Sinh sau đẻ muộn nhưng sự phát triển mạnh mẻ của cộng đồng Gopher hiện tại thực sự đáng gờm đối với các hệ sinh thái Java, C#. Go cung cấp một bộ thư viện chuẩn phong phú cùng với một hệ sinh thái open source giàu có nhờ cộng đồng lớn.&lt;/p&gt;

&lt;p&gt;Tuy không thể so sánh được với Java, C# về độ stable nhưng với các ngôn ngữ non trẻ như Node.js chẳng hạn thì Go thực sự già dơ hơn nhiều. Go ít sự thay đổi hơn và dù có thay đổi cũng ít khi gây ảnh hưởng lớn đến version củ.&lt;/p&gt;

&lt;p&gt;Do đó xét về mức độ trưởng thành, ổn định Go hoàn toàn xứng đáng được chọn là công nghệ chỉ xếp sau Java, C#.&lt;/p&gt;

&lt;h4 id=&quot;2-tốc-độ-của-golang&quot;&gt;2. Tốc độ của Golang:&lt;/h4&gt;
&lt;p&gt;Về điểm này thì theo cái nhân mình Go xứng đáng được đánh giá là chỉ xếp sau C, Elixir và Rust trong các ngôn ngữ phổ biến cho Back End.&lt;/p&gt;

&lt;p&gt;Go code được complile trực tiếp sang mã máy do đó có một tốc độ bàn thờ. Trong lúc các ngôn ngữ như Java, Node.js có các yếu tố trung gian làm ảnh hưởng phần nào đến tốc độ.&lt;/p&gt;

&lt;p&gt;Node.Js là runtime sử dụng bộ V8 của Google biên dịch code Javascript sang mã máy. Có thể nói Node.Js là một nữa thông dịch một nữa biên dịch dựa vào V8. Mặc dù Node.js optimize quá trình biên dịch bằng cách dùng cache để biên dịch nhanh hơn. Nhưng nhìn chung Node.js vẫn chủ yếu thông dịch nên có tốc độ thấp hơn đáng kể so với các ngôn ngữ biên dịch như Java hay Go.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó thì code Java được biên dịch sang các binary file. Các binary file đó lại được sử dụng trên Java Virtual Machine(JVM) cho việc thực thi. Java bytecode được thông dịch bằng JVM cuối cùng JVM mới chuyển Java bytecode sang mã máy sử dụng một Just-In-Time (JIT) compiler sau đó mới thực thi. Việc có một chút yếu tốc thông dịch cũng như yếu tố trung gian như JIT Compiler khiến cho Java có phần chậm hơn Go.&lt;/p&gt;

&lt;h4 id=&quot;3-concurrency-model-và-mức-độ-sử-dụng-memory-resource-của-golang&quot;&gt;3. Concurrency Model và mức độ sử dụng memory resource của Golang&lt;/h4&gt;
&lt;p&gt;Ngoài một tốc độ bàn thờ ra thì lợi thế mạnh nhất của Golang đó chính là chức năng hổ trợ concurrency dựng sẳn trong ngôn ngữ cùng với khả năng tận dụng bộ xử lí đa lõi.&lt;/p&gt;

&lt;p&gt;Ngày nay phần cứng máy tính đã phát triển để có nhiều lõi CPU và nhiều sức mạnh hơn, nhưng sức mạnh của máy tính hiện đại không thể được tận dụng bằng cách sử dụng các ngôn ngữ lập trình chỉ support đơn core.&lt;/p&gt;

&lt;p&gt;Trong một số môi trường lập trình, concurrency và parallelism cho hiệu quả và hiệu năng tốt, nhưng các tính năng này là một thư viện hay framework riêng biệt, chứ không phải là một tính năng tích hợp sẳn ở cấp độ ngôn ngữ. Do đó để lập trình concurrency hay parallelism đôi lúc lại làm tăng thêm sự phức tạp khi bạn viết các ứng dụng concurrent.&lt;/p&gt;

&lt;p&gt;Trong Go, concurrency được xây dựng sẳn và được thiết kế để viết các ứng dụng concurrent hiệu suất cao cho các máy tính hiện đại, có thể tận dụng multi proccessor.&lt;/p&gt;

&lt;p&gt;Với hiểu biết cá nhân mình thì hiện tại các ứng dụng web sử dụng 3 Concurrency model chủ yếu đó là Assembly Line model, Parallel Worker model(đây gọi là parallel thì đúng hơn nhưng cứ tạm gọi là Concurrency model cho thuận miệng) và Communicating Sequential Processes model(CSP).&lt;/p&gt;

&lt;p&gt;Trong quá trình học tập với Java mình chủ yếu được giới thiệu về mô hình Parallel Worker. Với mô hình này chúng ta sẻ config trước một thread pool với số lượng thread có hạn, đồng thời stack size của mỗi thread cũng được config cứng(default là 1Mb) mỗi một request tới sẻ được assign cho một worker(OS thread). Với model này trong Java chúng ta sẻ có một số vấn đề:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Vấn đề đầu tiên chúng ta có thể thấy đó là giới hạn số thread. Rõ ràng giả xử với 1Mb config cho mỗi thread thì maximum 1 Gb Ram chúng ta cũng chỉ xử lí được 1024 requests(chưa kể trừ hao cho context switching cost, heap,…).&lt;/li&gt;
  &lt;li&gt;Một vấn đề nữa đó là Garbage-Collection Pause Time. Khi trình dọn rác thực thi việc dọn dẹp bộ nhớ heap có thể sẻ block tất cả thread do đó có độ trể nhất định ở đây.&lt;/li&gt;
  &lt;li&gt;Vấn đề thứ ba đến từ cơ chế parallel. Java có được tính concurrency dựa vào việc share memory giữa các threads. Việc share memory này dẫn đến các vấn đề muôn thuở đó là deadlock, race condition…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mình đang làm việc chủ yếu với Node.js với concurrency model là Assembly Line(cũng được gọi là Reactive model hoặc Event Driven model). Node.js đạt được tính concurrecy nhờ vào cái Event Loop. Với mô hình này thì Node.js thực sự mạnh mẻ trong việc sử lí I/O với cơ chế Non-Blocking I/O. Nhìn chung Node.js ít gặo các vấn đề mà Java gặp phãi tuy nhiên lại gặp vấn đề lớn hơn đó là các request sẻ bị block lẫn nhau khi sử dụng các CPU-intensive programming tasks(tác vụ tính toán chuyên sâu). Nếu một service tính toán nhiều mà sử dụng Node.js thì thực sự độ trể sẻ rất cao khi có nhiều request đồng thời đến.&lt;/p&gt;

&lt;p&gt;Sử dụng Event Loop cho quá trình xử lí concurrent request về lí thuyết sẻ giúp Node.js sử dụng ít memory hơn tuy nhiên trong thực tế trình dọn rác của Node.js tương đối kém dẫn đến ngốn ram, cpu sau một thời gian chạy mà không rõ nguyên do dù đã detect rất kĩ các nguyên nhân dẫn đến memory leak.&lt;/p&gt;

&lt;p&gt;Golang thì sao?, concurrency model trong Golang có những điểm gì mạnh mẻ?&lt;/p&gt;

&lt;p&gt;Go đạt được tính concurrency bằng việc sử dụng Communicating Sequential Processes(CSP) model dựa trên các tính năng được build sẳn trong Go như Go Runtine, Channel, các câu lệnh select,…&lt;/p&gt;

&lt;p&gt;Mô hình này được implement dựa trên việc gửi và nhận message giứa các tiến trình(Go Runtines), các synchronous communication được thực hiện thông qua các channel, các channel cùng với việc sử dụng các câu lệnh select cũng giúp chúng ta chủ động hơn trong việc scheduling. Tuy rằng trong Go cũng có các vấn đề về Deadlock, Race Condition tuy nhiên Go Tool cũng support các công cụ thực sự mạnh mẻ cho việc detect các vấn đề này sớm.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó Go cũng rất tiết kiệm memory khi sử dụng các Go Rountine rất rẻ với 4kb Stack Size chi phí khởi tạo ban đầu và các Go Rountine cũng scale rất dynamic, chúng có thể scale lên đến 1Gb.&lt;/p&gt;

&lt;p&gt;Nhìn chung về yếu tố concurrency và mức độ sử dụng memory go đang khá lợi thế với các ngôn ngữ khác. Build-in Concurrency là lý do chính cho việc sử dụng Go như một ngôn ngữ để xây dựng các hệ thống phần mềm hiệu quả cao với hiệu năng cao hơn.&lt;/p&gt;

&lt;p&gt;Mình chưa biết Rust nên không dám phán nhiều :)))&lt;/p&gt;

&lt;h4 id=&quot;5-error-handling-trong-golang&quot;&gt;5. Error Handling trong Golang&lt;/h4&gt;
&lt;p&gt;Golang yêu cầu kiểm tra lỗi một cách rõ ràng, mỗi một hàm nên trả lỗi và check lỗi ngay khi gọi hàm. Việc check lỗi khắp mọi nơi, nhìn chung khá vất vã. Tuy nhiên, với cá nhân mình thấy việc xử lý lỗi trên Golang là rất nhất quán và hoàn hảo, không như cách implement throw/catch truyền thống trên Node.js và Java, ngày trước mình rất bực với những exception như “null pointer exception”.&lt;/p&gt;

&lt;h4 id=&quot;6-các-paradigms-và-design-parterns-mà-go-hổ-trợ&quot;&gt;6. Các Paradigms và Design Parterns mà Go hổ trợ&lt;/h4&gt;
&lt;p&gt;Golang có thể được gọi là multi paradigm programming language.&lt;/p&gt;

&lt;p&gt;Với các tín đồ Functional Programming, Go hổ trợ first-class functions, anonymous functions, closures gíup dễ implement các technique trong functional. Hơn nữa Gopher ưu tiên composition over inheritance phù hợp với các tín đồ functional.&lt;/p&gt;

&lt;p&gt;Với tín đồ OOP, Go hổ trợ struct được sử dụng với một số chức năng giống với class, kế thừa dựa vào việc sử dụng các embedded struct. Bên cạnh đó Interface cũng là công cụ mạnh mẻ để implement tính Polymorphism trong OOP cũng như implement theo nguyên tắc Dependency Inversion.&lt;/p&gt;

&lt;h4 id=&quot;7-code-transparency&quot;&gt;7. Code Transparency&lt;/h4&gt;
&lt;p&gt;Về cú pháp Go support một code format tool chuẩn và code generate tool chuẩn đó là fmt tool. Bộ tool này phần nào giúp thống nhất code convention của tất cả Gopher thay vì dựa vào các convention các ông lớn đưa ra như AirBnB convention trong Javascript chẳng hạn. Thứ hai là một chương trình Go sẻ không compile được nếu import một package mà không sử dụng phần nào giúp code đở rối.&lt;/p&gt;

&lt;p&gt;Về các quy ước tổ chức modules, packages thì Go nói không với circular dependencies. Mình thực sự bực mình với các thể loại circular dependencies, mỗi khi có bug hoặc vấn đề gì đó detect rất cực. Với một chương trình viết bằng Go thì chúng ta sẻ không thể compile nếu tồn tại circular dependencies.&lt;/p&gt;

&lt;h3 id=&quot;b-xét-về-khía-cạnh-business&quot;&gt;B. Xét về khía cạnh business:&lt;/h3&gt;
&lt;h4 id=&quot;1-mức-độ-hạnh-phúc-của-developer&quot;&gt;1. Mức độ hạnh phúc của developer&lt;/h4&gt;
&lt;p&gt;Tại sao mình lại đặt mức độ hạnh phúc của Developer trong khía cạnh business. Rõ ràng nếu các Engineer thực sự vui vẻ hạnh phúc thì chất lượng cũng như tốc độ phát triển sẻ cải thiện hơn so với việc sử dụng một ngôn ngữ gây khó chịu ức chế cho Developer rồi.&lt;/p&gt;

&lt;p&gt;Golang là một ngôn ngữ tối giản, có độ biểu cảm(expressive) cao cùng với sự support tương thích với các paradigms phần nào giúp developer vui vẻ hạnh phúc hơn khi làm việc với Go. Khi tìm hiểu bạn có thể thấy được sự đơn giản trong tất cả các tính năng của Go bao gồm cả hệ thống kiểu dữ liệu, cú pháp,… . Nhiều ngôn ngữ lập trình cung cấp quá nhiều tính năng giúp Dev dễ dàng làm việc hơn nhưng vô hình chung làm cho nó trở nên phức tạp hơn, ức chế hơn. Mục tiêu thiết kế của Go là một ngôn ngữ đơn giản và chỉ cung cấp tất cả các tính năng cần thiết tối thiểu để phát triển các hệ thống phần mềm một hiệu quả, đó cũng giúp dev vui vẻ hạnh phúc hơn.&lt;/p&gt;

&lt;p&gt;Đối với các Javascript developer thì họ cực kì thích Go ở việc Go là ngôn ngữ được xây dựng khá giống như C - ngôn ngữ mà Javascript xây dựng dựa trên đó. Họ thực sự yêu thích Golang nhờ nó cực kì strictly typing. Là ngôn ngữ static type nên khi lập trình với Go gần như là không có runtime error(trừ khi bạn quá lạm dụng reflect).&lt;/p&gt;

&lt;p&gt;Đối với các Java/C++ developers cũng vậy, với các Java/C++ developers họ cực kì mệt mỏi vì thời gian build quá lâu. Đối với Go, là một ngôn ngữ biên dịch và static type tuy nhiên khi làm việc với Go chúng ta có cảm giác như đang làm việc với một ngôn ngữ Dynamic Type hơn. Điều đó khiến các lập trình viên Back End với Java khi chuyển quá làm Go thực sự sướng.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó Go cũng có một số thiếu xót làm các Engineer ức chế, ví dụ như không support Generic, không support các constructs như Map, Reduce,… Là một ngôn ngữ biên dịch, static type mà lại không support Generic như Java làm các Developer khó viết code reusable hơn, việc duplicate code làm họ thực sự khó chịu. Tuy nhiên cũng có một số kĩ thuật giúp chúng ta viết code generic hơn như sử dụng các Closure, Callback, Higher-Order Function và Reflect cũng phần nào nguôi ngoai được thiếu xót từ Generic và các constructs.&lt;/p&gt;

&lt;h4 id=&quot;2-tốc-độ-phát-triển-product&quot;&gt;2. Tốc độ phát triển product&lt;/h4&gt;
&lt;p&gt;Đây là một mục tiêu rất quan trọng việc phát triển các product. Thời gian ra thị trường nhanh giúp các product tự tin thực hiện các chiến lược business hơn. Đối với các ngôn ngữ mạnh trong khoản mì ăn liền như Javascript, Ruby thì Go không có cửa so sánh. Tuy nhiên đối với các ngôn ngữ như Java, C#, C++ thì có thể Go có lợi thế hơn.&lt;/p&gt;

&lt;p&gt;Với việc là một ngôn ngữ biên dịch, static type nhưng cảm giác như là ngôn ngữ thông dịch, dynamic type khiến cho tốc độ phát triển sản phẩm nhanh hơn đôi chút so với Java. Cùng với đó là hệ sinh thái open source ngày càng màu mở cũng nâng cao tốc độ phát triển sản phẩm hơn trước.&lt;/p&gt;

&lt;p&gt;Lợi thế trong việc mang lại sự vui vẻ hạnh phúc cho developer cũng giúp rút ngắn thời gian ra thị trường hơn đối với các ứng dụng được xây dựng với Golang.&lt;/p&gt;

&lt;h4 id=&quot;3-human-resource&quot;&gt;3. Human Resource&lt;/h4&gt;
&lt;p&gt;Golang được biết đến là ngôn ngữ đa năng, Go có thể build mobile app, system infrastructure, web app, back end,…Tuy nhiên Go vẫn chỉ sử dụng nhiều nhất cho việc xây dựng Back End cho các hệ thống. Với Go chúng ta không thể apply fullstack culture như đối với Javascript.&lt;/p&gt;

&lt;p&gt;Tuy nhiên tính đơn giản, thực dụng của Go cũng mang lại nhiều lợi ích đáng kể trong vấn đề Human Resource. Go quá tối giản do đó việc học Go là rất nhanh, với mình một người khá chậm tuy nhiên mình tự tin sau tầm 2 tuần là tự tin làm việc được trong dự án. Do đó với Go các công ty dễ dàng đào tạo một bạn sinh viên trở thành một junior developer chất lượng sau 1-3 tháng. Cũng nhờ tính đơn giản, biểu cảm và dễ hiểu, việc transfer một service, ứng dụng với Golang cũng diễn ra rất nhanh giúp người quản lí dễ dàng hơn, linh hoạt hơn trong các giải pháp chuyển giao, backup…&lt;/p&gt;

&lt;p&gt;Tuy nhiên với một ngôn ngữ trẻ như Go với số lượng it Developer có kinh nghiệm cũng gây khó khăn cho nhà tuyển dụng.&lt;/p&gt;

&lt;h3 id=&quot;c-conclusion&quot;&gt;C. Conclusion:&lt;/h3&gt;
&lt;p&gt;Nhìn chung Go khá là imperative cá nhân mình không thích style này. Tuy nhiên với cái nhìn của một Back End developer, mình thấy ở Go là một ngôn ngữ expressive, tối giản và hiệu quả cùng với tính năng concurrent built-in và khả năng tận dụng multi-core thì Go thực sự đáng được lựa chọn cho việc xây dựng các ứng dụng back end với hiệu xuất và concurrency cao. Go support tốt các paradim, flexible và dễ module hoá, dễ layered sẻ thực sự hữu ích cho việc dựng architecture. Cùng với đó, Go là một ngôn ngữ biên dịch, static type nhưng lại flexible như một ngôn ngữ thông dịch, dynamic type sẻ giúp nâng cao hiệu suất làm việc hơn. Còn đối với các bạn thì sao, nếu có cách nhìn nào khác thì giúp mình góp ý nhé.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="nodejs" /><category term="eventloop" /><category term="singlethreaded" /><summary type="html">Gần đây Golang nổi lên mạnh mẻ như một ngôi sao trong làng lập trình hệ thống với các lợi ích, chức năng cực kì powerful. Bài viết này mình sẻ lược qua một số điểm đáng chú ý sau của Golang, để các bạn có thể phần nào xem xét chọn Go cho dự án của mình nhé:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Solid Principle</title><link href="https://romeo.vn/solid-principle/" rel="alternate" type="text/html" title="Solid Principle" /><published>2018-01-12T01:01:00-06:00</published><updated>2018-01-12T01:01:00-06:00</updated><id>https://romeo.vn/solid-principle</id><content type="html" xml:base="https://romeo.vn/solid-principle/">&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng clean code cũng giống như việc xây nhà, khi bắt đầu chúng ta cần những viên gạch tốt, nếu bắt đầu bởi những viên gạch không tốt thì cho dù kiến ​​trúc của tòa nhà ngon lành đến mấy cũng không còn quan trọng nữa vì nó đã dễ dàng sụp đổ. Một mặt khác, khi bạn đã có các viên gạch tốt, nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn. Ánh xạ sang Software Developmemnt, có một tập các nguyên tắc giúp chúng ta kết nối những viên gạch lại thành những bức tường, những component tốt. Một trong số đó là SOLID principle.&lt;/p&gt;

&lt;p&gt;SOLID Principle cho chúng ta biết cách sắp xếp các hàm, cấu trúc dữ liệu vào các struct/class sao cho các struct/class đó dễ dàng tiếp nhận sự thay đổi, dễ hiểu cho người mới đồng thời dễ tái sử dụng khi cần.&lt;/p&gt;

&lt;p&gt;Về cơ bản SOLID được Robert Martin giới thiệu với năm nguyên tắc thiết kế hướng đối tượng (OOD) sau:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Single responsibility principle (S)&lt;/li&gt;
  &lt;li&gt;Open/closed principle (O)&lt;/li&gt;
  &lt;li&gt;Liskov substitution principle (L)&lt;/li&gt;
  &lt;li&gt;Interface segregation principle (I)&lt;/li&gt;
  &lt;li&gt;Dependency inversion principle (D)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bây giờ chúng ta sẻ tiếp tục phân tích rõ từng nguyên tắc xem chúng hữu ích như thế nào&lt;/p&gt;

&lt;h3 id=&quot;1-the-single-responsibility-principlesrp&quot;&gt;1. The Single Responsibility Principle(SRP):&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;A class or function should only have one reason to change.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Đây là nguyên tắc chúng ta thường hay vi phạm nhất. Có thể hiểu rằng chúng ta phãi viết code sao cho một struct/class chỉ nên đảm nhiệm một trách nhiệm duy nhất, một hệ thống phần mềm có cấu trúc tốt là hệ thống có các module/component mà chúng chỉ có một và chỉ một lý do để thay đổi.&lt;/p&gt;

&lt;p&gt;Để hiểu rõ nguyên tắc này chúng ta sẻ xét một ví dụ mà ta đã vi phạm nguyên tắc này:&lt;/p&gt;

&lt;p&gt;Giả sử hệ thống quản lí tiền lương nhân viên của chúng ta có chứa 4 thực thể sau: Employee, CTO, CFO, COO. Class Employee của chúng ta sẻ có chứa ba phương thức sau:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Employee struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;Employee&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; caculatePay&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;hr, accounting and it
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;Employee&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; reportHours&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;hr, accounting and it
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;Employee&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; save&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;hr, accounting and it
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cách thiết kế class Employee của chúng ta đã vi phạm SRP bởi vì nó có ba phương thức mà đáng ra phãi phãi chia cho 3 thực thể rất khác nhau đó là:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức caculatePay() được gọi bởi phòng kế toán và báo cáo cho CFO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức reportHours() được gọi bởi phòng HR và báo cáo cho COO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức save() được gọi bởi phòng admin và báo cáo cho CTO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bằng việc đưa ba phương thức trên vào một class Employee đơn lẻ, chúng ta đã vô tình couple sự phụ thuộc của các thực thể khác lại với nhau, ở đây có thể là CFO, COO, CTO đã vô tình phụ thuộc vào nhau. Lấy ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử rằng hàm caculatePay() và hàm reportHours() cần có giờ làm việc của từng nhân viên và chúng dùng chung một thuật toán để tính giờ làm việc, rõ ràng là khi đó chúng ta sẻ không muốn việc duplicate code xãy ra ở đây, chúng ta sẻ viết một hàm regularHours() cho việc sử dụng của hai hàm caculatePay() và reportHours().&lt;/p&gt;

&lt;p&gt;Đến một ngày đẹp trời, nhóm CFO quyết định rằng việc tính toán giờ làm việc regularHours() cần được tinh chỉnh lại trong lúc nhóm COO vẫn thấy hàm regularHours() như thế là ổn rồi không muốn bất cứ thay đổi gì đối với nó nữa.&lt;/p&gt;

&lt;p&gt;Một developer được CFO giao nhiệm vụ tinh chỉnh lại hàm regularHours() theo một mục đích mới nào đó, anh ta làm việc nhưng đâu biết rằng hàm reportHours() đang phụ thuộc nó. Việc tinh chỉnh được thực hiện xong, hàm caculatePay() chạy trơn tru đúng yêu cầu và được áp dụng ngay. Sau một thời gian người ta nhận thấy hàm reportHours() đã đi sai hướng, các số liệu báo cáo lên sai lệch ảnh hưởng đến tài chính công ty.&lt;/p&gt;

&lt;p&gt;Đó là một ví dụ vi phạm, khi gặp các trường hợp đó chúng ta nên phân tách các phương thức ra các class riêng lẻ và ngược lại, cách dễ nhất để phá các ứng dụng là tạo ra các GOD classes(một GOD class là một class biết quá nhiều hoặc làm quá nhiều, GOD class là một ví dụ về một ví dụ về anti pattern), một God class giữ reference đến nhiều thực thể khác cũng như giữ nhiều trách nhiệm đâm ra dễ gây ra các vấn đề tương tự như ví dụ trên.&lt;/p&gt;

&lt;p&gt;Chúng ta sẻ refactor lại class trên như sau:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Hr struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;h &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;Hr&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; reportHours&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;hr
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Accountant struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;Accountant&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; caculatePay&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;accounting
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;ITAdmin struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ita &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;ITAdmin&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; save&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    // implement algorithm &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;it
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-openclosed-principle-ocp&quot;&gt;2. Open/Closed Principle (OCP):&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;A software artifact should be open for extension but closed for modification.”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Nguyên tắc này có nghĩa là chúng ta phãi viết code sao cho mỗi khi ta muốn thêm chức năng cho chương trình, chúng ta có thể viết code mới chứ hạn chế tối đa việc sửa code củ.&lt;/p&gt;

&lt;p&gt;Quá rõ ràng phãi không nào, đây là lý do cơ bản nhất mà chúng ta nghiên cứu Software Architecture. Rõ ràng là nếu muốn mở rộng, thay đổi một chức năng một cách đơn giản mà phãi thay đổi lớn đối với phần mềm thì các Architect của hệ thống phần mềm đó đã thất bại rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mục đích là thế, nhưng phãi làm thì như nào để hiểu và đạt được mục đích nguyên tắc đó, chúng ta cùng xét một ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử hệ thống của bạn đang có một chức năng báo cáo tóm tắt tài chính, dữ liệu được hiển thị trên giao diện web, rõ ràng trên giao diện web thì cần gì phân trang, roll lên roll xuống là được rồi. Một ngày đẹp trời khách hàng muốn bạn thêm chức năng hiển thị báo cáo đó trên trên PDF với tiêu đề và phân trang hợp lí, các số liệu cần được làm nổi bật và gửi cho người dùng.&lt;/p&gt;

&lt;p&gt;Rõ ràng, một lượng code sẻ phãi được viết lại để đáp ứng yêu cầu trên nhưng bao nhiêu code củ sẻ phãi thay đổi? Kiến trúc tốt sẻ giảm thiểu lượng code phãi thay đổi xuống mức tối thiểu nhất có thể và lí tưởng nhất là không có dòng code nào phãi thay đổi.&lt;/p&gt;

&lt;p&gt;Làm thế nào để đạt được điểu đó? Đầu tiên phãi tách biệt những thực thể mà chúng có thể phãi thay đổi vì các lí do khác nhau(áp dụng SRP) sau đó bố trí sự phụ thuộc của chúng đúng cách(sử dụng DIP nói sau). Bằng cách đó chúng ta sẻ đưa luồng dữ liệu hướng như dưới, mô tả một số quy trình kiểm tra xử lí dữ liệu có thể trình bày, sau đó trình bày theo định dạng phù hợp để thể hiện trên web và trên PDF.&lt;/p&gt;

&lt;p&gt;Thông tin chi tiết cần thiết ở đây là việc tạo báo cáo liên quan đến hai trách nhiệm riêng biệt: tính toán thông tin số liệu tài chính và việc trình bày data đó thành các model thân thiện với web và pdf.&lt;/p&gt;

&lt;p&gt;Sau khi thực hiện sự tách biệt này, chúng ta cần phải tổ chức các phụ thuộc code để đảm bảo rằng những thay đổi đối với một trong những trách nhiệm đó không gây ra những thay đổi ở bên kia. Ngoài ra, cách tổ chức mới phải đảm bảo rằng hành vi có thể được mở rộng mà không huỷ bỏ các sửa đổi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta thực hiện điều này bằng cách phân vùng các quy trình thành các class và tách các class đó thành các component, như được thể hiện bằng các dòng kép trong sơ đồ trong hình dưới.&lt;/p&gt;

&lt;p&gt;Trong hình này, thành phần ở phía trên bên trái là Controller, phía trên bên phải là Interactor, phía dưới bên phải là database, ở phía dưới bên trái có bốn thành phần đại diện cho đối tượng hiển thị và data hiển thị.&lt;/p&gt;

&lt;p&gt;Các  được đánh dấu bằng kí hiệu chứ &amp;lt;I là các interface; những người được đánh dấu bằng &amp;lt;DS là các data struct.&lt;/p&gt;

&lt;p&gt;Các mũi tên đang sử dụng để thể hiện các mối quan hệ. Đầu mũi tên trỏ tới thể hiện mối quan hệ thừa kế. Điều đầu tiên cần lưu ý là tất cả các phụ thuộc là các phụ thuộc code. Một mũi tên chỉ từ class A đến class B có nghĩa là code của lớp A reference đế class B, nhưng class B không cần biết gì đến class A.&lt;/p&gt;

&lt;p&gt;Như vậy, trong hình trên, FinancialDataMapper reference đến FinancialDataGateway thông qua một mối quan hệ implement interface, nhưng FinancialGateway không biết gì về FinancialDataMapper.
&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều tiếp theo cần lưu ý là tất cả mỗi quan hệ đều là một chiều và mỗi đối tượng chỉ chịu sự phụ thuộc đến duy nhất một thực thể khác như thể hiện trong hình dưới, những mũi tên hướng tới các thành phần mà chúng ta muốn bảo vệ khỏi thay đổi.&lt;/p&gt;

&lt;p&gt;Nghĩa là sao? là nếu thành phần A cần được bảo vệ khỏi những thay đổi trong thành phần B, thì thành phần B sẽ phụ thuộc vào thành phần A. Chúng ta muốn bảo vệ Controller khỏi những thay đổi trong Presenters. Chúng ta muốn bảo vệ các Presenters khỏi những thay đổi trong Views. Chúng tôi muốn bảo vệ Interactor khỏi những thay đổi trong bất cứ điều gì. Interactor ở vị trí phù hợp nhất với OCP.&lt;/p&gt;

&lt;p&gt;Các thay đổi đối với Database/Controller/Presenters/Views sẽ không ảnh hưởng đến Interactor.&lt;/p&gt;

&lt;p&gt;Tại sao Interactor nên giữ một vị thế đặc quyền như vậy? Bởi vì nó chứa các business rule. Interactor chứa các policy cao nhất của ứng dụng. Tất cả các thành phần khác đang xử lý các yếu tố ngoại vi còn interactor thực hiện các logic quan trọng nhất của ứng dụng. Mặc dù Controller là thành phần phụ so với với Interactor, nhưng nó vẫn là thành phần quan trọng hơn các Presenters và Views. Và trong Presenters có thể là phần phụ so với Controller nhưng chúng lại quan trọng hơn phần Views.&lt;/p&gt;

&lt;p&gt;Lưu ý cách thức này tạo ra một hệ thống phân cấp dựa trên khái niệm “level”. Các Interactor ưu tiên cao nhất vì vậy chúng cần được được bảo vệ nhất. View nằm trong số ưu tiên thấp nhất, vì vậy chúng được bảo vệ ít nhất.&lt;/p&gt;

&lt;p&gt;Đây là cách OCP hoạt động ở cấp kiến ​​trúc. Các kiến trúc chia chức năng riêng biệt dựa trên cách thức – tại sao và khi nào chúng thay đổi, sau đó tổ chức chức năng được phân tách thành một hệ thống phân cấp các thành phần. Các thành phần cấp cao hơn trong phân cấp đó được bảo vệ khỏi những thay đổi được thực hiện cho các thành phần cấp thấp hơn.&lt;/p&gt;

&lt;p&gt;Nói tóm lại OCP là một trong nhưng sức mạnh đứng đằng sau kiến trúc hệ thống tốt, giúp hệ thống dễ dàng mở rộng mà không phãi chịu sức ép từ những thay đổi, mục tiêu này đạt được khi chúng ta chia phân vùng hệ thống thành các component và sắp xếp chúng thành một hệ thống phân cấp sự phụ thuộc để bảo vệ các thành phần cấp cao khỏi sự thay đổi của các thành phần cấp thấp.&lt;/p&gt;

&lt;h3 id=&quot;3-liskov-substitution-principlelsp&quot;&gt;3. Liskov Substitution Principle(LSP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này được phát biểu như sau:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Trong một chương trình, các object của class con có thể thay thế class cha mà không làm thay đổi tính đúng đắn của chương trình
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thật khó hiểu đúng không nào? Có thể nghĩ như này: Khi các class A kế thừa từ class B thì phãi có hai điều kiện sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Class B có các behaviors nào thì A phãi có các behaviors đó.&lt;/li&gt;
  &lt;li&gt;Các phương thức của class B thì phãi đảm bảo có thể sử được trong các class con của nó(ở đây là class A) hay nói cách khác các phương thức của các class cha phãi luôn hoạt động chính xác trên tất cả các class kế thừa từ nó.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để hiểu hơn ta xét ví dụ như sau: Giả xử ta có class Chim có phương thức là Bay()&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Class Đại Bàng thừa kế class Chim cũng có đủ phương thức Bay() và hoạt động đúng như class chim() do đó trường hợp này thoả mãn LSP.&lt;/li&gt;
  &lt;li&gt;Class Chim Cánh cụt thừa kế class Chim nhưng phương thức Bay không khả dụng cho nên là vi phạm LSP.&lt;/li&gt;
  &lt;li&gt;Class Chim Điện thừa kế class Chim cũng có phương thức bay, nhưng phương thức Bay này có thêm yêu cầu là phãi có điện thì mới bay được cho nên vi phạm LSP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-interface-segregation-principleisp&quot;&gt;4. Interface Segregation Principle(ISP):&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nguyên tắc này có thể nói ngắn gọn là thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ, với nhiều mục đích cụ thể, để dễ hiểu hơn chúng ta cùng xét ví dụ như hình trên, mỗi user sử dụng các phương thức của class OPS, giả sử rằng User1 chỉ sử dụng op1, User2 chỉ sử dụng op2, User3 chỉ sử dụng op3.&lt;/p&gt;

&lt;p&gt;Khi đó User1 vô tình phụ thuộc vào op2 và op3 mặc dù nó không gọi chúng, sự phụ thuộc này khiến cho User1 phãi được implement lại khi op2 và op3 bị thay đổi mặc dù nó không dùng hai hàm đó, hơn thế nữa việc gom quá nhiều phương thức vào một đối tượng khiến cho chúng ta nhập nhằng trong việc implement cho nên chúng ta nên giải quyết bằng cách tách biệt các phương thức thành các interface nhỏ như hình bên dưới.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu vấn đề này được triển khai trên ngôn ngữ tỉnh như Golang thì code của User1 sẻ phụ thuộc vào U1Ops và op1 nhưng sẻ không phụ thuộc vào OPS do đó khi có thay đổi đối với OPS mà User1 không quan tâm sẻ không làm cho User1 bị biên dịch lại và triển khai lại.&lt;/p&gt;

&lt;h3 id=&quot;5-dependency-inversion-principledip&quot;&gt;5. DEPENDENCY INVERSION PRINCIPLE(DIP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này cho chúng ta biết rằng các hệ thống linh hoạt nhất là các hệ thống phụ thuộc vào mã nguồn chỉ tham chiếu đến trừu tượng hóa, chứ không phụ thuộc đến các implementation.&lt;/p&gt;

&lt;p&gt;Hãy tưởng tượng phần mềm của chúng ta sẻ như thế nào trước khi có một cơ chế an toàn và thuận tiện cho đa hình, luồng đi của phần mềm này sẻ như cây mô tả bên dưới, các hàm main được gọi là các hàm level cao chúng gọi các hàm level trung bình và các hàm level trung bình gọi các hàm ở level thấp. Tuy nhiên có thể thấy rằng trong cây đó các phụ thuộc code không đi theo hướng của luồng gọi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/6.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/7.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để hàm main gọi một trong các hàm level cao, nó phải reference đến tên của module chứa hàm đó. Trong C chúng ta dùng #include trong Java và Go ta dùng câu lệnh import. Thật vậy, mỗi phần chứa hàm gọi buộc phải refer đến tên của module có chứa hàm được gọi. Rõ ràng sự phụ thuộc được thể hiện rằng hàm Main sẻ phụ thuộc vào các hàm dưới nó. Tuy nhiên, khi đa hình được đưa vào sử dụng, một điều rất khác sẻ xảy ra như sau.&lt;/p&gt;

&lt;p&gt;Chúng ta có thể thấy rằng module HL1 vẫn gọi hàm F () trong module ML1 nhưng thực tế là nó gọi hàm này thông qua một interface mà khi chạy thì interface thực sự không tồn tại. HL1 đơn giản gọi F () trong ML1 mặc dù là thể hiện gián tiếp.&lt;/p&gt;

&lt;p&gt;Tuy nhiên lưu ý rằng sự phụ thuộc mã nguồn (mối quan hệ thừa kế) giữa ML1 và interface trỏ theo hướng ngược lại so với luồng điều khiển. Điều này được gọi là sự đảo ngược phụ thuộc và các tác động của nó đối với kiến trúc phần mềm là rất sâu sắc. Thực tế là các ngôn ngữ OOP cung cấp tính đa hình an toàn và thuận tiện cho nên bất kỳ sự phụ thuộc mã nguồn nào bất kể nó ở đâu đều có thể đảo ngược.&lt;/p&gt;

&lt;p&gt;Bây giờ hãy nhìn lại luồng đi trong hình 6 và các phụ thuộc mã nguồn của nó thì bất kỳ phụ thuộc mã nguồn nào đều có thể được quay lại bằng cách chèn một interface giữa chúng. Với cách tiếp cận này các kiến trúc implement trong các hệ thống được viết bằng ngôn ngữ OOP có thể kiểm soát hướng của tất cả các phụ thuộc mã nguồn trong hệ thống. Đó là sức mạnh mà OOP cung cấp. Bạn có thể làm gì với sức mạnh đó? Ví dụ, bạn có thể sắp xếp lại các phụ thuộc mã nguồn của hệ thống để cơ sở dữ liệu và giao diện người dùng (UI) phụ thuộc vào các quy tắc nghiệp vụ chứ không phải là cách khác.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/8.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều này có nghĩa là gì? Là giao diện người dùng và cơ sở dữ liệu có thể được implement để bổ sung cho thể hiện các business logic, mã nguồn của business logic không bao giờ cần biết đến giao diện người dùng hoặc cơ sở dữ liệu. Kết quả là, các business logic cũng như giao diện người dùng và cơ sở dữ liệu có thể được biên dịch thành ba thành phần hoặc đơn vị triển khai riêng biệt và thành phần chứa business logic sẽ không phụ thuộc vào các thành phần có chứa giao diện người dùng và cơ sở dữ liệu, các thay đổi đối với giao diện người dùng hoặc cơ sở dữ liệu không có bất kỳ ảnh hưởng nào đến business logic. Tóm lại, khi mã nguồn trong một thành phần thay đổi thì chỉ thành phần đó cần phải được triển khai lại. Đây là khả năng triển khai độc lập, nếu các module trong hệ thống của bạn có thể được triển khai độc lập, thì chúng có thể được phát triển độc lập bởi các nhóm khác nhau.&lt;/p&gt;

&lt;p&gt;Qua việc tìm hiểu nguyên tắc này chúng ta cũng có thể thấy được sức mạnh của OOP đặc biệt là tính đa hình, thông qua việc sử dụng đa hình chúng ta có thể giành quyền kiểm soát tuyệt đối đối với mọi phụ thuộc mã nguồn trong hệ thống.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">Hệ thống phần mềm tốt phãi bắt đầu bằng clean code cũng giống như việc xây nhà, khi bắt đầu chúng ta cần những viên gạch tốt, nếu bắt đầu bởi những viên gạch không tốt thì cho dù kiến ​​trúc của tòa nhà ngon lành đến mấy cũng không còn quan trọng nữa vì nó đã dễ dàng sụp đổ. Một mặt khác, khi bạn đã có các viên gạch tốt, nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn. Ánh xạ sang Software Developmemnt, có một tập các nguyên tắc giúp chúng ta kết nối những viên gạch lại thành những bức tường, những component tốt. Một trong số đó là SOLID principle.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Hiểu Về Call Stack - Heap - Queue</title><link href="https://romeo.vn/hieu-ve-call-stack-heap-queue/" rel="alternate" type="text/html" title="Hiểu Về Call Stack - Heap - Queue" /><published>2017-08-14T12:45:00-05:00</published><updated>2017-08-14T12:45:00-05:00</updated><id>https://romeo.vn/hieu-ve-call-stack-heap-queue</id><content type="html" xml:base="https://romeo.vn/hieu-ve-call-stack-heap-queue/">&lt;h2 id=&quot;1-stack&quot;&gt;1. Stack:&lt;/h2&gt;

&lt;p&gt;Ứng với mỗi thread (hoặc 1 goruntine đối với Golang) của chương trình thường có một call stack. Khi ứng dụng bắt đầu được thực thi, các biến cục bộ, địa chỉ hàm, biến tham chiếu đối tượng….sẻ được lưu trữ trong Stack, tùy theo thứ tự gọi mà các thành phần đẩy vào stack được sắp xếp theo đúng thứ tự.
Khi 1 phương thức kết thúc cũng là lúc các giá trị biến và các tham chiếu đối tương được hủy bỏ — và địa chỉ hàm cũng được hủy bỏ ngay sau đó. Stack lưu trữ dung lượng thấp hơn rất nhiều so với heap.&lt;/p&gt;

&lt;p&gt;Khi lập trình với các ngôn ngữ như Java, Golang… chúng ta thường quan tâm đến stack size. Với Java trong môi trường 64-bit thì JVM mặc định có stack size cho mỗi thread là 1MB và Golang thì mặc định là 2kb.&lt;/p&gt;

&lt;p&gt;Trong Javascript, Golang và đa số các ngôn ngữ lập trình khác, khi chúng ta gọi một hàm để thực thi đồng nghĩa với việc chúng ta push một hàm vào stack, đến khi nào hàm đó thực thi xong và trả về thì mới được pop ra khỏi stack. Thao tác đó được mô tả như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/1.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Như hình trên, khi chúng ta thực thi một chương trình, đầu tiên chúng ta sẻ tìm đến hàm main, nơi mà mọi thực thi đều bắt đầu từ đây. Trong chương trình trên ta sẻ có các bước như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;console.log(bar(6))&lt;/strong&gt; được đưa vào stack. Hàm này gọi đến hàm &lt;strong&gt;bar&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp theo, &lt;strong&gt;bar(6)&lt;/strong&gt; được đưa vào stack, hàm &lt;strong&gt;bar&lt;/strong&gt; lại tiếp tục gọi hàm &lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp đó &lt;strong&gt;foo(x,y)&lt;/strong&gt; lại được đưa vào stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;foo&lt;/strong&gt; thực thi xong trả kết quả về cho hàm &lt;strong&gt;bar&lt;/strong&gt; và được pop ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;bar&lt;/strong&gt; nhận được kết quả từ hàm foo, thực thi xong trả về kết quả cho hàm &lt;strong&gt;console.log()&lt;/strong&gt; và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;console.log()&lt;/strong&gt; thực thi và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cuối cùng hàm &lt;strong&gt;main&lt;/strong&gt; cũng được loại bỏ ra khỏi stack, chương trình kết thúc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Đôi lúc chúng ta tạo ra một vòng lặp vô hạn khi chúng ta gọi nhiều đệ quy, với chrom thì thường giới hạn bởi 16.000 frames, nếu vượt ra khỏi con số đó thì sẻ sinh ra lỗi như sau :v&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-heap&quot;&gt;2. Heap:&lt;/h3&gt;

&lt;p&gt;Bộ nhớ Heap dùng để cấp phát bộ nhớ cho object, biến toàn cục.
Bất cứ khi nào khai báo đối tượng thì các giá trị của đối tượng sẽ được lưu trữ trong Heap (chú ý giá trị đối tượng chứ ko phải biến tham chiếu đối tượng) và có thể truy cập bất cứ khi nào trong chương trình, bộ nhớ tồn tại trong suốt quá trình thực thi chương trình&lt;/p&gt;

&lt;p&gt;Khi kết thúc 1 phương thức các biến tham chiếu đối tượng bị hủy trong stack và các tham chiếu tới các dữ liệu lưu trong Heap cũng bị hủy bỏ javascript sẻ dùng trình thu dọn rác để thực hiện kiểm tra các tham chiếu.. nếu ko còn tham chiếu nào tới biến lưu trữ trên vùng nhớ Heap thì các vùng nhớ đó sẽ được thu gom.&lt;/p&gt;

&lt;h3 id=&quot;3-queue&quot;&gt;3. Queue:&lt;/h3&gt;

&lt;p&gt;Đối với Javascript runtime thì có thêm một thành phần nữa đó là queue, đây là danh sách các message cần được sử lí và các hàm callback liên quan thực thi. Nói dễ hiểu hơn là các message này sẻ được lưu vào queue để phản hồi các sự kiện async bên ngoài chẳng hạn như sự kiện nhấp chuột hay một http reuquest với một callback được cung cấp.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">1. Stack:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry></feed>