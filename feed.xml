<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://romeo.vn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://romeo.vn/" rel="alternate" type="text/html" /><updated>2019-09-03T02:23:11-05:00</updated><id>https://romeo.vn/feed.xml</id><title type="html">Le Phuoc My</title><subtitle>A blog about technology and stuff related</subtitle><entry><title type="html">Xàm xí về Domain Driven Design - Part 4: Strategic Design - Context Maps</title><link href="https://romeo.vn/xam-xi-ve-ddd-part2-2/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 4: Strategic Design - Context Maps" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part2-2</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part2-2/">&lt;p&gt;Bài trước chúng ta đã thảo luận về một số khái niệm về Domain, SubDomain, BoundedContext….và phần nào hiểu được cách xác định chúng trong dự án của mình. Chúng ta đã biết Domain của chúng ta là gì, cần phãi giải quyết các SubDomain nào, ứng với các SubDomain sẻ có những Bounded Contexts nào. Vậy các Contexts đó có các quan hệ ra sao? Chúng ta sẻ tổ chức tích hợp chúng như thế nàp? 
Trong bài viết này chúng ta cùng thảo luận về quan hệ và cách tích hợp các các Bounded Context, chúng ta sẻ cùng nhau trả lời một số câu hỏi quan trọng tồn tại trong quá trình phân tích dự án như sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Đâu là ranh giới của các Bounded Contexts?&lt;/li&gt;
  &lt;li&gt;Có những mối quan hệ nào giữa các Bounded Contexts?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để các Bounded Context giao tiếp với nhau về mặt kĩ thuật?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để đối phó với những thay đổi không mong muốn xãy ra ở Upstream Context? Làm thế nào để các Upstream Context không gây rắc rối cho các Downstream Context?&lt;/li&gt;
  &lt;li&gt;Làm thế nào để tổ chức ánh xạ ngữ nghĩa các Domain Model giữa các Bounded Context cũng như làm thế nào để translate các thuật ngữ trong ubiquitous language sang các ngôn ngữ khác.&lt;/li&gt;
  &lt;li&gt;Các Principles trong việc tổ chức integrate các Bounded Context là gì?&lt;/li&gt;
  &lt;li&gt;Những giá trị lớn lao khi tổ chức, xây dựng tốt các Context Maps(Integrate chúng một cách dễ dàng, tính cohesion cao mà lại low coupling, dễ duy trì, mở rộng, tạo nguổn dữ liệu real time cho việc mining, phân tích,…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Câu trả lời cho các câu hỏi trên sẻ được tổng hợp trong một thứ gọi là Context Map.&lt;/p&gt;

&lt;h3 id=&quot;mối-quan-hệ-giữa-các-bounded-context&quot;&gt;Mối quan hệ giữa các Bounded Context:&lt;/h3&gt;
&lt;p&gt;Trong các hệ thống lớn, phức tạp, hầu hết các Bounded Context sẽ có một số mối quan hệ với các Bounded Context khác. Việc xác định các mối quan hệ này có tầm quan trọng không chỉ về mặt kỹ thuật (các hệ thống sẽ giao tiếp với nhau như thế nào) mà còn cả cách chúng được phát triển (các team sẽ phối hợp với nhau ra sao).&lt;/p&gt;

&lt;p&gt;Cách phổ biến nhất để xác định mối quan hệ giữa các Bounded Context là phân loại các Bounded Context thành các Upstream và Downstream contexts. Điều đó tương tự như hình ảnh các thành phố bên cạnh một dòng sông, các thành phố ở thượng nguồn(Upstream) sẻ đổ những gì muốn truyền cho các thành phố ở hạ lưu(Downstream) xuống sông, những thứ đó sẻ được đưa đến các thành phố ở hạ lưu và họ chỉ cần vớt lên từ dưới sông.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-20-xam-xi-ve-ddd-part2-2/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên việc chia thành các Upstream và Downstream contexts sẻ có ưu và nhược điểm riêng của nó. Một Upstream Context sẻ không phụ thuộc vào bất kỳ Context nào khác, nó sẻ tự do phát triển theo bất kỳ hướng nào. Tuy nhiên, hệ quả của bất kỳ thay đổi nào ở Upstream Context cũng có thể gây ảnh hưởng nghiêm trọng đối với các Downstream Context. Một Downstream Context bị hạn chế bởi sự phụ thuộc của nó vào Upstream Context nhưng lại không phãi quá lo lắng vì những thay đổi của nó sẻ gây ảnh hướng cho các Downstream Context, điều này giúp các nhà developer tại Downstream Context sẻ tự do hơn các developer tại Upstream Context muốn làm gì cũng phãi nhìn trước ngó sau.&lt;/p&gt;

&lt;h4 id=&quot;partnership&quot;&gt;Partnership&lt;/h4&gt;
&lt;h4 id=&quot;shared-kernel&quot;&gt;Shared Kernel&lt;/h4&gt;
&lt;h4 id=&quot;customer-supplier&quot;&gt;Customer-Supplier&lt;/h4&gt;

&lt;p&gt;Updating……&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Bài trước chúng ta đã thảo luận về một số khái niệm về Domain, SubDomain, BoundedContext….và phần nào hiểu được cách xác định chúng trong dự án của mình. Chúng ta đã biết Domain của chúng ta là gì, cần phãi giải quyết các SubDomain nào, ứng với các SubDomain sẻ có những Bounded Contexts nào. Vậy các Contexts đó có các quan hệ ra sao? Chúng ta sẻ tổ chức tích hợp chúng như thế nàp? Trong bài viết này chúng ta cùng thảo luận về quan hệ và cách tích hợp các các Bounded Context, chúng ta sẻ cùng nhau trả lời một số câu hỏi quan trọng tồn tại trong quá trình phân tích dự án như sau: Đâu là ranh giới của các Bounded Contexts? Có những mối quan hệ nào giữa các Bounded Contexts? Làm thế nào để các Bounded Context giao tiếp với nhau về mặt kĩ thuật? Làm thế nào để đối phó với những thay đổi không mong muốn xãy ra ở Upstream Context? Làm thế nào để các Upstream Context không gây rắc rối cho các Downstream Context? Làm thế nào để tổ chức ánh xạ ngữ nghĩa các Domain Model giữa các Bounded Context cũng như làm thế nào để translate các thuật ngữ trong ubiquitous language sang các ngôn ngữ khác. Các Principles trong việc tổ chức integrate các Bounded Context là gì? Những giá trị lớn lao khi tổ chức, xây dựng tốt các Context Maps(Integrate chúng một cách dễ dàng, tính cohesion cao mà lại low coupling, dễ duy trì, mở rộng, tạo nguổn dữ liệu real time cho việc mining, phân tích,…)</summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - Part 3: Strategic Design - SubDomain - Bounded Context</title><link href="https://romeo.vn/xam-xi-ve-ddd-part2-1/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 3: Strategic Design - SubDomain - Bounded Context" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part2-1</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part2-1/">&lt;p&gt;Ở bài trước mình đã phần nào đưa ra ý kiến cá nhân về định nghĩa, mục đích sử dụng domain driven design trong việc phát triển các enterprise system. Trong bài này mình tiếp tục nói về công cụ của quan trọng nhất của DDD - Strategic Design, sự thiết yếu của Strategic Design, nói về approach để chúng ta xử lí một hệ thống phức tạp, về approach để chia nhỏ hệ thống bên cạnh đó phần nào làm rõ các khái niệm như Ubiquitous Language, Bounded Context, Subdomain,….&lt;/p&gt;

&lt;p&gt;Khi nói đến việc xử lí một Domain lớn, một vấn đề lớn và phức tạp thường chúng ta tiếp cận dựa trên &lt;strong&gt;Problem space&lt;/strong&gt; và &lt;strong&gt;Solution Space&lt;/strong&gt;. &lt;strong&gt;Problem space&lt;/strong&gt; trả lời một tập các câu hỏi What? Hướng chúng ta nghĩ đến các business problems cần được giải quyết nhằm trả lời câu hỏi What lớn nhất là Domain của chúng ta. Trong khi đó &lt;strong&gt;Solution space&lt;/strong&gt; tập trung vào việc trả lời các câu hỏi How? hướng chúng ta nghĩ đến cách chúng ta sẽ triển khai phần mềm để giải quyết các vấn đề business đó. &lt;strong&gt;Problem Space&lt;/strong&gt; và &lt;strong&gt;Solution Space&lt;/strong&gt; là nền tảng cho việc xử lí hệ thống phức tạp của chúng ta. Về cơ bản DDD hướng chúng ta giảm sực phức tạp bằng cách chia nhỏ &lt;strong&gt;Problem Space&lt;/strong&gt; và &lt;strong&gt;Solution Space&lt;/strong&gt; của domain mà chúng ta hướng tới.&lt;/p&gt;

&lt;h3 id=&quot;problem-space-và-sub-domain&quot;&gt;Problem space và Sub Domain:&lt;/h3&gt;
&lt;p&gt;Như nội dung bài trước mình đã đề cập, một Domain là một thứ gì đó cực kì rộng lớn và trừu tượng, từ một khía cạnh nào đó chúng ta có thể định nghĩa Domain là các problems mà hệ thống của chúng ta sẻ giải quyết, do đó có thể gọi tập hợp các problems đó là Problem Space.&lt;/p&gt;

&lt;p&gt;Để làm cho một Domain trở nên cụ thể và dễ phân tích đánh giá hơn chúng ta thường chia nhỏ Problem Space của Domain đó ra thành các problem nhỏ hơn, chúng có thể được hiểu là các Sub Domain. Sub Domain được chia thành ba loại sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Core Domain: Core Domain là những gì mang đến giá trị cốt lõi cho business của bạn, là những gì thể hiện xứ mệnh tổ chức của bạn. Core Domain phãi chứa những gì làm cho tổ chức của bạn trở nên khác biệt so với các tổ chức khác trong cùng lĩnh vực, một công ty không thể nào trụ được và thành công nếu không có gì đặc biệt so với các công ty khác.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Supporting Sub Domain: Đôi lúc một hệ thống cần phãi giải quyết một số vấn đề chuyên biệt để hổ trợ cho các core business của hệ thống, các vấn đề đó là cần thiết nhưng không phãi là cốt lõi của hệ thống, nó được gọi là Supporting Sub Domain. Một ví dụ như phần Suggestion của TIKI, nó không là phần quan trọng nhất nhưng là phần hổ trợ cực mạnh mẻ cho Core business của Tiki. Nó được gọi là Supporting Sub Domain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Generic Sub Domain: Là một Sub Domain chung chung hoạt động nhiều nơi trong hệ thống, không chứa bất cứ gì chuyên biệt cho hệ thống nhưng vẫn cần thiết để hệ thống có thể hoạt động.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để hiểu hơn về việc chia tách thành các Subdomains, chúng ta hãy nghĩ về việc design một hệ thống e-commerce như TIKI chẳng hạn. Những yêu cầu cơ bản tối thiểu để người mua hàng và người bán hàng có thể sử dụng được là phãi có một danh mục sản phẫm cho cả hai,  quản lí kho bãi, cho phép người ta đặt hàng, thanh toán, vận chuyển….như vậy về cơ bản chúng ta sẻ có một số subdomains chính đó là Product Catalog, Inventory, Order, Payment, Shipping, Suggesting, Forecasting, Event….&lt;/p&gt;

&lt;p&gt;Cái nhìn cá nhân của mình thấy rằng rõ ràng Core Domain của họ là giải quyết các vấn đề của người mua và người bán dựa trên một Marketplace gồm Product Catalog, Product Listing, Buying…, đó là giá trị cốt lõi của TIKI mà mọi người nhìn thấy và nhớ đến. Bên cạnh đó có thêm các thành phần Supporting Sub Domain như Suggesting, Forecasting về cơ bản nó không quan trọng bằng Marketplace tuy nhiên lại bổ trợ cực kì mạnh mẻ cho Core Business của hệ thống. Hệ thống suggestion hoạt động thông minh mang lại trải nghiệm mua sắm tốt cho người dùng, hệ thống dự báo hoạt động thông minh có thể giúp các nhà cung cấp nhận thức đánh giá được thị trường, đưa ra các quyết định kinh doanh đúng đắn hơn.  Các Supporting Sub Domain đó gián tiếp mang lại thành công cho core business. Ngoài ra còn có một số Generic Sub Domain ví dụ như user identity, authorization/authentication là những thứ cần thiết cho hệ thống&lt;/p&gt;

&lt;p&gt;Một điều đáng chú ý là một Sub Domain có thể thuộc hai loại Sub Domain khác nhau, nếu một marketplace đặt trải nghiệm người mua hàng lên hàng đầu, muốn xây dựng một hệ thống suggestion system nhằm tạo ra sự khác biệt, lợi thế đối với các tổ chức khác thì Suggestion cũng sẻ có thể coi Core Sub Domain.&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta có thể thấy rằng &lt;strong&gt;Problem Space&lt;/strong&gt; cuối cùng cũng là các phần của Domain cần được phát triển để tạo nên core Domain. Đồng nghĩa với việc đánh giá, phân tích &lt;strong&gt;Problem Space&lt;/strong&gt; của một domain lớn sẻ liên quan đến việc phân tích các Sub Domain đã hiện hữu hay chưa và sự hiện hữu của các Sub Domain đó có thực sự cần thiết hay không. Sub Domain cho phép chúng ta có cái nhìn vừa bao quát vừa chi tiết các thành phần vấn đề khác nhau của Domain lớn, do đó Sub Domains là một công cụ rất hữu ích trong việc đánh giá, phân tích &lt;strong&gt;Problem Space&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã phần nào rõ ràng các khái niệm về &lt;strong&gt;Problem space, SubDomain.&lt;/strong&gt; Vậy làm sao để tiếp cận một dự án phức tạp và lèo lái dự án đi đúng hướng? Chúng ta phãi trả lời các câu hỏi sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Core Domain của chúng ta là gì?&lt;/li&gt;
  &lt;li&gt;Tầm nhìn mục tiêu chiến lược về Core Domain đó là gì?&lt;/li&gt;
  &lt;li&gt;Những thành phần nào nên được coi là một phần của Core Domain?&lt;/li&gt;
  &lt;li&gt;Các Supporting Subdomains và Generic Subdomains nào là cần thiết đối với hệ thống?&lt;/li&gt;
  &lt;li&gt;Trong từng khu vực của hệ thống sẻ có những nhân tố nào(engineer, domain expert…)?&lt;/li&gt;
  &lt;li&gt;Mỗi nhân tố đó sẻ đóng góp ra sao?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Một khi đã xác định rõ ràng được tầm nhìn và mục tiêu chiến lược của Core Domain và các thành phần cần thiết để hỗ trợ, bổ trợ cho Core Domain, chúng ta sẻ có được chiến lượt tốt nhằm tập trung ưu tiên nguồn lực, sức mạnh, tầm nhìn, bí quyết để phát triển Core Domain, đồng thời đảm bảo rằng tất cả các bên liên quan trong hệ thống có được sự liên kết chặc chẻ và cam kết hợp tác dựa trên một tầm nhìn chung, không lang mang giao động, không cảm thấy chơi vơi không biết mình đang làm gì, biết mình đang phục vụ core domain như thế nào, đóng góp ra sao…..&lt;/p&gt;

&lt;h3 id=&quot;solution-space-và-boundex-context&quot;&gt;Solution Space và Boundex Context:&lt;/h3&gt;
&lt;p&gt;Chúng ta đã xác định Problem Space với các Sub Domain được chia nhỏ, ứng với từng Sub Domain chúng ta sẻ có một hoặc nhiều Solution/ Boundex Context để giải quyết nó, tập hợp chúng gọi là &lt;strong&gt;Solution Space.&lt;/strong&gt; Như vậy chúng ta tạm định nghĩa có phần chưa hoàn chỉnh rằng Solution Space là nơi các vấn đề được giải quyết trong thực tế và Bounded Context là mỗi câu trả lời cho mỗi problem trong Problem Space, là một giải pháp cụ thể, một quan điểm hiện thực hóa, được sử dụng để hiện thực hóa một giải pháp.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó chúng ta cũng có thể hình dung rằng mỗi một Bounded Context xác định một cách nhìn nhận về một phần của domain business. Một thành phần business có thể có mặt ở nhiều nơi trong một hệ thống tuy nhiên tại mỗi khu vực, mỗi context của hệ thống có thể nhìn nhận thành phần đó một cách khác nhau đó cũng chính là nguyên nhân vì sao họ gọi đó là Bounded Context.&lt;/p&gt;

&lt;p&gt;Theo lẻ thông thường, chúng ta luôn có một quan hệ 1-1 là lí tưởng cho một câu hỏi và một câu trả lời, do đó để đơn giản hoá chúng ta nên cố gắng chia các Subdomain và Bounded Context sao cho chúng luôn có sự liên kết 1-1 giữa một Subdomain và một Bounded Context.&lt;/p&gt;

&lt;p&gt;Tuy nhiên trong thực tế ta nên linh động trong việc define các Subdomain và Bounded Context cho hợp lí, một hệ thống phức tạp có rất ít Domain nhỏ và đơn giản chỉ có một Ubiquitous Language và một model duy nhất biểu diễn mọi thứ về một Sub Domain đồng thời luôn có một liên kết đẹp đẻ 1-1 giữa Sub Domain và Bounded Context như vậy. Các business rule thường chống chéo, conflict, rối rắm rất nhiều. Cũng là một thuật ngữ nhưng có thể mang nhiều nghĩa khác nhau ở các context khác nhau, và cũng có thể hai từ khác nhau như lại cùng mang một ý nghĩa ở các context khác nhau. Thông thường sẻ có nhiều solution cùng phối hợp để giải quyết một problem trong &lt;strong&gt;Problem Space&lt;/strong&gt; tuỳ thuộc vào cách bạn nhìn nhận nó. Mỗi một Bounded Context là một trong nhiều solution để giải quyết một problem, do đó một Sub Domain có thể có nhiều Bounded Context. Bên cạnh đó, bạn cũng có thể dễ dàng tìm thấy một Bounded Context trãi dài qua nhiều Sub Domain, trong trường hợp đó giữa các Bounded Context và các Sub Domain sẻ có các thuật ngữ, đối tượng cụ thể theo từng Bounded Context, cho nên chắc chắn sẻ xãy ra việc xung đột chồng chéo ý nghĩa các thuật ngữ tại các BoundeD context khác nhau.&lt;/p&gt;

&lt;p&gt;Lấy ví dụ trong một marketplace, thuật ngữ User trong context khách hàng duyệt catalog thì User mang ý nghĩa một Object biểu diễn hạng khách hàng(vàng, bạc, bạch kim…), mức giảm giá đối với khách hàng này, tuy nhiên trong context khách hàng order thì User lại phãi là một Object biểu diễn thông tin như địa chỉ, thông tin thanh toán,…. điều đó sẽ làm tăng nguy cơ quá tải các thuật ngữ do quá nhiều Subdomain sẽ được thể hiện thông qua cùng một Ubiquitous Language.&lt;/p&gt;

&lt;p&gt;Một khi toàn bộ Domain của một của tổ chức đã được chia ra thành các SubDomain, các Bounded Contexts rồi thì chúng ta chỉ cần tập trung vào một khu vực cụ thể thay vì toàn bộ business domain. Tuy nhiên cũng có những trường hợp không thể chia được khi đó bắt buộc chúng ta phãi tách một số domain code ra(shared kernal) để chia sẻ cho nhiều khu vực muốn sử dụng.&lt;/p&gt;

&lt;p&gt;Hãy nhớ rằng &lt;strong&gt;Problem Space&lt;/strong&gt; là sự kết hợp giữa Core Domain, các Supporting Domain và Generic Domain&lt;strong&gt;.&lt;/strong&gt; Khi bạn đã hiểu rõ về &lt;strong&gt;Problem space&lt;/strong&gt;, bạn sẻ ra được &lt;strong&gt;Solution space&lt;/strong&gt;. &lt;strong&gt;Solution space&lt;/strong&gt; sẽ bị ảnh hưởng mạnh mẽ bởi hệ thống, công nghệ hiện có và những hệ thống mới sẻ được tạo ra. Ở đây chúng ta cần phải phân tích về các Bounded Context, hãy cân nhắc những câu hỏi quan trọng sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hệ thống hiện tại đang có những gì?&lt;/li&gt;
  &lt;li&gt;Những thứ đó có thể được tái sử dụng hay không?&lt;/li&gt;
  &lt;li&gt;Những gì cần được thêm vào để thoả mãn mục tiêu cuối cùng?&lt;/li&gt;
  &lt;li&gt;Làm thế nào tất cả những thứ có sẳn và những thứ mới được thêm vào có thể kết nối với nhau, tích hợp với nhau?&lt;/li&gt;
  &lt;li&gt;Xác xuất mà mỗi quyết định chiến lượt đó sẻ thành công, thất bại, làm delay quá trình phát triển như thế nào?&lt;/li&gt;
  &lt;li&gt;Chúng ta phãi quản lí hệ thống các thuật ngữ của các Ubiquitous Languages giữa các context như thế nào? Quản lí sự khác nhau về mặt ngữ nghĩa các mỗi khái niệm/thuật ngữ, sự chồng chéo, xung đột ngữ nghĩa giữa các bounded context khác nhau ra sao?&lt;/li&gt;
  &lt;li&gt;Quyết định độ lớn của một Bounded Context như thế nào? Trong một Bounded Context nên chứa bao nhiêu Modules, Aggregates, loại Event, Services?&lt;/li&gt;
  &lt;li&gt;Trong một Boundex Context nào sẻ chứa các concepts giải quyết Core Domain? Các Tactical Parterns nào sẻ được sử dụng cho việc model chúng?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;size-của-bounded-context&quot;&gt;Size của Bounded Context:&lt;/h4&gt;
&lt;p&gt;Xác định độ lớn của một Bounded Context như thế nào là hợp lí? Trong một Bounded Context nên chứa bao nhiêu Modules, Aggregates, loại Event, Services?&lt;/p&gt;

&lt;p&gt;Thực sự không có một câu trả lời cho con số chính xác cho câu hỏi trên. Một bouded context cần đủ lớn để thể hiện đầy đủ một Ubiquitous Language trong chính nó.&lt;/p&gt;

&lt;p&gt;Các khái niệm ngoại lai không thực sự là thành phần của Core Domain thì nên được cân nhắc mức độ quan trọng mới được đưa bào Ubiquitous Language. Nếu một khái niệm không có trong Ubiquitous Language của bạn, thì nó không nên được đưa vào model ngay từ đầu, nếu một hoặc nhiều khái niệm ngoại lai chen vào, hãy loại bỏ chúng ra, chúng có thể thuộc về một Supporting hoặc Generic Subdomain hoặc không thuộc model nào cả. 
Hãy cẩn thận để không nhầm lẫn các yếu tố là thành phần thực sự của Core Domain. Model của bạn phải thể hiện hoàn toàn sự phong phú của Ubiquitous Language trong ngữ cảnh, không để xót thứ gì thiết yếu cũng như không có quá nhiều thứ nhỏ nhặt rối rắm khiến chúng ta khó hình dung được thứ gì là cốt lõi cần tập trung thứ gì là nhỏ nhặt không đáng đề cao. Các công cụ như Context Map có thể giúp chúng ta đánh giá những tiêu chí đó một cách tốt hơn.&lt;/p&gt;

&lt;p&gt;Bên cạnh đó cũng sẻ có một số nguyên nhân dẫn đến việc chúng ta tạo ra một Bounded Context với một kích thước sai lầm. Những điều gì có thể dẫn chúng ta tạo ra một Bounded Context có kích thước sai?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Chúng ta có thể sai lầm khi chấp nhận các ảnh hưởng đến từ kiến ​​trúc thay vì Ubiquitous Language dẫn lối chúng ta. Trong quá trình phát triển phần mềm, các engineer có xu hướng chuyển một Bounded Context thành một Fake Context ứng với mục tiêu phát triển của họ, Fake Context đó đôi lúc bị phụ thuộc vào một platform, framework hoặc một vài thành phần infrastructure giúp ích cho việc implement, vô hình chung khiến các engineer không thể tập trung nhìn nhận các Bounded Context như với mục đích ban đầu, họ cân nhắc các ranh giới kĩ thuật thay cho ranh giới ngôn ngữ mà các Bounded Context bám víu vào, làm méo mó tầm nhìn đến từng Bounded Context.&lt;/li&gt;
  &lt;li&gt;Một sai lầm nữa là thay vì dùng Bounded Context để phân chia trách nhiệm thì các manager dùng việc chia Bounded Context để chia task, quản lí task cho Engineer Team, họ có xu hướng coi các Bounded Context là Fake Context của họ nhằm áp dụng các mục tiêu quản lí. Vì một số chiến lược về mặt quản lí mà họ có thể thêm bớt nhiều nhu cầu, thành phần dẫn đến việc không còn nhìn nhận đúng bản chất, kích thước cũng như méo mó tầm nhìn đến từng Bounded Context.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Ở bài trước mình đã phần nào đưa ra ý kiến cá nhân về định nghĩa, mục đích sử dụng domain driven design trong việc phát triển các enterprise system. Trong bài này mình tiếp tục nói về công cụ của quan trọng nhất của DDD - Strategic Design, sự thiết yếu của Strategic Design, nói về approach để chúng ta xử lí một hệ thống phức tạp, về approach để chia nhỏ hệ thống bên cạnh đó phần nào làm rõ các khái niệm như Ubiquitous Language, Bounded Context, Subdomain,….</summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - Part 1</title><link href="https://romeo.vn/xam-xi-ve-ddd-part1-1/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 1" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part1-1</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part1-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/5.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Có bao giờ bạn làm việc trong một hệ thống thực sự lớn, nơi mà bạn phãi trăn trở đấu tranh với bản thân làm sao để tổ chức một lượng lớn business logic sao cho phù hợp? Business thì luôn luôn thay đổi cùng với sự chồng chéo rối rắm khiến bạn stress, hiệu xuất làm việc của bạn đi xuống, làm thế nào để lường trước và tránh tình trạng đó xãy ra?&lt;/p&gt;

&lt;p&gt;Có bao giờ bạn làm việc trong một codebase mà cứ hể thêm code vào là thấy một nùi phức tạp lòi ra? Hơn nữa bạn không thể biết nó sẻ đụng chạm đến những thứ nào khác hay không, làm sao để tránh tạo ra một code base kiểu đó?&lt;/p&gt;

&lt;p&gt;Thử đứng dưới góc độ của một người quản lí, làm sao chúng ta control việc phát triển của một ứng dụng phức tạp một cách mượt mà trơn tru. Nơi mà sự phức tạp cứ luôn luôn tăng, luôn luôn ập đến? Điều đó cũng kéo theo quá nhiều rủi ro, vậy chúng ta phãi quản lí, đối phó với những rủi ro đó như thế nào?&lt;/p&gt;

&lt;p&gt;Làm sao chúng ta chia một hệ thống lớn thành nhiều phần và giao chúng cho các team khác nhau cùng phối hợp phát triển và tích hợp chúng lại một cách mượt mà, nhịp nhàng và hiệu quả?&lt;/p&gt;

&lt;p&gt;Mình từng may mắn có cơ hội tham gia vào một dự án khá lớn với vài chục modules mà trong mỗi module là rất nhiều sự phức tạp khác nhau, điều đó phần nào giúp mình nếm trãi được sự đắng cay của complexity. Domain Driven Design chính xác là bài thuốc đã phần nào giúp mình thoát khỏi nổi đau đó. Nó là bài thuốc gần như là tốt nhất dành cho các Enterprise System phức tạp.&lt;/p&gt;

&lt;p&gt;Thực sự Domain Driven Design thì đã từng nghe và tìm hiểu về nó từ thời gian trước. Tuy nhiên việc thiếu nhận thức về sự cấp thiết, tính chất quy mô các dự án trước đó và khả năng bản thân tại thời điểm đó chưa thể lĩnh hội được cũng như áp dụng trong thực tế. Đến khoản thời gian một năm đổ lại đây, khi tham gia vào một dự án thực sự lớn và phức tạp thì mình mới thấm thía về tính thiết yếu của DDD đối với các software engineer, đặc biệt là trong các dự án lớn có độ phức tạo cao.&lt;/p&gt;

&lt;p&gt;Với hơn 15 năm phát triển kể từ khi được giới thiệu từ năm 2003, DDD bây giờ không chỉ là một phương pháp, cách tiếp cận trong thiết kế phần mềm nữa. DDD thực sự cần thiết trong mọi ngóc ngách của quá trình phát triển phần mềm. Từ khâu tiếp nhận requirement, thảo luận làm rõ domain knowledge đến khâu decouple, design cho đến tổ chức quản lí phối hợp các đội nhóm. DDD thực sự powerful đối với chúng ta.&lt;/p&gt;

&lt;p&gt;Trong chuỗi bài xàm xí này mình sẻ cố gắn tập trung ghi lại kiến thức bản thân về Domain Driven Design bạn đọc nếu có thấy bất cứ sai lầm thiếu sót nào mong rằng sẻ comment ở dưới để mình cũng cố thêm.&lt;/p&gt;

&lt;p&gt;Mở đầu cho chuổi xàm xí này mình sẻ điểm nhanh trãi nghiệm bản thân qua các dự án với các mẫu kiến trúc.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;MVC Architecture&lt;/li&gt;
  &lt;li&gt;Database Centric Approach với mô hình 3-Layers và Transaction Script&lt;/li&gt;
  &lt;li&gt;Anemic Domain Model vs Rich Domain Model&lt;/li&gt;
  &lt;li&gt;Conclusion&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-mvc-architecture&quot;&gt;1. MVC Architecture:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi bắt đầu đi làm, mẫu thiết kế đầu tiên mình được tiếp cận đó là MVC. Nhìn chung với ứng dụng nhỏ đơn giản thì mô hình này khá ổn.&lt;/p&gt;

&lt;p&gt;Code được tổ chức riêng biệt thành các thành phần Model - View - Controller tách bạch rõ ràng, bước đầu tương đối dễ quản lí và phát triển dự án. Code base khá đơn giản, đáp ứng yêu cầu về tốc độ phát triển. Người mới có thể nhanh chóng nắm được bộ source.&lt;/p&gt;

&lt;p&gt;Tuy nhiên, với đội ngủ có chuyên môn chưa cao, chưa thật sự cứng với các mô hình principles như SOLID chẳng hạn thì thật sự khó quản lí một cách lâu dài. Vì logic quá tập trung đóng gói trong Data model lẫn Business Model, các model của chúng ta có xu hướng phình to và rất khó có thể chia nhỏ cả bề ngang lẫn bề dọc. MVC thật sự là không còn khả dụng với các ứng dụng vừa và lớn.&lt;/p&gt;

&lt;h4 id=&quot;2-database-centric-approach-với-mô-hình-3-layers-và-transaction-script&quot;&gt;2. Database Centric Approach với mô hình 3-Layers và Transaction Script&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Đa số các dự án mình tham gia trước đó đều dựa trên Database Centric Approach với mô hình 3-Layers và Transaction Script.&lt;/p&gt;

&lt;p&gt;Với Database-Centric Approach, database là trung tâm của ứng dụng khi đó mọi thứ sẻ phãi hướng sự phụ thuộc vào database. Với approach này business logic có xu hướng dính chặt với data access logic, thường đi đôi với Transaction Script partern. Với Transaction Script chúng ta sẻ rất khó để chia thành các layer. Trong trường hợp chúng ta sử dụng Relational business logic thường chứa các thủ tục với database luôn do đó việc phát triển ứng dụng thường được bắt đầu bằng việc design bằng việc design database.&lt;/p&gt;

&lt;p&gt;Database-Centric Approach cùng với Transaction Script thật sự tốt khi ứng dụng chúng ta có ít business rules, chúng ta chỉ muốn thực hiện việc xử lí dữ liệu CRUD đơn giản.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với cách tiếp cận này để reuse code chúng ta thường dùng database làm điểm tích hợp. Bằng việc sử dụng các thư viện, helper liên quan đến database như CrudRepository với Java Bean trong Spring chẳng hạn, với cơ chế auto implement rất tiện lợi sẻ giúp chúng ta tiết kiệm rất nhiều effort trong việc phát triển ứng dụng.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên với Database Centric approach, vì business logic có xu hướng dính chặt với data access logic nên lúc business thay đổi, mở rộng hoặc refactor thường rất vất vã khi mọi thứ dính chùm với nhau. Tương tự việc optimize cũng diễn ra thực sự nhọc nhằn.&lt;/p&gt;

&lt;p&gt;Cùng với đó là sự gia tăng của complexity thực sự gây áp lực lên ứng dụng dựa trên Database Centric approach. Với một ứng dụng phức tạp mà mình đã từng tham gia, đã có cơ hội nhìn thấy hồi kết của approach này. Sau một thời gian nhất định, mọi nổ lực để thêm mới business rules hoặc thay đổi một thứ gì đó gần như là không thể.&lt;/p&gt;

&lt;p&gt;Với cách tiếp cận này mình cũng có một trãi nghiệm cay đắng đó là khi phát triển một service dựa trên code base có sẳn với mô hình 3 lớp như trên. Về bản chất 3-Layered Architecture thực sự mạnh mẻ và có khả năng mở rộng cao, điều đó được chứng minh qua thời gian bởi đã có rất nhiều project thành công với lối kiến trúc này. 3-Layered Architecture đã tách bạch các concerns với 3 tầng Presentation Layer, Business Layer và Data Layer. Điều đó gíup chúng ta đạt được tính linh hoạt và khả năng mở rộng cao cho một hệ thống phần mềm. Tuy nhiên khi làm việc cùng Database Centric Approach, các engineer thường vướng một sai lầm, mình cũng đã tiếp nối sai lầm của các engineer trước đó của một bộ source. Đó là việc dùng Transaction Script làm cho Data Access Layer và Business Layer dính chặt với nhau. Khi bước vào với dự án mình đã cảm giác có gì đó không ổn và muốn chia thêm layer theo hướng Clean Architecture, nhưng với Database Centric approach, với anamic model approach và transaction script thì việc chia tầng là điều không thể làm đối với một lượng logic lớn. Việc thiếu khả năng thuyết phục một khoản upfront cost cho một kiến trúc phức tạp ngay từ ban đầu với Domain Centric approach và Clean Architecture, các yêu cầu business ập đến bắt buộc phãi sống chung với lũ, do đó technical debt liên tục tăng lên đến một thời điểm dường như không nhúc nhích được.&lt;/p&gt;

&lt;h4 id=&quot;3-anemic-domain-model-vs-rich-domain-model&quot;&gt;3. Anemic Domain Model vs Rich Domain Model&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/6.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Có một thực tế rằng trước khi nghiêm túc với DDD và apply nó vào dự án thì cho dù sau một số dự án lớn nhỏ dù đã biết những ý tưởng về Clean Architecture đi chăng nữa mình vẫn chưa nhận thức được tính thiết yếu của Rich Domain Model đối với một ứng dụng phức tạp. Một cách vô tình hay quán tính thì tất cả dự án trước đó mình tham gia đều sử dụng Anemic Domain Model. Đây chỉ là các Enitity model được biểu diễn bởi các class/struct chỉ chứa cấu trúc dữ liệu và mối quan hệ giữa chúng với các Entity khác. Với việc các Entity Model này ít khi chứa logic nghiệp vụ dẫn đến bắt buộc tụi mình phãi đẩy hết logic nghiệp vụ vào tầng service(đối với mô hình ba lớp) và đẩy vào tầng usecases(Clean Architecture).&lt;/p&gt;

&lt;p&gt;Cũng theo một lẻ tự nhiên, các Entity đó lập tức được ánh xạ quán tính 1:1 với một Table trong database ngay. Lúc đó việc quản lí persisting của các Entity trở nên rối rắm, hai tình huống xãy ra đó là chấp nhận việc lỏng lẻo trong consystency hoặc dùng transaction script giữa nhiều Entity(đại diện cho nhiều Table) để quản lí transaction. Rõ ràng hãy thử tưởng tượng với một lượng logic khổng lồ xem nó sẻ rối như thế nào.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-07-17-xam-xi-ve-ddd-part1/7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DDD đến cùng với cách tiếp cận hoàn toàn khác về việc chia code theo từng layer và model hoá dựa trên domain model đã giúp giảm đi sự gia tăng phức tạp theo thời gian. Mình sẻ giới thiệu Rich Domain Model trong các bài tiếp sau.&lt;/p&gt;

&lt;h4 id=&quot;4-conclusion&quot;&gt;4. Conclusion&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Một architecture tốt có giá trị cực kì to lớn trong việc tạo tiền đề, thúc đẩy những điều mới mẻ, hay ho hơn vào hệ thống của chúng ta thay vì làm chúng ta mất quá nhiều effort để lo những thứ mà architecture không tốt gây nên. Do đó, với tầm nhìn xây dựng một hệ thống phần mềm phức tạp, chúng ta nên ưu tiên một khoản upfront cost ban đầu cho việc xây dựng một kiến trúc tốt, mặc dù chi phí khởi tạo có vẻ đắt đỏ hơn so với các kiến trúc đơn giản khác nhưng về lâu về dài lại tối thiểu hoá được chi phí phát triển, vận hành và duy trì hệ thống.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Đối&lt;/em&gt; &lt;em&gt;với&lt;/em&gt; &lt;em&gt;các&lt;/em&gt; &lt;em&gt;hệ&lt;/em&gt; &lt;em&gt;thống&lt;/em&gt; &lt;em&gt;phức&lt;/em&gt; &lt;em&gt;tạp&lt;/em&gt; bằng việc sử dụng những kĩ thuật mà DDD refer như Domain Centric Approach với Rich Domain Model, sử dụng Value Object Type thay vì Primitive Type và nhiều kĩ thuật trong DDD mình chưa liệt kê, chúng sẻ giúp hệ thống của chúng ta mạnh mẻ hơn trước sự phức tạp, đáp ứng yêu cầu cho một kiến trúc tốt.&lt;/li&gt;
  &lt;li&gt;Bên cạnh đó các kiến thức về hoạch định chiến lượt mà DDD mang lại cũng có giá trị to lớn đối với các nhà quản lí. DDD không là viên đạn bạc cho mọi trận chiến nhưng là vũ khí cực kì tối tân cho các ứng dụng lớn và phức tạp.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html"></summary></entry><entry><title type="html">Xàm xí về Domain Driven Design - Part 2</title><link href="https://romeo.vn/xam-xi-ve-ddd-part1-2/" rel="alternate" type="text/html" title="Xàm xí về Domain Driven Design - Part 2" /><published>2019-07-17T20:12:00-05:00</published><updated>2019-07-17T20:12:00-05:00</updated><id>https://romeo.vn/xam-xi-ve-ddd-part1-2</id><content type="html" xml:base="https://romeo.vn/xam-xi-ve-ddd-part1-2/">&lt;h3 id=&quot;domain-là-gì&quot;&gt;Domain là gì?&lt;/h3&gt;
&lt;p&gt;Ngày trước mình cũng lùng bùng bên tai khi nghe từ này, chẳng hiểu chính xác nó là gì. Đơn giản không thể hiểu vì bản chất từ này mang một ý nghĩa rất rộng, Domain là tất cả những gì mà một tổ chức đã, đang và sẻ làm và thế giới mà tổ chức đó thuộc về.&lt;/p&gt;

&lt;p&gt;Như chúng ta đều biết, các doanh nghiệp/tổ chức sẻ xác định thị trường và bán sản phẩm, dịch vụ của họ. Mỗi tổ chức, doanh nghiệp sẻ có các bí quyết và cách thức riêng biệt để thực hiện các thứ liên quan đến thị trường và sản phẩm dịch vụ của họ. Ví dụ như KFC sinh ra để cung cấp cho người tiêu dùng những bữa ăn nhanh, nhằm thoả mãn nhu cầu ăn uống cho những người bận rộn. Tiki hướng đến việc cung cấp một Marketplace để phục vụ người mua và người bán. Grab cung cấp một giải pháp kinh tế chia sẻ giữa tài xế, cửa hàng tiện ích, người đi mua hàng, người bán dịch vụ, người có nhu cầu đi lại….nhằm tối ưu hoá các hoạt động đi lại, mua sắm, vận chuyển….&lt;/p&gt;

&lt;p&gt;Tổng hợp của sự hiểu biết về thị trường hiểu biết về người dùng, quan hệ giữa các loại thực thể trong thế giới mà các doanh nghiệp đó muốn xây dựng nên, cộng với các phương pháp cách thức mà các doanh nghiệp đó tạo ra sản phẩm dịch vụ của họ sẻ được gói gọn bằng từ Domain.&lt;/p&gt;

&lt;h3 id=&quot;ddd-giải-quyết-những-vấn-đề-gì-tại-sao-chúng-ta-cần-ddd&quot;&gt;DDD giải quyết những vấn đề gì? Tại sao chúng ta cần DDD?&lt;/h3&gt;
&lt;p&gt;Việc phát triển một hệ thống lớn và phức tạp thật sự là một quá trình khó khăn và đôi lúc là đau đơn. Từ phía management team, development team lẫn các stackholders liên quan khác đều có các vấn đề nan giải.&lt;/p&gt;

&lt;p&gt;Đứng ở phía các manager rõ ràng tồn tại rất nhiều bài toán khó:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Vấn đề Bottleneck: Việc decouple một Team lớn không hợp lí sẻ gây ra các hệ luỵ các tình huống thắt cổ chai trong việc phân chia trách nhiệm, nhiệm vụ hay đối phó với rủi ro ở những điểm tập trung.&lt;/li&gt;
  &lt;li&gt;Tăng hiệu quả trong việc phối hợp giữa các Team: Trong quá trình phát triển một phần mềm lớn thì việc collaboration giữa các technical team, domain experts lẫn stakeholders thật sự diễn ra phức tạp, và một khi size của project tăng lên thì tính hiệu quả trong collaboration thực sự khó kiểm soát.&lt;/li&gt;
  &lt;li&gt;Quản lí risk và planning: Risk và planning thực sự là các vấn đề lớn trong việc phát triển các hệ thống lớn. Các rủi ro ở cả technical, management, internal lẫn external thực sự là ác mộng với các lãnh đạo, việc cân bằng các yếu tố urgent và important chưa bao giờ có một lời giải chính xác tuyệt đối.&lt;/li&gt;
  &lt;li&gt;Vấn đề giao tiếp giữa technical team và business team: Trong việc phát triển một hệ thống lớn, phức tạp thì việc truyền tải thông tin, yêu cầu giữa Domain Expert hay BA team đến Dev team thường có một số rào cản nhất định về ngôn ngữ, context, cũng mindset giữa các team dẫn đến một số thiếu xót về domain knowledge. BA/Domain Expert thực sự khó chịu với Technical Team khi họ không có chung một tiếng nói, BA/Domain Expert luôn dựa trên các nhìn business trong lúc Dev thì áp đặt cái nhìn technical trong quá trình tiếp cận thông tin.&lt;/li&gt;
  &lt;li&gt;Các mục tiêu business cần được deliver một cách bền vững nhưng phần mềm thì ngày một giảm đi tính maintainable do nhiều nguyên nhân mà cơ bản đầu tiên là về việc quản lí tổ chức hệ thống không thực sự tốt. Chúng ta cần xây dựng được một kiến trúc ngoài khả năng đáp ứng các yêu cầu business còn phãi đảm bảo tính mở rộng cũng như maintainable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Đứng về phía Architect hay Technical Expert cũng có những đau đớn riêng:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Bottom-up và Top-down approach: Đây là căn bệnh thường gặp trong việc phát triển các start-up, nơi mà đôi lúc Founder họ còn không biết họ đang muốn gì, họ muốn giải quyết gì cho khác hàng nhất. Việc tiếp nhận yêu cầu một cách lắc nhắc rơi vãi thay vì có một cái nhìn tổng quát trước dẫn đến nhiều sai lầm, hệ luỵ trong việc đưa ra quyết định cho các system design.&lt;/li&gt;
  &lt;li&gt;Vấn đề của kiến trúc monolith: Trong việc phát triển phần mềm chúng ta thường có thể có ý tưởng rằng nên tạo một model duy nhất, gắn kết chặt chẻ, bao gồm toàn bộ business domain của tổ chức, giống như một mô hình hoàn chỉnh của doanh nghiệp. Tuy nhiên bất kỳ nỗ lực nào để define business của một tổ chức vừa và lớn trong một model duy nhất bao gồm tất cả mọi thứ sẽ là rất khó khăn và thường sẽ thất bại vì quá rối rắm. Mình từng tham gia một dự án nhỏ gặp trường hợp đó, mọi người cố gắn tạo ra một model duy nhất bao quát từ ban đầu, mặt dù lượng logic chưa là gì so với dự án hiện tại mình tham gia tuy nhiên việc quá ôm đồm vào một model, logic chồng chéo khiến cả chục con người mô hình hoá hơn 2 tuần vẫn chưa hoàn chĩnh và có thể để lại nhiều sai lầm về sau. Việc phát triển một hệ thống monolith khổng lồ là nguyên nhân dẫn đến cơn đau đầu vô cùng nặng và dai dẳng, làm trì trệ tốc độ cũng như khó có thể linh hoạt được trong quá trình phát triển cũng như scale hệ thống.&lt;/li&gt;
  &lt;li&gt;Vấn đề coupling: Như chúng ta đều biết thì chia để trị là một nghệ thuật trong phát triển phần mềm, một hệ thống được chia thành các component thực loosely-coupled sẻ mang lại giá trị scalable cũng như maintainable cao. Tuy nhiên một hệ thống phức tạp với quá nhiều quan hệ logic phức tạp không hề dễ cho chúng ta chia. Việc thiếu kĩ luật, thiếu xót hiểu biết về các phương pháp, principle cũng như nhận thức trong quá trình phát triển dẫn đến hệ thống của chúng ta dễ có xu hương dính lại với nhau gây ra nhiều chồng chéo rối rắm về mặt kiến trúc, gây ra nhiều hệ luỵ phãi trả giá đắt đỏ. Một khi chúng vượt khỏi tầm kiểm soát thì dù tăng quy mô số lượng dev gấp mấy cũng chỉ kéo tốc độ phát triển đi xuống mà thôi.&lt;/li&gt;
  &lt;li&gt;Thiếu xót kiến thức về Domain: Dev thiếu xót domain knowledge cũng dẫn đến nhiều hệ luỵ đớn đau. Thay vì tập trung đào sâu vào domain knowledge, Dev thường bị che mắt bởi data, infrastructure,…việc thiếu domain knowledge và có quá nhiều nhiều &lt;a href=&quot;https://en.wikipedia.org/wiki/God_object&quot;&gt;God object&lt;/a&gt; thực sự là cản trở lớn cho việc chia nhỏ hệ thống, làm chúng ta không biết nên chia như thế nào.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vậy các vấn đề trên bắt nguồn từ đâu? Đó chính là sự phức tạp. Để giải quyết các vấn đề trên bắt buộc chúng ta phải liên tục giảm độ phức tạp, tăng cường đàm phán loại bỏ các yếu tố gây nên sự phức tạp dựa trên nguyên tắc 80-20 đồng thời đào sâu làm rõ kiến thức về Domain. DDD về cơ bản là một tập hợp các principles, concepts, parterns, tư tưởng, quy trình hướng đến việc thảo luận, lắng nghe, thấu hiểu và khám phá các giá trị business từ đó sẻ giúp chúng ta thoả mãn các vấn đề kể trên.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DDD yêu cầu Domain Expert/BA team làm việc với Dev team cũng như các bên liên quan khác dựa trên một tiếng nói chung(The Ubiquitous Language), khi đó việc translate requirement giữa Domain Expert/BA với các bên liên quan gần như bằng không, việc học hỏi củng cố domain knowledge sẻ dễ dàng và chính xác hơn.&lt;/li&gt;
  &lt;li&gt;DDD cung cấp cho chúng ta cả strategic lẫn tactical để mô model hoá phần mềm: Boundex context cho chúng ta một modeling boundary mà trong đó chúng ta sẻ tạo ra một solution cho một business problem cụ thể. Trong mỗi một Bounded Context là Ubiquitous Language được xây dựng bởi team, Ubiquitous Language được dùng cho giao tiếp trong Team. Mỗi team khác nhau đôi khi sẻ chịu trách nhiệm cho các Bounded Context khác nhau, DDD sẻ cung cấp một công cụ gọi là Context Map, sử dụng Context Map để phân tách các Bounded Context một cách có chủ đích có chiến lượt đồng thời hiểu các mối quan hệ giữa các Bounded Context và integrate giữa chúng. Trong mỗi Bounded Context chúng ta có thẻ sử dụng tactical, building block partern để model như Aggregates, Entities, Value Objects, Services, Domain Events, từ đó chúng ta có được một kiến trúc đảm bảo tính mở rộng cũng như maintainable.&lt;/li&gt;
  &lt;li&gt;Các Bounded Context được tổ chức một cách rõ ràng và các context map tổ chức tốt cũng như domain knowledge được cũng cố vững chắc sẻ giúp chúng ta tránh được sự bội thực về mặt ngữ nghĩa giữa các thuật ngữ, khái niệm, đối tượng. Các concepts sẻ được chia nhỏ, đổi tên, custom sao cho hợp lí sẻ giúp chúng ta tránh được việc đưa ra các God object. Đảm bảo hệ thống sẻ được chia nhỏ thành các phần đơn giản hơn đi theo các nguyên tắc Isolation, Low coupling, Comprehensibility, High cohesion, Parallelisation/Autonomy, do đó engineer team dễ dàng đáp ứng các yêu cầu logic lúc design ban đầu, logic ít chồng chéo đỡ nặng đầu hơn cũng như tổ chức code tốt hơn, có tầm nhìn tốt về hướng phát triển code base để dễ bảo trì, thay thế, bổ sung cũng như improve về sau. Các manager cũng dễ dàng quản lí phân công trách nhiệm cũng như đánh độ ưu tiên, đưa ra quyết định.&lt;/li&gt;
  &lt;li&gt;Việc các phần được chia ra đạt được tính Isolation, Parallelisation/Autonomy sẻ giúp chúng ta tăng tốc độ phát triển một cách tối đa nhất, loại bỏ tối đa các dấu hiệu quản lí tập trung, các dependencies trong dự án rõ ràng và dễ kiểm soát hơn giúp chúng ta tránh được các vấn đề coupling và bottlenecks trong development cũng như management. Microservice approach cũng chỉ là một cách tiếp cận trên con đường DDD mà thôi.&lt;/li&gt;
  &lt;li&gt;Về trãi nghiệm cá nhân, nếu có kiến thức về DDD sớm hơn và tốt hơn thì có thể các sai lầm về design trong các dự án đã phần nào tránh được, các approach như microservices, event sourcing, reactive system sẻ được nhìn nhận đúng đắn hơn đồng thời xử lí các business logic rối rắm phức tạp, các vấn đề scale, concurrency, consistency…đã được giải quyết một cách đơn giản, hiệu quả hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-is-the-ubiquitous-language&quot;&gt;What is the Ubiquitous Language?&lt;/h3&gt;
&lt;p&gt;Để có thể phát triển một phần mềm cho một Domain cụ thể ít nhất chúng ta cần một cách mô tả Domain này. Viêc chỉ có một relational data model truyền thống hay thứ gì đó tương tự thực sự là không đủ. Chúng ta cần có khả năng mô tả không chỉ các đối tượng và mối quan hệ của chúng mà phãi mô tả những thứ khác linh động hơn như events, event flow, processes, business invariants, cách mà các đối tượng thay đổi theo thời gian… Chúng ta cần có thể thảo luận và phản biện về Domain với cả các developer lẫn các domain expert/BA. Những gì mà chúng ta cần đó được là Ubiquitous Language.&lt;/p&gt;

&lt;p&gt;Ubiquitous Language là một ngôn ngữ thống nhất được cả Domain Expert và Developers sử dụng để mô tả và thảo luận về Domain. Ngoài code ra thì Ubiquitous Language là trọng nhất của Domain Driven Design proccess. Chúng ta có thể document lại Ubiquitous Language theo nhiều cách khác nhau, ban đầu là phãi tạo ra các thuật ngữ thống nhất giữa developer mà domain expert. Các Business Logic, relationship có thể được mô tả bằng các domain specific languages, diagrams and flow charts, UML, Finite state machine, Data Flow, Event Storming….Đôi lúc có một số nhu cầu nhỏ, nhanh gọn chúng ta có thể sử dụng các domain specific languages build sẳn, cá nhân bản thân mình thấy đối với một team nhỏ tầm 6-9 người thì một Domain Specific Language như DSL của &lt;a href=&quot;https://goa.design/extend/dsls/&quot;&gt;GOA&lt;/a&gt; thì cũng đủ sài cho các bên liên quan.&lt;/p&gt;

&lt;h3 id=&quot;bức-tranh-tổng-quát-về-ddd&quot;&gt;Bức tranh tổng quát về DDD:&lt;/h3&gt;
&lt;p&gt;Về DDD mình chủ yếu tập trung vào ba mục chính:&lt;/p&gt;

&lt;h4 id=&quot;1-strategic-modeling&quot;&gt;1. Strategic Modeling:&lt;/h4&gt;

&lt;p&gt;Thiết kế các Enterprise Software cần được thực hiện một cách khôn ngoan và hợp lí, Strategic Modeling là tập hợp các cách tiếp cận nhằm giúp chúng ta mô hình hoá một hệ thống cho phép chúng ta có khả năng chia để trị domain lớn, lập kế hoạch cho tương lai cũng như đưa ra quyết định phù hợp với sứ mệnh và giá trị cốt lõi của domain mà chúng ta muốn làm.&lt;/p&gt;

&lt;p&gt;Strategic Modeling tập trung vào việc define cũng như sử dụng các Bounded Context, SubDomain, quản lí ngữ nghĩa của các concepts giữa các context khác nhau… đồng thời rất hữu ích để trong việc cung cấp các khía cạnh phản biện, tranh luận để tìm ra một strategic architecture tốt phù hợp với domain chúng ta hướng tới.&lt;/p&gt;

&lt;p&gt;Việc có một bản Context Map và các khái niệm cốt lõi chung giúp chúng ta dễ dàng improve bức tranh tổng quan của toàn hệ thống. Đặc biệt đối với Microservices approach, Strategic Modeling giúp chúng ta define và kết nối các service một cách đúng đắn tuân theo nguyên tắc low coupling, high cohesion bằng cách xác định các Bounded Context, Subdomain một cách phù hợp.&lt;/p&gt;

&lt;h4 id=&quot;2-tactical-modeling&quot;&gt;2. Tactical Modeling:&lt;/h4&gt;

&lt;p&gt;Đây sẻ là cách mà chúng ta mô hình hoá một cách có đường hướng chiến thuật trong các Bounded Context bằng cách sử dụng các building block partern của DDD như Aggregate, Repository, Factory, Services, Domain Event và các khái niệm liên quan như Entity, Value Objects,… để design các module một cách đúng đắn nhất&lt;/p&gt;

&lt;h4 id=&quot;3-các-parterns-architectures&quot;&gt;3. Các parterns, architectures:&lt;/h4&gt;

&lt;p&gt;Có chiến thuật, có model rồi, chúng ta cần nhạy bén tuỳ vào các yêu cầu mục đích cụ thể mà chọn các mẫu architecture phù hợp ví dụ như Clean Architecture, CQRS/Event Sourcing,… sao cho vừa thoả mãn business đồng thời dễ dàng mở rộng thêm tính năng cũng như tối thiểu hoá chi phí maintain.&lt;/p&gt;

&lt;p&gt;Tóm lại, bài viết ngắn này cá nhân mình đã trả lời một số băng khoăn:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Domain Driven Design là gì?&lt;/li&gt;
  &lt;li&gt;Domain là gì? Ubiquitous Language là gì?&lt;/li&gt;
  &lt;li&gt;Các vấn đề mà Domain Driven Design sẻ giúp chúng ta giải quyết?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nếu có bất cứ thiếu xót nào mong các bạn góp ý bổ sung.&lt;/p&gt;

&lt;p&gt;Bài tiếp Theo mình sẻ nói về chủ đề Strategic Modeling.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="ddd" /><category term="domain-driven-design" /><category term="domain-driven-development" /><category term="microservice" /><summary type="html">Domain là gì? Ngày trước mình cũng lùng bùng bên tai khi nghe từ này, chẳng hiểu chính xác nó là gì. Đơn giản không thể hiểu vì bản chất từ này mang một ý nghĩa rất rộng, Domain là tất cả những gì mà một tổ chức đã, đang và sẻ làm và thế giới mà tổ chức đó thuộc về.</summary></entry><entry><title type="html">Kafka note</title><link href="https://romeo.vn/kafka-note/" rel="alternate" type="text/html" title="Kafka note" /><published>2018-09-16T21:10:00-05:00</published><updated>2018-09-16T21:10:00-05:00</updated><id>https://romeo.vn/kafka-note</id><content type="html" xml:base="https://romeo.vn/kafka-note/">&lt;h2 id=&quot;why-kafka&quot;&gt;Why Kafka?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Dùng làm message queue&lt;/li&gt;
  &lt;li&gt;Là công cụ thiết yếu cho việc Decoupling và Integrating&lt;/li&gt;
  &lt;li&gt;Là công cụ cực kì mạnh mẻ cho Data Streaming, xử lí data realtime&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dùng-làm-message-queue&quot;&gt;Dùng làm message queue&lt;/h3&gt;
&lt;p&gt;Chúng ta bắt đầu bằng việc có một bài toán như sau: Nếu có 1 triệu người đặt hàng trên trang web của bạn cùng lúc nó có thể tạo ra một số vấn đề concurrency và việc đảm bảo việc sử lí các yêu cầu theo thứ tự ngay lập tức chúng ta nghĩ đến việc xếp các order vào một message queue để có thể đảm bảo thứ tự của chúng và kiểm soát được số lượng được xử lí đồng thời đó, Kafka với một kiến trúc scalability là một trong những lựa chọn tốt giúp chúng ta xử lí được bài toán trên.&lt;/p&gt;

&lt;h3 id=&quot;là-công-cụ-thiết-yếu-cho-việc-decoupling-và-integrating&quot;&gt;Là công cụ thiết yếu cho việc Decoupling và Integrating&lt;/h3&gt;
&lt;p&gt;Khi làm việc với các hệ thống phức tạp chúng ta bắt buộc phãi thiết kế thành một hệ thống low coupling, High cohesion. Kafka là công cụ cực kì mạnh mẻ cho việc decoupling hệ thống cho phép chúng ta phân tách các thành phần của hệ thống thành các thành phần độc lập, low coupling. Trong một hệ thống lớn chúng ta thường sử dụng nhiều ngôn ngữ, công nghệ khác nhau tuỳ thuộc vào mục đích từng thành phần, hơn nữa việc duy trì dependencies cứng nhắc giữa các thành phần đôi lúc không cần thiết. Bằng cách giao tiếp thông qua kafka giữa các services với các format hợp lí và khớp lệ bạn có có thể tách biệt được dependencies giữa các service, mỗi thành phần của hệ thống đều có thể phát triển, mở rộng một cách độc lập.&lt;/p&gt;

&lt;p&gt;Đặc biệt đối với Microservice Approach, chúng ta thường đối mặt với các vấn đề liên quan đến internal communication và xử lí lỗi trong communication giữa các services. Những dạng giao tiếp thường thấy có thể là call trực tiếp(thông qua http rest/gRPC/thrift….), giao tiếp thông qua việc sử dụng asynchronous messaging, và có thể cao hơn đó là dùng các giao thức đặc biệt dành riêng cho hệ thống. Tuy nhiên đối với các hệ thống phãi xử lí một lượng lớn request trên kiến trúc microservice cũng như kiến trúc monolic truyền thống thì những lỗi như lỗi mạng, timeout, lỗi do bug….là điều không thể tránh khỏi. Message Streaming nói chung và kafka nói riêng giúp hệ thống của chúng ta xử lí các lỗi trên một cách hiệu quả bằng cách lưu lại trạng thái các request lúc nào xử lí xong mới xoá request đó đi bất cứ lỗi nào xãy ra thì chúng ta đều có thể xử lí lại request đó.&lt;/p&gt;

&lt;h3 id=&quot;đối-với-mô-hình-event-driven&quot;&gt;Đối với mô hình Event Driven:&lt;/h3&gt;
&lt;p&gt;Các ngôn ngữ lập trình truyền thống thường dựa trên thread và threadpools để xử lí các tác vụ đồng thời đơn cử như là Java theo mặc định mỗi thread thường chiếm 1MB trong stack size(trên JVM 64bit) và chúng ta có thể config stack size tuỳ ý. Việc cấp phát một thread thường khá đắt đỏ trong CPU cho nên chúng ta thường sẻ phãi config size của threadpools trước, mỗi khi có request tới, web server sẻ pick một thread trong threadpools và kêu nó xử lí reuqest, các thread trên sẻ xử lí các tác vụ một cách song song. Nếu bạn giữ các giá trị như mặc định thì nếu config 1k thread trong thread pool đồng nghĩa với việc bạn sẻ dùng hết gần 1G Ram.&lt;/p&gt;

&lt;p&gt;Đối với hệ thống lớn chúng ta sẻ gặp phãi hai vấn đề về thread đó là stack size và threadpools size. Nếu config stack size mỗi thread nhỏ xuống thì sẻ tiết kiệm được nhiều bộ nhớ nhưng khi một thread nào đó đòi hỏi tính toán nhiều thì dễ gây ra stack overflow. Cũng như vậy đối với threadpools size, khi chúng ta giữ một lượng lớn thread trong threadpool thì memory cost và switching context cost sẻ là rất cao và hệ thống sẻ trở nên khó kiểm soát, ngược lại khi giữ một số lượng thread nhỏ hơn thì lại làm giảm tính available của hệ thống.&lt;/p&gt;

&lt;p&gt;Nếu hệ thống chúng ta có các tác vụ tính toán mất thời gian, tốn tài nguyên, khó thể ước tính thời gian và tài nguyên cho mỗi yêu cầu nhưng lại không nhất thiết phãi response ngay lập tức thì chúng ta có thể sử dụng mô hình trên. Khi thiết kế hệ thống dựa trên mô hình Event Driven thì Kafka là một lựa chọn khá tốt để xử lí các event. Bạn có thể sử dụng kafka để lưu trử các request message và các worker xử lí request sau đó.&lt;/p&gt;

&lt;h3 id=&quot;đối-với-stream-proccessing-data-realtime&quot;&gt;Đối với Stream Proccessing data realtime.&lt;/h3&gt;
&lt;p&gt;Trong một hệ thống lớn với lượng Data khổng lồ thì việc xử lí một lượng lớn Data như vậy bằng Batch Proccessing là điều rất tốn thời gian cũng như tài nguyên. Có những yêu cầu về việc phân tích Data Realtime, đưa ra report gần như chính xác tại mỗi thời điểm,…lúc đó những Message Stream như Kafka là giải pháp thực sự tốt.&lt;/p&gt;

&lt;h2 id=&quot;kiến-trúc-kafka&quot;&gt;Kiến trúc kafka:&lt;/h2&gt;
&lt;p&gt;Cơ chế hoạt động cơ bản của Kafka hình dung đơn giản giống như Logs system, các log record được lưu lên đĩa và sắp xếp theo thứ tự thời gian, Kafka tổ chức phân loại các messages theo khái niệm Topic hình dung giống như tag trong việc quản lí Log của chúng ta. Mỗi khi cài đặt kafka một trong những việc ta cần làm là setup nơi mà log sẻ được lưu xuống-url của log.dir, mỗi topic sẻ được map với thư mục con bên trong thư mục log của chúng ta và cũng có thêm nhiều thư mục con nữa đó là các thư mục topic partitions với tên thư mục format là topic-name_partition-number, bên trong mỗi thư mục sẻ là file log nơi mà message tới sẻ được append vào. Mỗi Topic có một nhiều Partitions và mỗi Partition là một list các messages, khi một message được chia sẻ lên Kafka theo Topic, message sẻ được gửi vào một Partition của Topic, việc lưu message xuống Partition nào được quyết định bởi các producers. Nếu ta muốn message xuống Partition cụ thể nào đó thì ta phãi set partition_key cho message đó ứng với Partition ta muốn message xuống, nếu không mặc định message sẻ được phân phối theo giải thuật round-robin.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicA_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Như trên chúng ta có thể thấy rằng topic A có 1 partition, topic B có 2 partitions và C có 3 partitions. Vậy partition đó là gì, dùng để làm gì? Partitions là một phần quan trọng trong thiết kế của kafka. Các partitions chia luồng message đến một topic vào các luồng song song và đó là chìa khoá giúp Kafka achieves một lượng message khổng lồ. Tuy nhiên thứ tự message đến từ các partitions khác nhau không được đảm bảo, Kafka chỉ đảm bảo thứ tự message trong cùng một partition, do đó trong trường hợp chúng ta cần đảm bảo thứ tự message cho nhiều tác vụ nào đó, chắc chắn các message xử lí các tác vụ đó phãi được sắp xếp vào cùng 1 topic và cùng một partion_key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mỗi Partition có thể được phân tán trên nhiều máy và mỗi máy như thế được gọi là một Broker, mỗi Broker có thể có 0 1 hoặc nhiều Partitions của cùng 1 Topic hoặc thậm chí các topic khác nhau.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka hổ trợ Replication để đảm bảo tính high-availability và tính fault-tolerance. Mỗi partition có thể có nhiều bản replicas tuỳ thuộc vào số replication factor mà ta config.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ có các leader partitions mới được cho phép nhận message sau đo mới đồng bộ lên các replicas partitions khác và khi một leader partition chết thì một trong những replica của partition được chọn để làm leader partition cho đến khi partition kia sống lại thì nó trở thành replica và phãi fetch lại tất cả data chưa đồng bộ được trong quá trình chết đi từ các partition khác. Kafka dùng ZOOKEEPER để handle chuyện đó, Kafka dùng nó để thực hiện việc leadership electron các kafka broker và các cặp Topic Partition, ZOOKEEPER giúp quản lí việc Service Discovery cho các Kafka Brokers từ các cluster, handle các trường hợp broker nào join vào, broker nào chết đi, topic nào được add vào topic nào bị remove đi….
Rõ ràng kafka thoã mãn hai đặc điểm đó là High-availability và Durability.&lt;/p&gt;

&lt;p&gt;Cách hoạt động của Kafka producers khá đơn giản, ban đầu các producers phãi fetch các metadata lên ví dụ như chúng cần biết có các topics nào đang tồn tại? có bao nhiêu partition mỗi topic đang có? leader broker hiện tại của mỗi partition là node nào? host và port của mỗi broker đó là sao? Sau đó chúng làm việc trực tiếp với các broker khác nhau mà không có một sự điều phối nào.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế đó kafka producers đã loại bỏ triệt để vấn đề write-bottleneck, đồng thời giúp cho mỗi broker nhận được một số lượng messages hợp lí, dễ dàng mở rộng tuyến tính, khi muốn mở rộng chỉ cần thêm partition và broker vào.&lt;/p&gt;

&lt;p&gt;Như vậy nhìn chung thì Kafka producers tương đối đơn giản tuy nhiên đối với Kafka consumers thì phức tạp hơn nhiều. Cũng giống như Kafka producer, Kafka consumers bắt đầu các hoạt động của chúng bằng việc fetch các metadata, mỗi consumer có thể kết nối tới nhiều brokers và đọc từ nhiều replicas. Mỗi broker xử lí một tập hợp các partition của các topics mà consumer subsribe tới cùng lúc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nhờ thiết kế đó mà workload giữa các broker được cân bằng đồng thời giảm thiểu vấn đề read-bottleneck. Hơn nữa mỗi consumer có nhiều replicas để đọc giúp tăng tính availability và cân bằng workload giữa các consumer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ với thiết kế đó thì vẫn chưa đảm bảo tính scale, khái niệm consumer group sinh ra giúp chúng ta dễ dàng scale các consumers. Theo đó mỗi consumer sẻ thuộc về một consumer group hay nói cách khác một consumer group sẻ chứa các consumer và message sẻ được phân phát đến tất cả consumer group, mỗi member của group sẻ xử lí message từ một hoặc nhiều partitions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế này, mỗi consumer có thể xử lí message từ nhiều partitions, đảm bảo cover hết tất cả các partition cũng như thứ tự xử lí message trong mỗi partition đồng thời cân bằng tải giữa các consumers trong cùng một group. Khi chúng ta muốn scale lên chỉ cần tăng số brokers, tăng số partitions và tăng số consumers. Nhìn lại một lần nữa vào ví dụ trên, chúng ta có thể thấy rằng thiết kế trên cho phép mỗi consumer có thể xử lí nhiều partitions cùng lúc chứ không cho phép nhiều consumers cùng lúc xử lí một partition cho nên giả dụ như chúng ta có 5 partitions nhưng có đến 6 cunsumers thì hiển nhiên 1 consumer ngồi chơi làm phí phạm tài nguyên hệ thống, cho nên khi scale thì nên lưu ý rằng số consumers luôn bé hơn hoặc bằng số partitions mà tốt nhất là bằng nhau thì hơn.&lt;/p&gt;

&lt;p&gt;Updating….&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="kafka" /><category term="event-driven" /><category term="microservice" /><summary type="html">Why Kafka? Dùng làm message queue Là công cụ thiết yếu cho việc Decoupling và Integrating Là công cụ cực kì mạnh mẻ cho Data Streaming, xử lí data realtime</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/2018-07-16-nhung-van-de-kafka-giai-quyet/1.png" /></entry><entry><title type="html">Introduce To GoKit</title><link href="https://romeo.vn/introduce-gokit/" rel="alternate" type="text/html" title="Introduce To GoKit" /><published>2018-08-06T20:15:00-05:00</published><updated>2018-08-06T20:15:00-05:00</updated><id>https://romeo.vn/introduce-gokit</id><content type="html" xml:base="https://romeo.vn/introduce-gokit/">&lt;p&gt;Golang là ngôn ngữ tuyệt vời cho Microservices về hiệu xuất lẫn sự thân thiện đối với developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất có ích và làm cho việc phát triển phần mềm với Go trở nên dễ dàng hơn. Gokit là một bộ toolkit tuyệt vời cho việc xây dựng các microservices với Go, cung cấp cho chúng ta các quy tắc, ý tưởng về kiến trúc nhằm giúp developer tập trung hơn vào việc phát triển business logic và tránh khỏi các mối quan tâm chung về operational lẫn infrastructural.&lt;/p&gt;

&lt;p&gt;Gokit là bộ toolkit nhẹ nhàng nhưng cung cấp gần như đầy đủ các thư viện đồ chơi cho một hệ thống service mesh, từ Logging, Metrics, Tracing, Rate-Limiting, Circuit Breaking cho đến Service Discovery, Pub/Sub…&lt;/p&gt;

&lt;p&gt;Tuy ban đầu được giới thiệu là dùng cho việc build các microservices nhưng trong qúa trình làm việc mình thấy Gokit dường như phù hợp với monolith không kém. Với Gokit, developer cần tuân theo một số nguyên tắc sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Phãi nắm bắt và tuân thủ các nguyên tắc thiết kế như SOLID, DDD, Clean Architecture và áp dụng chặt chẻ.&lt;/li&gt;
  &lt;li&gt;Các interfaces được sử dụng như là các quy ước, không có global state, declarative composition và các Dependencies phãi rõ ràng.&lt;/li&gt;
  &lt;li&gt;Áp dụng nguyên tắc Composition over inheritance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kiến-trúc-của-gokit&quot;&gt;Kiến trúc của Gokit:&lt;/h3&gt;
&lt;p&gt;Gokit được chia làm ba layer chính đó là&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Transport layer&lt;/li&gt;
  &lt;li&gt;Endpoint layer&lt;/li&gt;
  &lt;li&gt;Service layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tầng Service là tầng quan trọng nhất, nơi mà developer quan tâm nhất, là nơi chứa các domain của ứng dụng cũng như implementation của tất cả business logic cho ứng dụng, nó tách biệt hoàn toàn với các phần còn lại. Hai tầng Transport và Endpoint nằm ở tầng Interface của Clean Architect như bài trước mình đã giới thiệu về Clean Architecture https://romeo.vn/clean-architecture/. Tầng transaport được liên kết với các giao thức cụ thể như Http, gRPC, Pub/Sub nhằm lấy request từ client và encoding/decoding request. Trong Gokit, RPC là giao thức chính được ưu tiên nhất, mỗi service method trong Gokit sẻ được chuyển đổi thành một endpoint để giao tiếp giữa client và server. Mỗi endpoint sẻ expose một service method ra ngoài bằng cách sử dụng Transport liên kết với một giao thức Transport cụ thể như Http Rest/gRPC hay Pub/Sub.&lt;/p&gt;

&lt;p&gt;Một thành phần khác không kém phần quan trọng trong Gokit đó là các &lt;strong&gt;Middlewares&lt;/strong&gt;. Gokit thực hiện nghiêm ngặt việc separate các concerns, các &lt;strong&gt;cross-cutting concern components&lt;/strong&gt; của tầng services và endpoints được implement bằng việc sử dụng các Middlewares. Middleware là một thành phần mạnh mẻ nhằm bọc các services và endpoints lại để thêm các các &lt;strong&gt;cross-cutting concern components&lt;/strong&gt; như Logging, Circuit Breakers, Rate Limiting, Load Balancing, hay Distributed tracing…&lt;/p&gt;

&lt;p&gt;Dưới đây là một hình ảnh mô tả kiến trúc của Gokit mình copy từ trang web chính thức của Gokit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gokit.io/faq/onion.png&quot; alt=&quot;Atom&quot; /&gt;&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="golang" /><category term="gokit" /><category term="microservices" /><summary type="html">Golang là ngôn ngữ tuyệt vời cho Microservices về hiệu xuất lẫn sự thân thiện đối với developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất có ích và làm cho việc phát triển phần mềm với Go trở nên dễ dàng hơn. Gokit là một bộ toolkit tuyệt vời cho việc xây dựng các microservices với Go, cung cấp cho chúng ta các quy tắc, ý tưởng về kiến trúc nhằm giúp developer tập trung hơn vào việc phát triển business logic và tránh khỏi các mối quan tâm chung về operational lẫn infrastructural.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Introduce ToClean Architecture</title><link href="https://romeo.vn/clean-architecture/" rel="alternate" type="text/html" title=" Introduce ToClean Architecture" /><published>2018-07-20T09:01:00-05:00</published><updated>2018-07-20T09:01:00-05:00</updated><id>https://romeo.vn/clean-architecture</id><content type="html" xml:base="https://romeo.vn/clean-architecture/">&lt;p&gt;Trong bài viết này chúng ta sẻ cùng thảo luận về một loạt các patterns, principles, paradigms nhằm tạo ra một kiến trúc tốt hơn nhằm thay thế cho các approaches không thực sự còn hợp thời nữa, đặc biệt là các concepts trong Clean Architecture. Bài viết này mình sẻ thảo luận về một số mục chính sau:&lt;/p&gt;

&lt;p&gt;I. Software Architecture là gì? Tại sao chúng ta cần tìm hiểu chúng?&lt;/p&gt;

&lt;p&gt;II. Những gì cấu nên Software Architecture&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Các promgramming paradigms&lt;/li&gt;
  &lt;li&gt;Các design principles&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;III. Một architecture tốt sẻ trông như thế nào?&lt;/p&gt;

&lt;p&gt;IV. Clean Architecture&lt;/p&gt;

&lt;p&gt;Trước khi bắt đầu thảo luận về các mục chính, mình xin chia sẻ một chút về quá trình tiếp xúc với các mẫu kiến trúc của mình.&lt;/p&gt;

&lt;p&gt;Điểm xuất phát của mình dường như nó không đi theo con đường “chính đạo” như các bạn các anh chị đi trước. Đa số các tiền bối đi trước thường xuất phát với Java, C#, Scala,…. Việc xuất phát với các ngôn ngữ framework dựa trên các ngôn ngữ đó phần nào mang lại lợi ích nhất đích định dựa vào sự trưởng thành của ecosystem ứng với ngôn ngữ đó, dựa vào cộng đồng lớn cùng với các kiến thức cực kì cần thiết trong OOP cũng như Design parterns, do đó mang lại cái nhìn sớm hơn, đúng đắn và đầy đủ hơn về architecture cũng như system design.&lt;/p&gt;

&lt;p&gt;Mình thì ngược lại, mình bắt đầu sự nghiệp coder với một dự án startup với công nghệ chính là Node.js, code không theo một paradigm cụ thể nào cả, OOP cũng không hẳn là OOP, Functional cũng không hẳn là Functional, Functional Reactive cũng không ra Functional Reactive, qua một thời gian thì mọi thứ gần như out of control và không có cơ hội cứu chữa trừ khi đập đi làm lại. Và thực tế là dự án đó đã đập đi làm lại rất nhiều lần tuy nhiên không có một kiến trúc vững trãi thì sau một thời gian lại đâu vào đấy, out of control.&lt;/p&gt;

&lt;p&gt;Sau một thời gian dài code quán tính thì không những không xây dựng được tư duy kiến trúc, tư duy tổ chức và làm mình khó nhồi nhét tư duy design sau này. Thật may lúc đó mình có cơ hội cho công việc mới dù kết thúc sớm vì một số lí do nhưng nhờ chính cơ hội đó đã mở ra cho mình một số kiến thức hay ho, mang lại lợi ích to lớn sau này.&lt;/p&gt;

&lt;p&gt;Yêu cầu công việc của mình thời điểm đó là tìm hiểu và áp dụng Clean Architecture vào dự án với Golang với một tài liệu duy nhất là bài viết này &lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;The Clean Architecture&lt;/a&gt;. Một task với description cực kì ngắn gọn nhưng không hề đơn giản tí nào cho một con gà tại thời điểm đó. Với tư duy tổ chức kém, hỏng kiến thức về OOP lẫn design partern thì quả thực Clean Architecture là một thứ gì đó quá xa vời.&lt;/p&gt;

&lt;p&gt;Clean Architecture yêu cầu phãi xâu chuổi tất cả kiến thức tổ chức code, từ sự hiểu biết và kinh nghiệ về các Programming paradigms, các Design Parterns ở OOP cũng như ở các paradigms khác, tiếp đến mới là các Design Principles như SOLID Principles, Component Principles rồi mới đến các nguyên tắc, các mẫu kiến trúc cho phần mềm. Thực tế thì không chỉ là Clean Architecture mà tất cả các kiến trúc khác đều dựa trên những nguyên tắc chung đó mà xây dựng nên.&lt;/p&gt;

&lt;p&gt;Sau một thời gian với nhiều may mắn được làm việc với các dự án từ Golang đến Typescript mình tóm tắt lại quá trình mình tiếp cận với Clean Architecture nói riêng và các quy tắc lập trình, tổ chức code nói chung cũng và cũng là dịp để mình ôn lại kiến thức, kĩ năng lẫn thói quen nhằm ghi nhớ sâu hơn hoặc ai đó đang tìm hiểu hoặc đang implement Clean Architecture vô tình đọc bài này có thể cảm nhận và phản biện giúp mình cũng cố kiến thức hơn.&lt;/p&gt;

&lt;h3 id=&quot;i-software-architecture-là-gì-tại-sao-chúng-ta-phãi-tìm-hiểu-chúng&quot;&gt;I. SOFTWARE ARCHITECTURE LÀ GÌ? TẠI SAO CHÚNG TA PHÃI TÌM HIỂU CHÚNG?&lt;/h3&gt;
&lt;p&gt;Như chúng ta đều biết thì với yêu cầu của việc phát triển phần mềm thì việc phát triển đội ngủ về số lượng luôn là điều hiển nhiên. Tuy nhiên sự phát triển của số lượng chưa hẳn sẻ kéo theo sự phát triển chất lượng và tốc độ phát triển phần mềm.&lt;/p&gt;

&lt;p&gt;Một sự thật đớn đau là theo các con số thống kê, đa số phần mềm khi phát đến một mức nào đó thì cho dù tăng thêm số lượng engineer đến bao nhiêu cũng không thể kéo tốc độ cũng như chất lượng lên được nữa, cũng có thể là tốc độ và chất lượng lại đi xuống. Tức nhiên là chẳng ai muốn điều đó xãy ra, ai cũng luôn luôn cố gắn phát triển cả. Nhưng với việc tổ chức kém code base ban đầu, việc out of control chất lượng code, độ phình to của software mà không có một chiến lược tái cấu trúc hợp lí….tất cả các nguyên nhân đó tạo ra một đống hổn độn mà không một cá nhân nào trong đó không muốn “đập đi làm lại cmn đi”.&lt;/p&gt;

&lt;p&gt;Các Software Architecture sinh ra để giải quyết bài toán đầu tiên về tổ chức cũng như độ dễ của việc duy trì một code base sạch sẻ gọn gàn, nhằm giảm tối đa resource để xây dựng phát triển cũng như maintain đồng thời tăng khả năng mở rộng về mặt hệ thống lẫn số lượng engineer.&lt;/p&gt;

&lt;h3 id=&quot;ii-các-programming-paradigms&quot;&gt;II. CÁC PROGRAMMING PARADIGMS:&lt;/h3&gt;

&lt;p&gt;Như chúng ta đều biết thì các Architectures đều bắt đầu từ code, do đó các Paradigms sẻ cho chúng ta biết cách tổ chức nào sẻ được sử dụng. Đến nay thì mình chỉ mới tiếp cận được 3 Programming Paradigms nên có thể nêu lên quan điểm cá nhân của mình như sau:&lt;/p&gt;

&lt;h4 id=&quot;1object-oriented-programmingoop&quot;&gt;1.Object Oriented Programming(OOP):&lt;/h4&gt;

&lt;p&gt;Đây dường như đây là Paradigm thịnh hành nhất hiện tại với các ưu điểm đáng kể.&lt;/p&gt;

&lt;p&gt;Việc hiểu rõ các tính chất cũng như các nguyên tắc design trong OOP giúp chúng ta dễ tổ chức, phát triển và maintain, dễ module hoá, tính reusable cao và cũng như cho phép chúng ta dễ dàng phát triển các module một cách song song.&lt;/p&gt;

&lt;p&gt;Tuy nhiên OOP cũng có nhiều hạn chế. Về coding style, OOP nhìn chung là quá imperative, tập trung trả lời câu hỏi “How?”(làm sao để làm điều đó) hơn là câu hỏi “What?”(chúng ta muốn gì ở đây), khi đọc code chúng ta khó nhanh chóng hiểu được người viết muốn gì.&lt;/p&gt;

&lt;p&gt;Nhược điểm thứ hai đó là về vấn đề race condition, trong concurrent programming đây là vấn đề thường gặp và rất tốn công giải quyết, việc chia sẻ trạng thái trong lập trình hướng đối tượng là một trong các nguyên nhân chủ yếu dẫn đến race condition và khiến ta khó debug cũng như fix bug.&lt;/p&gt;

&lt;h4 id=&quot;2functional-programmingfp&quot;&gt;2.Functional Programming(FP):&lt;/h4&gt;
&lt;p&gt;Những năm gần đây FP nổi lên như một xu hướng mà các lập trình viên đang theo đuổi và dần chuyển đổi, không chỉ mang lại những trải nghiệm mới mà FP xử lí một số vấn đề hạn chế của OOP.&lt;/p&gt;

&lt;p&gt;Về coding style nhìn chung FP theo trường phái declarative, tập trung trả lời câu hỏi “What?”(chúng ta muốn gì), giúp chúng ta nhanh chóng hiểu code trong lúc maintain, fix bug.&lt;/p&gt;

&lt;p&gt;Việc sử dụng các pure functions mang lại cho chúng ta các functions đáng tin cậy hơn, hạn chế tối đa side effect có thể xãy ra do đó các hàm luôn luôn chỉ trả đúng kết quả mà chúng ta mong đợi.&lt;/p&gt;

&lt;p&gt;Về mặt Architecture, tính IMMUTABILITY là tính chất rất quan trọng mà chúng ta cần xem xét. Đứng ở vị trí là một Backend Engineer ngoài các vấn đề thuật toán, design hay architectures thì các engineer thường coi trọng nhất các vấn đề về concurency như race condition, deadlock conditions và concurrent update. Tất cả chúng sinh ra do đâu? chỉ có thể là do tính mutable của biến.&lt;/p&gt;

&lt;p&gt;Chúng ta sẻ không dính bất cứ race condition hoặc concurrent update nào khi không có một biến/shared memory nào được cập nhật. Chúng ta sẻ không dính bất cứ deadlocks nào nếu không có mutable locks. Hay nói cách khác tất cả vấn đề concurrency, tất cả vấn đề chúng ta đối mặt trong hệ thống multiple threads/multiple processors sẻ không bao giờ xãy ra nếu không có bất cứ mutable variables nào.&lt;/p&gt;

&lt;p&gt;Ở vị trí Backend Enginner chúng ta luôn muốn thiết kế một hệ thống mạnh mẻ với sự có mặt của multi threads multi processors sau đó câu hỏi mà chúng ta tự hỏi chính mình đó là tính immutability có luôn được thực hiện được hay không? Câu trả lời tức nhiên sẻ là không rồi, tuy nhiên chúng ta sẻ có những kĩ thuật nhằm phân tích các thành phần mutable và các thành phần immutable sau đó tách biệt chúng ra. Các thành phần immutable bắt buộc chúng ta phãi implement một cách purely functional và các thành phần mutable bắt buộc chúng ta phãi cân nhắc sử dụng một số loại transaction memory để tránh khỏi vấn đề concurrent updates và race conditions.&lt;/p&gt;

&lt;p&gt;Tuy nhiên nó vẫn chưa được bảo vệ hoàn toàn khỏi vấn đề concurrent updates và deadlocks khi có quá nhiều biến phụ thuộc xuất hiện, khi đó chúng ta lại phãi cân nhắc tách và chuyển các thành phần mutable thành các thành phần immutable nhiều nhất có thể và tập trung đẩy càng nhiều tài nguyên nhất có thể vào các thành phần immutable. Ngoài ra việc thay đổi, tận dụng sức mạnh xử lí của hệ thống máy tính hiện đại kết hợp cùng các kĩ thuật xử lí theo event, cron job,…. có thể giúp chúng ta giải quyết phần nào hiệu quả các vấn đề trên.&lt;/p&gt;

&lt;h4 id=&quot;3-reactive--functional-reactive-programmingfrp&quot;&gt;3. Reactive &amp;amp; Functional Reactive Programming(FRP):&lt;/h4&gt;

&lt;p&gt;Đối với hầu hết các lập trình viên Javascript thì đây là một Paradigm không quá xa lạ, là sự hợp thành của 2 Paradigms Functional và Reactive(Events/Data stream Driven, Push, Asynchronous).&lt;/p&gt;

&lt;p&gt;Đây là một Paradigm giúp chúng ta code Declarative hơn, dễ hiểu hơn theo hướng event, giúp đơn giản hoá việc xử lí bất đồng bộ đồng thời tránh đi việc gọi quá nhiều callback gây callback hell hoặc dùng promise/async-await mà quên đi tính event driven khi code. Ngoài ra đây cũng là một Paradigm giúp engineer xử lí concurent với một mô hình khác(event driven) ở mức low-level thông qua các khái niệm như observables, observers, operators, scheduler….&lt;/p&gt;

&lt;h3 id=&quot;iiicác-design-principles&quot;&gt;III.CÁC DESIGN PRINCIPLES:&lt;/h3&gt;
&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng việc clean code, nó cũng giống như việc xây nhà, khi bắt đầu điều tiên quyết chúng ta cần có đó là những viên gạch tốt. Những viên gạch đã không tốt thì cho dù kiến trúc tổ chức tốt đến nhừng nào cũng chỉ là trên bản vẻ mà thôi, khi xây nên hoàn toàn dễ dàng sụp đổ. Mặt khác khi bạn đã có các viên gạch đủ tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn.&lt;/p&gt;

&lt;p&gt;Để cấu nên một toà nhà lớn chúng ta nên chia nhỏ phát triển từng components bằng cách abstract hoá lên rồi lại separate ra một cách thích hợp để tạo thành các components nhỏ dễ cho việc quản lí, tái sử dụng cũng như gỡ bỏ khi không cần nữa.&lt;/p&gt;

&lt;p&gt;Các Design Principles sinh ra nhằm giúp chúng ta thực hiện việc đó ở mức độ hight-level/mid-level/low-level như việc tổ chức tốt các thành phần từ đơn vị nhỏ như ghép nối các viên gạch thành cấu trúc từng bức tường.&lt;/p&gt;

&lt;p&gt;Các design parterns cho chúng ta biết cách xắp xếp các hàm, các cấu trúc dữ liệu vào các class, struct và kết nối chúng lại với nhau để xây dựng nên các module hoàn chỉnh dễ dàng thay đổi, dễ hiểu cho người mới và đồng thời dễ tái sử dụng code, tiết kiệm effort hơn.&lt;/p&gt;

&lt;p&gt;Các Principles chúng ta nên tham khảo và áp dụng như Component Principles, SOLID Principles,… Các bạn có thể xem lại &lt;a href=&quot;https://romeo.vn/solid-principle/&quot;&gt;SOLID Principles&lt;/a&gt; .&lt;/p&gt;

&lt;h3 id=&quot;iii-một-architecture-tốt-sẻ-trông-như-thế-nào&quot;&gt;III. MỘT ARCHITECTURE TỐT SẺ TRÔNG NHƯ THẾ NÀO?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Architecture có thể được xem như cấp độ cao hơn code mà chúng ta đã viết. Nó là structure của ứng dụng, là cách mà các thành phần được tổ chức, sắp xếp và liên kết với nhau. 
Architecture thường bao gồm các lớp được triển khai theo trục dọc và ngang của hệ thống đồng thời phãi kết nối các thành đó lại với nhau để chúng work một cách gọn ghẽ.&lt;/p&gt;

&lt;p&gt;Software architecture phãi được design với mục đích chính là phục vụ developer, cải thiện hiệu năng làm việc của họ chứ không phãi thoả mãn các architect hay optimize hiệu suất làm việc cho phần cứng.&lt;/p&gt;

&lt;p&gt;Người thiết kế kiến trúc phần mềm phãi đặt mục tiêu thấu hiểu những vấn đề của dev, hiểu được gì họ cần để làm việc một cách vui vẻ hạnh phúc, hiểu được những khó khăn của họ trong quá trình phát triển cũng như duy trì hệ thống từ đó đưa ra những gì tốt nhất, tiện lợi nhất cho developer.&lt;/p&gt;

&lt;p&gt;Khi nói rằng software architecture không sinh ra mục đích optimize hiệu suất làm việc cho phần cứng không có nghĩa là chúng ta không optimize hiệu suất phần cứng, ở đây chúng ta sẻ chỉ optimize cho phần cứng khi chi phí cho vấn đề performance lớn hơn lợi ích của một kiến trúc sạch cho developer mà thôi. Nói tóm lại chúng ta nên tránh optimize quá sớm, nên đặt trọng tâm vào design một architecture phục vụ developer trước tiên.&lt;/p&gt;

&lt;p&gt;Đứng về phía developer chúng ta có thể thấy rằng một architecture tốt sẻ thoả mãn các tiêu chí sau đây:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Simple, Understandable and Emergent: Quá hiển nhiên, một kiến trúc đơn giản, rõ ràng và dễ thẩm thấu sẻ giúp người mới tiếp cận code base một cách nhanh hơn, giảm effort khi transfer cũng như trainning.&lt;/li&gt;
  &lt;li&gt;Flexible: Đây cũng là một đặc điểm quan trọng, một kiến trúc linh hoạt, dễ thay đổi để đáp ứng các yêu cầu business sẻ phần nào giúp developer vui vẻ hạnh phúc hơn mỗi lúc có sự thay đổi diễn ra về mặt business.&lt;/li&gt;
  &lt;li&gt;Testable: Một architecture giúp developer dễ test hơn sẻ mang lại rất nhiều giá trị về việc duy trì cũng như refactor sau này. Họ có thể tự tin refactor phần nào đó mà vẫn dám đảm bảo business vẫn chạy đúng hoặc hạn chế tối đa bug khi refactor.&lt;/li&gt;
  &lt;li&gt;Maintainable: Rõ ràng rồi, thời gian và chi phí của việc maintain luôn chiếm hơn gấp đôi so với việc xây dựng mới, do đó một architecture không đảm bảo được tính Maintainable thì quả thực là nổi ám ảnh cho developer khi duy trì nó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;v-clean-architecture&quot;&gt;V. CLEAN ARCHITECTURE:&lt;/h3&gt;
&lt;p&gt;Trãi qua một quá trình dài tiến hoá và phát triển với các mẫu Architecture khác nhau. Cụ Bob giới thiệu cho chúng ta một tập hợp các Principles, Design Parterns nhằm separate các components, các dependencies, các concerns, chia phần mềm thành nhiều lớp và tổ chức các lớp đó sao cho thoả mãn các yêu cầu chung của một kiến trúc có thể gọi là tốt, nó được cụ Bob giới thiệu đầy đủ trong cuốn Clean Architecture, một cuốn sách mình thực sự nghiền ngẫm. Trong đó mô tả một kiến trúc Clean là một kiến trúc đáp ứng những tiêu chí sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Độc lập với các Frameworks: Kiến trúc phần mềm là không phụ thuộc vào bất cứ Framework/Tool-kit nào, các Frameworks có sẳn sinh ra nhằm giúp chúng ta một phần nào đó trong việc tổ chức hệ thống chứ không nhất nhất là chúng ta cần gì cũng kéo Framework vào để rồi phãi nhồi nhét nhiều thứ quy tắc rối rắm mà mỗi Framework yêu cầu.&lt;/li&gt;
  &lt;li&gt;Dễ test: Các thành phần trong phần mềm của chúng ta phãi dễ test mà không phãi phụ thuộc vào interface(UI/console UI), database hay bất cứ thành phần nào.&lt;/li&gt;
  &lt;li&gt;Độc lập với UI hay bất cứ interface nào: Các interface hổ trợ người dùng có thể thay đổi một cách dễ dàng mà không ảnh hưởng đến phần còn lại của hệ thống. Chẳng hạn, một giao diện web có thể được thay đổi thành giao diện command mà không làm ảnh hưởng đến các business rule.&lt;/li&gt;
  &lt;li&gt;Độc lập với Database, bạn có thể thay đổi từ Oracle hoặc Sql Server thành Mongo, BigTable, CouchDB, Cassandra hoặc bất kỳ hệ quản trị cơ sở dữ liệu nào mà không làm ảnh hưởng đến Business Rule ban đầu.&lt;/li&gt;
  &lt;li&gt;Độc lập với các thành phần third-party: Phần mềm của chúng ta sẻ không phụ thuộc vào bất cứ libraries/frameworks hay bất cứ thành phần third-party nào, chúng ta phãi có một tư duy rằng các frameworks/libraries sinh ra để chúng ta chọn cho việc phục vụ nhu cầu nghiệp vụ của chúng ta chứ không phãi chúng ta phụ thuộc vào các thứ đó để implement các logic nghiệp vụ của mình.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để đạt được những điều trên, tác giả Uncle Bob đề ra các ý tưởng, quy tắc được mô tả trong hình dưới:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và để dễ dàng tiếp cận chúng ta sẻ cùng phân tích các thành phần của một ứng dụng đơn giản để làm rõ những mục tiêu nguyên tắc của Clean Architect. Giả sử chúng ta có một ứng dụng đơn giản với một mô hình data-flow đơn giản như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi đó chúng ta sẻ đặt các thành phần lên các vòng tròn cơ bản như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nhìn theo mức độ tổng quát chúng ta sẻ có hai tầng abstract như sau:&lt;/p&gt;

&lt;h4 id=&quot;tầng-interface&quot;&gt;Tầng Interface:&lt;/h4&gt;
&lt;p&gt;Hai vòng tròn ngoài cùng mình tạm đặt nó vào tầng Interface. Đây là tầng chứa các  cổng giao tiếp:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Giao tiếp từ client đến hệ thống(Controller vs Presenter), tuỳ thuộc vào yêu cầu của hệ thống mà chúng ta sẻ implement các cổng Interfaces cụ thể để phục vụ client, có thể là giao tiếp dựa trên Rest/gRPC/TCP…. từ đó chúng ta có thêm các quyết định separate tầng này ra thành các tầng nhỏ dựa vào các lớp endpoints, transports cụ thể.&lt;/li&gt;
  &lt;li&gt;Giao tiếp với các thành phần infrastructure như Database System, Log System, Message Queue System, Search Engine,…. . Đây là nơi chứa các implementations của các Infrastructure Interfaces(Repository Interfaces, Search Interfaces, Message Interfaces…) mà Domain Layer yêu cầu để thực hiện. Tuỳ vào yêu cầu cũng như loại infrastructure mà chúng ta implement và separate tầng này một cách phù hợp dựa vào các parterns và toolkit(DAO, Repository, Data mapper, ORM, Query builder…..).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domain-layer&quot;&gt;Domain Layer:&lt;/h4&gt;
&lt;p&gt;Domain Layer là layer chứa hai vòng tròn trong cùng, hai vòng tròn này về cơ bản sẻ gồm các Entities, các Use cases và các Infrastructure Interfaces.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Các Entities sẻ encapsulate các business rules. Một Entity có thể là một class/struct với các phương thức hoặc có thể là một tập hợp các cấu trúc dữ liệu và hàm, miễn là nó có thể được sử dụng bởi nhiều ứng dụng khác nhau trong toàn bộ hệ thống. Nếu chúng ta chỉ viết một ứng dụng đơn lẻ, thì các Entities chính là các business object của ứng dụng. Chúng encapsulate các quy tắc chung và cao cấp nhất. Các Entities ít có khả năng thay đổi do ảnh hưởng từ những thay đổi từ bên ngoài như UI, security hay kể cả việc thay đổi công nghệ, language, framework.&lt;/li&gt;
  &lt;li&gt;Các Use Case: Domain Layer sẻ chứa các business rules cụ thể của ứng dụng. Nó đóng gói và implement tất cả các use cases của hệ thống. Các use cases này sẽ điều chỉnh luồng dữ liệu đến và đi từ các Entities và chỉ đạo Entities thể đó sử dụng các business rules của doanh nghiệp để đạt được các mục tiêu của mỗi use case.&lt;/li&gt;
  &lt;li&gt;Chúng ta không cho phép những thay đổi trong các use cases ảnh hưởng đến các Entities, và cũng không muốn lớp use cases bị ảnh hưởng bởi những thay đổi của các yếu tố bên ngoài như cơ sở dữ liệu, giao diện người dùng hoặc bất kỳ framework nào, lớp này phãi cô lập với những thành phần đó.&lt;/li&gt;
  &lt;li&gt;Các Infrastructure Interfaces: Ở đây là các Repository Interfaces, Search Engine Interface,… mà các Use Cases cần để phục vụ việc vận hành business logic. 
Đây là layer vô cùng quan trọng, chứa nhiều logic do đó chúng ta phãi chú trọng tổ chức một cách hợp lí để không bị rối sau quá trình phình to. Tuỳ vào mục đích và tình huống cụ thể mà chúng ta có thể lựa chọn các partern cho phù hợp. 
Với tất cả hệ thống thì thành phần quan trọng nhất của nó luôn là Domain Layer, đây là nơi tập trung các Domain, các Use Cases, là nơi sẻ quyết định hệ thống này làm gì cho khách hàng, quyết định giá trị gì mà chúng ta tạo ra, quyết định sống còn của hệ thống. Mọi thứ bên ngoài như Databases, Frameworks, Protocols,…. đó có thể quy chung lại là các thành phần infrastructures giúp chúng ta implement và vận hành business logic mà thôi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Về cách tổ chức code chúng ta cũng sẻ dễ dàng tuỳ chỉnh dựa trên tư tưởng đó:&lt;/p&gt;

&lt;p&gt;Với Golang mình thường tổ chức theo mô hình sau:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── domain
│   ├── models
│   │   ├── ..
│   ├── repositories
│   │   ├── ..
│   ├── usecases
│   │   ├── ..
├── endpoints
├── interfaces
│   ├── httpsv
│   ├── grpcsv
│   ├── elasticsearch
│   ├── mysql
├── cmd
├── vendor
└── ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Với Typescript trên nền tảng Nodejs mình thưởng tổ chức như sau:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── src
│   ├── domains
│   │   ├── entities
│   │   ├── interfaces
│   │   ├── use_cases
│   │   ├── ...
│   ├── delivery
│   │   ├── http
│   │   ├── grpc
│   ├── infrastructure
│   │   ├── data_access_layer
│   │   │   ├── cassandra_implementation
│   │   │...
│   └── ...
├── node_modules
├── package.json
└── ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;quy-tắc-về-dependencythe-dependency-rule&quot;&gt;Quy tắc về Dependency(The Dependency Rule)&lt;/h4&gt;
&lt;p&gt;Chính sự phân cấp về độ quan trọng của các thành phần của hệ thống, chúng ta phãi có một quy tắc để tổ chức chúng quy tắc về Dependency(The Dependency Rule)&lt;/p&gt;

&lt;p&gt;Quy tắc này yêu cầu chúng ta phãi tổ chức code làm sao mà chúng chỉ có thể hướng vào bên trong, tức là những thứ ở bên trong không cần biết về những thứ ở bên ngoài, những thứ ở bên ngoài sinh ra nhằm phục vụ việc hiện thực business logic bên trong.&lt;/p&gt;

&lt;p&gt;Cụ thể, tên của một cái gì đó khai báo trong một vòng tròn bên ngoài không được tham chiếu đến hoặc sử dụng bởi mã nguồn trong một vòng tròn bên trong bao gồm, các hàm, các class, biến, hoặc bất kỳ thực thể phần mềm khác. Cũng giống như vậy, các định dạng dữ liệu(Class/Struct/….) được sử dụng trong vòng ngoài không nên được sử dụng bởi những thứ ở vòng tròn bên trong, đặc biệt nếu các định dạng đó được tạo ra bởi một framework trong vòng tròn bên ngoài. Chúng ta không muốn bất cứ điều gì trong một vòng tròn bên ngoài tác động vào vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;OK! Vậy phãi làm sao khi mà các thứ nằm trong vòng tròn bên trong không hề biết việc tồn tại các thứ ở bên ngoài lại có thể sử dụng được những thứ được implement bên ngoài. Ví dụ như các Use Cases nằm ở tầng Domain cần database implementation ở tầng bên ngoài cho việc hiện thực Use Case. Lúc này thay vì chúng ta sử dụng trực tiếp các Repository implementation thì chúng ta sẻ sử dụng Repository Interface/Abstraction ở tầng domain. Đây cũng là một ví dụ về nguyên tắc Dependency Inversion trong SOLID về việc phân tách các layers, các modules. Các high-level modules sẻ không phụ thuộc vào các low-level modules mà cả hai nên phụ thuộc vào các Abstractions nằm tại các hight-level modules.&lt;/p&gt;

&lt;h4 id=&quot;interface-adapters&quot;&gt;Interface Adapters&lt;/h4&gt;

&lt;p&gt;Một thành phần không kém phần quan trọng trong hệ thống  phần mềm của chúng ta đó là Interface Adapters. Đây là một bộ các adapters có nhiệm vụ chuyển dữ liệu từ đầng này sang  tầng khác. Ví dụ như adapter chuyển đổi dữ liệu từ các use cases và Entities/Domain Model thành dữ liệu cho Database(Database Model) và ngược lại(Data Mapper). Hoặc đối với các bạn quen thuộc với Gokit sẻ thấy đó là các Endponts, chuyển đổi các cấu trúc dữ liệu từ định dạng của request sang cấu trúc dữ liệu đầu vào cho các Use Case Logics hoặc domain model. Và các Presenters sẻ encode response với định dạng phù hợp cho client.&lt;/p&gt;

&lt;h4 id=&quot;framework-và-driver&quot;&gt;Framework và Driver&lt;/h4&gt;

&lt;p&gt;Đây là một số thành phần có thể nằm trong các vòng tròn ngoài cùng, nói chung bạn không viết nhiều code trong layer này ngoại trừ code để connect với các vòng tròn ở bên trong. Layer này là nơi tập trung của các chi tiết. Chúng ta sẻ giữ những thứ này ở bên ngoài, nơi chúng khó có thể gây ảnh hưởng đến các phần ở vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;Tuân theo các quy tắc đơn giản trên không phải là một việc quá khó khăn nhưng nó sẻ giúp chúng ta tiết kiệm được nhiều thời gian trong tương lai. Bằng việc tách hệ thống thành các layer, đồng thời tuân theo Dependency Rule, chúng ta sẽ xây dựng được một hệ thống dễ test, cùng với những lợi ích kèm theo như đã đề cập ở trên. Khi bất kỳ bộ phận bên ngoài của hệ thống trở nên lỗi thời, chẳng hạn như database, hoặc web framework, bạn hoàn toàn có thể thay thế chúng với một effort tối thiểu.&lt;/p&gt;

&lt;h3 id=&quot;chỉ-chừng-đó-là-đủ-ư&quot;&gt;Chỉ chừng đó là đủ ư?&lt;/h3&gt;
&lt;p&gt;Tất nhiên đó chỉ là những thứ cơ bản, chỉ là một mẫu đơn giản, nhiều lúc bạn cần nhiều hơn 4 vòng tròn đó hoặc mỗi vòng tròn chúng ta phãi chia nhỏ thành các vòng tròn khác nữa để đảm bảo sự rõ ràng và “CLEAN” tuỳ thuộc vào sự tiến hoá của code base, hơn nữa không có quy tắc nào nói rằng bạn luôn phải có chỉ 4 vòng tròn, có thể có chừng đó layer, có thể nhiều hơn và cũng có thể ít hơn, nhiều hơn khi kiến trúc monolith của bạn ngày càng phình to và trở nên phức tạp, ít hơn khi bạn đã chia chúng được thành các microservices một cách mượt mà, chỉ tập trung là logic và loại bỏ đi những thứ rườm rà không đáng quan trọng, và có thể chia thêm layer cho phù hợp với độ tiến hoá. Cũng có thể bạn tách ra thành miroservices nhưng vẫn giữ nguyên kiến trúc với đầy đủ ban bệ của mẫu monolith củ, tuỳ vào việc bạn muốn quản lí một củ hành bự hoặc một rỗ hành hoặc một rỗ các tép hành mà thôi. Nhưng một điều mà chúng ta phãi ghi nhớ nếu không muốn bị ăn hành đó là Dependency Rule luôn phãi được áp dụng, sự phụ thuộc luôn phãi được hướng vào những thứ quan trọng nhất. Khi chia các layer theo các vòng tròn chúng ta nhìn sâu vào tâm vòng tròn thì mức độ abstract phãi tăng lên, vòng tròn trong cùng chỉ chứa những gì chung nhất, khó có thể chia nhỏ được nữa như các interface chẳng hạn. Các vòng tròn ngoài cùng phãi là các chi tiết được implement cụ thể ở mức thấp nhất và không ngại phãi thay đổi.&lt;/p&gt;

&lt;p&gt;Clean Architecture hay các Architectures mục tiêu lớn nhất vẫn là hướng Engineer vào thứ quan trọng nhất của phần mềm là các Domain, Business Rules và là tập hợp các quy tắc, để giữ cho source code hệ thống phần mềm của chúng ta luôn được “Clean”.&lt;/p&gt;

&lt;h3 id=&quot;implement-clean-architecture&quot;&gt;Implement Clean Architecture:&lt;/h3&gt;
&lt;p&gt;Đây là hai ví dụ nhỏ mình implement Clean Architecture với Golang và Typescript các bạn có thể tham khảo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lephuocmy668/daily-problems-solving/tree/master/golang/workspace/tiktok-clean-microservice&quot;&gt;Golang Clean Microservice&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lephuocmy668/nodejs-typescript-clean-architecture&quot;&gt;Typescript Clean Microservice&lt;/a&gt;&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><category term="functional programming" /><category term="functional reactive programming" /><category term="declarative programming" /><category term="clean architecture" /><category term="concurrency" /><summary type="html">Trong bài viết này chúng ta sẻ cùng thảo luận về một loạt các patterns, principles, paradigms nhằm tạo ra một kiến trúc tốt hơn nhằm thay thế cho các approaches không thực sự còn hợp thời nữa, đặc biệt là các concepts trong Clean Architecture. Bài viết này mình sẻ thảo luận về một số mục chính sau:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Solid Principle</title><link href="https://romeo.vn/solid-principle/" rel="alternate" type="text/html" title="Solid Principle" /><published>2018-01-12T01:01:00-06:00</published><updated>2018-01-12T01:01:00-06:00</updated><id>https://romeo.vn/solid-principle</id><content type="html" xml:base="https://romeo.vn/solid-principle/">&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng code sạch. Cũng giống như việc xây nhà, bắt đầu chúng ta cần những viên gạch tốt đã, nhưng những viên gạch đã không tốt thì kiến ​​trúc của tòa nhà không còn quan trọng nữa vì nó đã dễ dàng sụp đổ rồi. Một mặt khác, khi bạn có các viên gạch tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn từ những viên gạch tốt đó. Do đó Solid đến và giúp chúng ta xây dựng các kiến trúc tốt dựa trên các viên gạch tốt.&lt;/p&gt;

&lt;p&gt;Nguyên tắc SOLID cho chúng ta biết cách sắp xếp các hàm, cấu trúc dữ liệu của chúng ta vào các lớp và kết nối chúng lại với nhau để xây dựng nên hệ thống. Việc sử dụng từ class không có nghĩa rằng các nguyên tắc này chỉ áp dụng cho phần mềm hướng đối tượng. Một class đơn giản là một nhóm các hàm và dữ liệu được ghép đôi. Mọi hệ thống phần mềm đều có các nhóm như vậy cho dù chúng có được gọi là các class hay không thì nguyên tắc SOLID vẫn sẻ áp dụng được cho các nhóm đó.&lt;/p&gt;

&lt;p&gt;Vậy mục tiêu của các nguyên tắc trong SOLID là gì? Là tạo ra các cấu trúc ở mức mid-level của phần mềm có các yêu cầu như dễ dàng tiếp nhận sự thay đổi, dễ hiểu cho người mới, dễ sử dụng lại. Từ mid-level đề cập đến thực tế là các nguyên tắc này được áp dụng bởi các lập trình viên làm việc ở cấp modules, SOLID được áp dụng ngay trên mức của code implement và giúp xác định các loại cấu trúc phần mềm được sử dụng trong các modules và các components.&lt;/p&gt;

&lt;p&gt;Chỗ này hơi khó hiểu nhể, có thể tưởng tượng rằng một ngôi nhà nên được chia đầu tiên thành các components như các bức tường nhỏ, sau đó ghép nối lại thì SOLID được dùng ở mức các Engineer tạo nên các bức tường đó. Nói cách khác, khi muốn xây dựng kiến trúc tốt cho một ngôi nhà hay phần mềm chúng ta phãi thiết kế tốt từ từng bức tường, từng modules từng component để sao cho nó có thể dễ dàng tiếp nhận sự thay đổi, dễ dùng dễ hiểu cho người mới và hơn nữa là dễ dàng tái sử dụng module/component đó.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SOLID&lt;/strong&gt; được &lt;strong&gt;Robert C. Martin&lt;/strong&gt; đưa ra với năm nguyên tắc thiết kế hướng đối tượng (OOD) sau:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Single responsibility principle (SRP)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Open/closed principle (O)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Liskov substitution principle (L)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Interface segregation principle (I)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Dependency inversion principle (D)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta sẻ tiếp tục phân tích rõ từng nguyên tắc.&lt;/p&gt;

&lt;h3 id=&quot;1-the-single-responsibility-principlesrp&quot;&gt;1. The Single Responsibility Principle(SRP):&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;The Single Responsibility Principle(SRP)&lt;/strong&gt;: Mỗi một class chỉ đảm nhiệm một trách nhiệm duy nhất,một hệ thống phần mềm có cấu trúc tốt là hệ thống có các module/component mà chúng chỉ có một và chỉ một lý do để thay đổi.
Đọc đến đây chúng ta sẻ có thể dễ nhầm lẩn với một nguyên tắc khác đó là việc các hàm nên làm một và chỉ một việc duy nhất, đó là một nguyên tắc chúng ta thường sử dụng khi tái cấu trúc các hàm lớn thành các hàm nhỏ. Đó không phãi là SRP.&lt;/p&gt;

&lt;p&gt;Để hiểu rõ nguyên tắc này chúng ta sẻ xét một ví dụ mà ta đã vi phạm nguyên tắc này:
Giả sử hệ thống quản lí tiền lương nhân viên của chúng ta có chứa 4 thực thể sau: Employee, CTO, CFO, COO. Class Employee của chúng ta sẻ có chứa ba phương thức sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;caculatePay()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reportHours()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;save()&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cách thiết kế class Employee của chúng ta đã vi phạm SRP bởi vì nó có ba phương thức chịu trách nhiệm với 3 thực thể rất khác nhau.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức caculatePay() được gọi bởi phòng kế toán và báo cáo cho CFO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức reportHours() được gọi bởi phòng HR và báo cáo cho COO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức save() được gọi bởi database admin và báo cáo cho CTO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bằng việc đưa ba phương thức trên vào một class Employee đơn lẻ, chúng ta đã vô tình kết hợp sự phụ thuộc của các thực thể khác lại với nhau, ở đây có thể là CFO, COO, CTO đã vô tình phụ thuộc vào nhau. Lấy ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử rằng hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; và hàm &lt;strong&gt;reportHours()&lt;/strong&gt; cần có giờ làm việc của từng nhân viên và chúng dùng chung một thuật toán để tính giờ làm việc, rõ ràng là khi đó chúng ta sẻ không muốn việc duplicate code xãy ra ở đây, chúng ta sẻ viết một hàm &lt;strong&gt;regularHours()&lt;/strong&gt; cho việc sử dụng của hai hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; và &lt;strong&gt;reportHours()&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Đến một ngày đẹp trời, nhóm CFO quyết định rằng việc tính toán giờ làm việc &lt;strong&gt;regularHours()&lt;/strong&gt; cần được tinh chỉnh lại trong lúc nhóm COO vẫn thấy hàm &lt;strong&gt;regularHours()&lt;/strong&gt; như thế là ổn rồi không muốn bất cứ thay đổi gì đối với nó nữa.&lt;/p&gt;

&lt;p&gt;Một developer được giao nhiệm vụ tinh chỉnh lại hàm &lt;strong&gt;regularHours()&lt;/strong&gt; theo một mục đích mới nào đó, anh ta làm việc nhưng đâu biết rằng hàm &lt;strong&gt;reportHours()&lt;/strong&gt; cũng gọi đến nó, việc tinh chỉnh được thực hiện xong, hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; chạy trơn tru đúng yêu cầu và được áp dụng ngay. Sau một thời gian người ta nhận thấy hàm &lt;strong&gt;reportHours()&lt;/strong&gt; đã đi sai hướng, các số liệu báo cáo lên sai lệch ảnh hưởng đến tài chính công ty.&lt;/p&gt;

&lt;p&gt;Đó là một ví dụ vi phạm, khi gặp các trường hợp đó chúng ta nên phân tách các phương thức ra các class riêng lẻ và ngược lại, cách dễ nhất để phá các ứng dụng là tạo ra các GOD classes(một GOD class là một class biết quá nhiều hoặc làm quá nhiều, GOD class là một ví dụ về một ví dụ về anti pattern), một God class giữ reference đến nhiều thực thể khác cũng như giữ nhiều trách nhiệm đâm ra dễ gây ra các vấn đề tương tự như ví dụ trên.&lt;/p&gt;

&lt;h3 id=&quot;2-openclosed-principle-ocp&quot;&gt;2. Open/closed principle (OCP):&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Theo nguyên lý này, mỗi khi ta muốn thêm chức năng cho chương trình, chúng ta nên viết class mới mở rộng từ class cũ ( bằng cách kế thừa hoặc sở hữu class cũ) không nên sửa đổi class cũ:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tất nhiên rồi phãi không nào, đây là lý do cơ bản nhất mà chúng ta nghiên cứu software architecture. Rõ ràng là nếu muốn mở rộng chức năng một cách đơn gỉan mà phãi thay đổi lớn đối với phần mềm thì các kiến ​​trúc sư của hệ thống phần mềm đó đã thất bại rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mục đích là thế nhưng làm thì như nào để đạt được mục đích nguyên tắc đó, chúng ta cùng xét một ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử hệ thống của bạn đang có một chức năng báo cáo tóm tắt tài chính, dữ liệu được hiển thị trên giao diện web và có thể cuộn cho bản tóm tắt dài. Rồi một ngày đẹp trời khách hàng muốn bạn thêm chức năng thể hiện báo cáo đó trên trên PDF với tiêu đề và phân trang hợp lí, các số liệu cần được làm nổi bật và gửi cho người dùng.&lt;/p&gt;

&lt;p&gt;Rõ ràng, một lượng code sẻ phãi được viết lại để đáp ứng yêu cầu trên nhưng bao nhiêu code củ sẻ phãi thay đổi? Kiến trúc tốt sẻ giảm thiểu lượng code phãi thay đổi xuống mức tối thiểu nhất và lí tưởng nhất là không có dòng code nào phãi thay đổi.&lt;/p&gt;

&lt;p&gt;Làm thế nào để đạt được điểu đó? Đầu tiên phãi tách biệt những thực thể mà chúng có thể phãi thay đổi vì các lí do khác nhau(áp dụng SRP) sau đó bố trí sự phụ thuộc của chúng đúng cách(sử dụng DIP nói sau). Bằng cách đó chúng ta sẻ đưa luồng dữ liệu hướng như dưới, mô tả một số quy trình kiểm tra xử lí dữ liệu có thể trình bày, sau đó trình bày theo định dạng phù hợp để thể hiện trên web và trên PDF.&lt;/p&gt;

&lt;p&gt;Thông tin chi tiết cần thiết ở đây là việc tạo báo cáo liên quan đến hai trách nhiệm riêng biệt: tính toán thông tin số liệu tài chính và việc trình bày data đó thành các model thân thiện với web và pdf.&lt;/p&gt;

&lt;p&gt;Sau khi thực hiện sự tách biệt này, chúng ta cần phải tổ chức các phụ thuộc code để đảm bảo rằng những thay đổi đối với một trong những trách nhiệm đó không gây ra những thay đổi ở bên kia. Ngoài ra, cách tổ chức mới phải đảm bảo rằng hành vi có thể được mở rộng mà không huỷ bỏ các sửa đổi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/2.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta thực hiện điều này bằng cách phân vùng các quy trình thành các class và tách các class đó thành các component, như được thể hiện bằng các dòng kép trong sơ đồ trong hình dưới.&lt;/p&gt;

&lt;p&gt;Trong hình này, thành phần ở phía trên bên trái là Controller, phía trên bên phải là Interactor, phía dưới bên phải là database, ở phía dưới bên trái có bốn thành phần đại diện cho đối tượng hiển thị và data hiển thị.&lt;/p&gt;

&lt;p&gt;Các  được đánh dấu bằng &lt;i&gt; là các interface; những người được đánh dấu bằng &lt;DS&gt; là các cấu trúc dữ liệu.&lt;/DS&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Các mũi tên đang sử dụng để thể hiện các mối quan hệ. Đầu mũi tên trỏ tới thể hiện mối quan hệ thừa kế. Điều đầu tiên cần lưu ý là tất cả các phụ thuộc là các phụ thuộc code. Một mũi tên chỉ từ class A đến class B có nghĩa là code của lớp A reference đế class B, nhưng class B không cần biết gì đến class A.&lt;/p&gt;

&lt;p&gt;Như vậy, trong hình trên, FinancialDataMapper reference đến FinancialDataGateway thông qua một mối quan hệ implement interface, nhưng FinancialGateway không biết gì về FinancialDataMapper.
&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/3.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều tiếp theo cần lưu ý là tất cả mỗi quan hệ đều là một chiều và mỗi đối tượng chỉ chịu sự phụ thuộc đến duy nhất một thực thể khác như thể hiện trong hình dưới, những mũi tên hướng tới các thành phần mà chúng ta muốn bảo vệ khỏi thay đổi.&lt;/p&gt;

&lt;p&gt;Nghĩa là sao? là nếu thành phần A cần được bảo vệ khỏi những thay đổi trong thành phần B, thì thành phần B sẽ phụ thuộc vào thành phần A. Chúng ta muốn bảo vệ Controller khỏi những thay đổi trong Presenters. Chúng ta muốn bảo vệ các Presenters khỏi những thay đổi trong Views. Chúng tôi muốn bảo vệ Interactor khỏi những thay đổi trong bất cứ điều gì. Interactor ở vị trí phù hợp nhất với OCP.&lt;/p&gt;

&lt;p&gt;Các thay đổi đối với Database hoặc Controller hoặc Presenters hoặc Views sẽ không ảnh hưởng đến Interactor.
Tại sao Interactor nên giữ một vị thế đặc quyền như vậy? Bởi vì nó chứa các business rule. Interactor chứa các chính sách cao nhất của ứng dụng. Tất cả các thành phần khác đang xử lý các mối quan tâm ngoại vi còn interactor giao dịch với mối quan tâm trung tâm. Mặc dù Controller là ngoại vi với Interactor, nhưng nó vẫn là trung tâm của các Presenters và Views. Và trong khi các diễn giả có thể là ngoại vi với Controller nhưng chúng là trung tâm của Views.&lt;/p&gt;

&lt;p&gt;Lưu ý cách thức này tạo ra một hệ thống phân cấp bảo vệ dựa trên khái niệm “level”. Các tác nhân tương tác là khái niệm mức cao nhất, vì vậy chúng được bảo vệ nhất. View nằm trong số các khái niệm cấp thấp nhất, vì vậy chúng được bảo vệ ít nhất. Presenters có cấp độ cao hơn Views nhưng cấp thấp hơn Controller hoặc Interactor.&lt;/p&gt;

&lt;p&gt;Đây là cách OCP hoạt động ở cấp kiến ​​trúc. Các kiến trúc chia chức năng riêng biệt dựa trên cách thức – tại sao và khi nào chúng thay đổi, sau đó tổ chức chức năng được phân tách thành một hệ thống phân cấp các thành phần. Các thành phần cấp cao hơn trong phân cấp đó được bảo vệ khỏi những thay đổi được thực hiện cho các thành phần cấp thấp hơn.&lt;/p&gt;

&lt;p&gt;Nói tóm lại OCP là một trong nhưng sức mạnh đứng đằng sau kiến trúc hệ thống tốt, giúp hệ thống dễ dàng mở rộng mà không phãi chịu sức ép từ những thay đổi trong mã nguồn, mục tiêu này đạt được khi chúng ta chia phân vùng hệ thống thành các component và sắp xếp chúng thành một hệ thống phân cấp sự phụ thuộc để bảo vệ các thành phần cấp cao khỏi sự thay đổi của các thành phần cấp thấp.&lt;/p&gt;

&lt;h3 id=&quot;3-liskov-substitution-principlelsp&quot;&gt;3. Liskov Substitution Principle(LSP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này được phát biểu như sau:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trong một chương trình, các object của class con có thể thay thế class cha mà không làm thay đổi tính đúng đắn của chương trình&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Không hiểu đúng không nào? Có thể nghĩ như này: Khi các class A kế thừa từ class B thì phãi có hai điều kiện sau:&lt;/p&gt;

&lt;p&gt;– Class B có các behaviors nào thì A phãi có các behaviors đó.&lt;/p&gt;

&lt;p&gt;– Các phương thức của class cơ sở thì phãi đảm bảo có thể sử được trong các class con của nó hay nói cách khác các phương thức của các class cha phãi luôn hoạt động được và chính xác trên tất cả các class kế thừa từ nó.&lt;/p&gt;

&lt;p&gt;Để hiểu hơn ta xét ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử ta có class Chim có phương thức là Bay()&lt;/p&gt;

&lt;p&gt;– Class Đại Bàng thừa kế class Chim cũng có đủ phương thức Bay() và hoạt động đúng như class chim() trường hợp này thoả mãn LSP.&lt;/p&gt;

&lt;p&gt;– Class Chim Cánh cụt thừa kế class Chim nhưng phương thức Bay không khả dụng cho nên là vi phạm LSP.&lt;/p&gt;

&lt;p&gt;– Class Chim Điện thừa kế class Chim cũng có phương thức bay, nhưng phương thức Bay này có thêm yêu cầu là phãi có điện thì mới bay được cho nên vi phạm LSP.&lt;/p&gt;

&lt;p&gt;LSP cần được mở rộng đến mức kiến trúc. Một sự vi phạm đơn giản về khả năng thay thế, có thể làm cho kiến trúc của hệ thống bị ô nhiễm với một số lượng đáng kể các cơ chế bổ sung.&lt;/p&gt;

&lt;h3 id=&quot;4-interface-segregation-principleisp&quot;&gt;4. Interface segregation principle(ISP):&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/4.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nguyên tắc này có thể nói ngắn gọn là thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ, với nhiều mục đích cụ thể, để dễ hiểu hơn chúng ta cùng xét ví dụ như hình trên, mỗi user sử dụng các phương thức của class OPS, giả sử rằng User1 chỉ sử dụng op1, User2 chỉ sử dụng op2, User3 chỉ sử dụng op3.&lt;/p&gt;

&lt;p&gt;Khi đó User1 vô tình phụ thuộc vào op2 và op3 mặc dù nó không gọi chúng, sự phụ thuộc này khiến cho User1 phãi được implement lại khi op2 và op3 bị thay đổi mặc dù nó không dùng hai hàm đó, hơn thế nữa việc gom quá nhiều phương thức vào một đối tượng khiến cho chúng ta nhọc nhằng trong việc implement cho nên chúng ta nên giải quyết bằng cách tách biệt các phương thức thành các interface nhỏ như hình bên dưới.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/5.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu vấn đề này được triển khai trên ngôn ngữ tỉnh như Golang thì code của User1 sẻ phụ thuộc vào U1Ops và op1 nhưng sẻ không phụ thuộc vào OPS do đó khi có thay đổi đối với OPS mà User1 không quan tâm sẻ không làm cho User1 bị biên dịch lại và triển khai lại.&lt;/p&gt;

&lt;h3 id=&quot;5-dependency-inversion-principledip&quot;&gt;5. DEPENDENCY INVERSION PRINCIPLE(DIP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này cho chúng ta biết rằng các hệ thống linh hoạt nhất là các hệ thống phụ thuộc vào mã nguồn chỉ tham chiếu đến trừu tượng hóa, chứ không chỉ các concretions.&lt;/p&gt;

&lt;p&gt;Hãy tưởng tượng phần mềm của chúng ta sẻ như thế nào trước khi có một cơ chế an toàn và thuận tiện cho đa hình, luồng đi của phần mềm này sẻ như cây mô tả bên dưới, các hàm main được gọi là các hàm level cao chúng gọi các hàm level trung bình và các hàm level trung bình gọi các hàm ở level thấp. Tuy nhiên có thể thấy rằng trong cây đó các phụ thuộc code không đi theo hướng của luồng gọi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/6.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/7.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để hàm main gọi một trong các hàm level cao, nó phải reference đến tên của module chứa hàm đó. Trong C chúng ta dùng #include trong Java và Go ta dùng câu lệnh import. Thật vậy, mỗi phần chứa hàm gọi buộc phải refer đến tên của module có chứa hàm được gọi. Rõ ràng sự phụ thuộc được thể hiện rằng hàm Main sẻ phụ thuộc vào các hàm dưới nó. Tuy nhiên, khi đa hình được đưa vào sử dụng, một điều rất khác sẻ xảy ra như sau.&lt;/p&gt;

&lt;p&gt;Chúng ta có thể thấy rằng module HL1 vẫn gọi hàm F () trong module ML1 nhưng thực tế là nó gọi hàm này thông qua một interface mà khi chạy thì interface thực sự không tồn tại. HL1 đơn giản gọi F () trong ML1 mặc dù là thể hiện gián tiếp.&lt;/p&gt;

&lt;p&gt;Tuy nhiên lưu ý rằng sự phụ thuộc mã nguồn (mối quan hệ thừa kế) giữa ML1 và interface trỏ theo hướng ngược lại so với luồng điều khiển. Điều này được gọi là sự đảo ngược phụ thuộc và các tác động của nó đối với kiến trúc phần mềm là rất sâu sắc. Thực tế là các ngôn ngữ OOP cung cấp tính đa hình an toàn và thuận tiện cho nên bất kỳ sự phụ thuộc mã nguồn nào bất kể nó ở đâu đều có thể đảo ngược.&lt;/p&gt;

&lt;p&gt;Bây giờ hãy nhìn lại luồng đi trong hình 6 và các phụ thuộc mã nguồn của nó thì bất kỳ phụ thuộc mã nguồn nào đều có thể được quay lại bằng cách chèn một interface giữa chúng. Với cách tiếp cận này các kiến trúc implement trong các hệ thống được viết bằng ngôn ngữ OOP có thể kiểm soát hướng của tất cả các phụ thuộc mã nguồn trong hệ thống. Đó là sức mạnh mà OOP cung cấp. Bạn có thể làm gì với sức mạnh đó? Ví dụ, bạn có thể sắp xếp lại các phụ thuộc mã nguồn của hệ thống để cơ sở dữ liệu và giao diện người dùng (UI) phụ thuộc vào các quy tắc nghiệp vụ chứ không phải là cách khác.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/8.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều này có nghĩa là gì? Là giao diện người dùng và cơ sở dữ liệu có thể được implement để bổ sung cho thể hiện các business logic, mã nguồn của business logic không bao giờ cần biết đến giao diện người dùng hoặc cơ sở dữ liệu. Kết quả là, các business logic cũng như giao diện người dùng và cơ sở dữ liệu có thể được biên dịch thành ba thành phần hoặc đơn vị triển khai riêng biệt và thành phần chứa business logic sẽ không phụ thuộc vào các thành phần có chứa giao diện người dùng và cơ sở dữ liệu, các thay đổi đối với giao diện người dùng hoặc cơ sở dữ liệu không có bất kỳ ảnh hưởng nào đến business logic. Tóm lại, khi mã nguồn trong một thành phần thay đổi thì chỉ thành phần đó cần phải được triển khai lại. Đây là khả năng triển khai độc lập, nếu các module trong hệ thống của bạn có thể được triển khai độc lập, thì chúng có thể được phát triển độc lập bởi các nhóm khác nhau.&lt;/p&gt;

&lt;p&gt;Qua việc tìm hiểu nguyên tắc này chúng ta cũng có thể thấy được sức mạnh của OOP đặc biệt là tính đa hình, thông qua việc sử dụng đa hình chúng ta có thể giành quyền kiểm soát tuyệt đối đối với mọi phụ thuộc mã nguồn trong hệ thống.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">Hệ thống phần mềm tốt phãi bắt đầu bằng code sạch. Cũng giống như việc xây nhà, bắt đầu chúng ta cần những viên gạch tốt đã, nhưng những viên gạch đã không tốt thì kiến ​​trúc của tòa nhà không còn quan trọng nữa vì nó đã dễ dàng sụp đổ rồi. Một mặt khác, khi bạn có các viên gạch tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn từ những viên gạch tốt đó. Do đó Solid đến và giúp chúng ta xây dựng các kiến trúc tốt dựa trên các viên gạch tốt.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Hiểu Về Call Stack - Heap - Queue</title><link href="https://romeo.vn/hieu-ve-call-stack-heap-queue/" rel="alternate" type="text/html" title="Hiểu Về Call Stack - Heap - Queue" /><published>2017-08-14T12:45:00-05:00</published><updated>2017-08-14T12:45:00-05:00</updated><id>https://romeo.vn/hieu-ve-call-stack-heap-queue</id><content type="html" xml:base="https://romeo.vn/hieu-ve-call-stack-heap-queue/">&lt;h2 id=&quot;1-stack&quot;&gt;1. Stack:&lt;/h2&gt;

&lt;p&gt;Ứng với mỗi thread (hoặc 1 goruntine đối với Golang) của chương trình thường có một call stack. Khi ứng dụng bắt đầu được thực thi, các biến cục bộ, địa chỉ hàm, biến tham chiếu đối tượng….sẻ được lưu trữ trong Stack, tùy theo thứ tự gọi mà các thành phần đẩy vào stack được sắp xếp theo đúng thứ tự.
Khi 1 phương thức kết thúc cũng là lúc các giá trị biến và các tham chiếu đối tương được hủy bỏ — và địa chỉ hàm cũng được hủy bỏ ngay sau đó. Stack lưu trữ dung lượng thấp hơn rất nhiều so với heap.&lt;/p&gt;

&lt;p&gt;Khi lập trình với các ngôn ngữ như Java, Golang… chúng ta thường quan tâm đến stack size. Với Java trong môi trường 64-bit thì JVM mặc định có stack size cho mỗi thread là 1MB và Golang thì mặc định là 2kb.&lt;/p&gt;

&lt;p&gt;Trong Javascript, Golang và đa số các ngôn ngữ lập trình khác, khi chúng ta gọi một hàm để thực thi đồng nghĩa với việc chúng ta push một hàm vào stack, đến khi nào hàm đó thực thi xong và trả về thì mới được pop ra khỏi stack. Thao tác đó được mô tả như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/1.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Như hình trên, khi chúng ta thực thi một chương trình, đầu tiên chúng ta sẻ tìm đến hàm main, nơi mà mọi thực thi đều bắt đầu từ đây. Trong chương trình trên ta sẻ có các bước như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;console.log(bar(6))&lt;/strong&gt; được đưa vào stack. Hàm này gọi đến hàm &lt;strong&gt;bar&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp theo, &lt;strong&gt;bar(6)&lt;/strong&gt; được đưa vào stack, hàm &lt;strong&gt;bar&lt;/strong&gt; lại tiếp tục gọi hàm &lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp đó &lt;strong&gt;foo(x,y)&lt;/strong&gt; lại được đưa vào stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;foo&lt;/strong&gt; thực thi xong trả kết quả về cho hàm &lt;strong&gt;bar&lt;/strong&gt; và được pop ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;bar&lt;/strong&gt; nhận được kết quả từ hàm foo, thực thi xong trả về kết quả cho hàm &lt;strong&gt;console.log()&lt;/strong&gt; và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;console.log()&lt;/strong&gt; thực thi và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cuối cùng hàm &lt;strong&gt;main&lt;/strong&gt; cũng được loại bỏ ra khỏi stack, chương trình kết thúc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Đôi lúc chúng ta tạo ra một vòng lặp vô hạn khi chúng ta gọi nhiều đệ quy, với chrom thì thường giới hạn bởi 16.000 frames, nếu vượt ra khỏi con số đó thì sẻ sinh ra lỗi như sau :v&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-heap&quot;&gt;2. Heap:&lt;/h3&gt;

&lt;p&gt;Bộ nhớ Heap dùng để cấp phát bộ nhớ cho object, biến toàn cục.
Bất cứ khi nào khai báo đối tượng thì các giá trị của đối tượng sẽ được lưu trữ trong Heap (chú ý giá trị đối tượng chứ ko phải biến tham chiếu đối tượng) và có thể truy cập bất cứ khi nào trong chương trình, bộ nhớ tồn tại trong suốt quá trình thực thi chương trình&lt;/p&gt;

&lt;p&gt;Khi kết thúc 1 phương thức các biến tham chiếu đối tượng bị hủy trong stack và các tham chiếu tới các dữ liệu lưu trong Heap cũng bị hủy bỏ javascript sẻ dùng trình thu dọn rác để thực hiện kiểm tra các tham chiếu.. nếu ko còn tham chiếu nào tới biến lưu trữ trên vùng nhớ Heap thì các vùng nhớ đó sẽ được thu gom.&lt;/p&gt;

&lt;h3 id=&quot;3-queue&quot;&gt;3. Queue:&lt;/h3&gt;

&lt;p&gt;Đối với Javascript runtime thì có thêm một thành phần nữa đó là queue, đây là danh sách các message cần được sử lí và các hàm callback liên quan thực thi. Nói dễ hiểu hơn là các message này sẻ được lưu vào queue để phản hồi các sự kiện async bên ngoài chẳng hạn như sự kiện nhấp chuột hay một http reuquest với một callback được cung cấp.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">1. Stack:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">What and Why Golang?</title><link href="https://romeo.vn/gioi-thieu-ngon-ngu-golang/" rel="alternate" type="text/html" title="What and Why Golang?" /><published>2017-01-28T21:20:00-06:00</published><updated>2017-01-28T21:20:00-06:00</updated><id>https://romeo.vn/gioi-thieu-ngon-ngu-golang</id><content type="html" xml:base="https://romeo.vn/gioi-thieu-ngon-ngu-golang/">&lt;p&gt;Dạo gần đây Golang nổi lên mạnh mẻ như một ngôi sao trong làng lập trình hệ thống với các lợi ích, chức năng cực kì powerful. Chúng ta cùng lượt qua các điểm đáng chú ý của Go để xem xem vì sao nên cân nhắc chọn Go trong dự án của mình nhé.&lt;/p&gt;

&lt;p&gt;Về lịch sử Go là một ngôn ngữ lập trình được phát triển bởi Google bắt đầu từ năm 2007 và ra phiên bản đầu tiên vào tháng 12 năm 2012. Go là một strong typed language, biên dịch, có khả năng tự động dọn dẹp rác, hổ trợ sẳn concurrent và rất giống C về cú pháp.&lt;/p&gt;

&lt;h3 id=&quot;go-là-ngôn-ngữ-tối-giản-với-thiết-kế-thực-dụng&quot;&gt;Go là ngôn ngữ tối giản với thiết kế thực dụng:&lt;/h3&gt;

&lt;p&gt;Ngôn ngữ lập trình Go có thể được mô tả đơn giản bằng ba từ: &lt;strong&gt;đơn giản – tối thiểu – thực dụng&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Nhìn vào thiết kế của ngôn ngữ Go, chúng ta sẽ thấy được một cách tiếp cận cực kì đơn giản, tối thiểu nhưng vô cùng thực dụng của nó. Bạn có thể thấy được sự đơn giản trong tất cả các tính năng của Go bao gồm cả hệ thống kiểu dữ liệu, cú pháp,…. . Nhiều ngôn ngữ lập trình cung cấp quá nhiều tính năng giúp Dev dễ dàng làm việc hơn nhưng vô hình chung làm cho nó trở nên phức tạp hơn, mục tiêu thiết kế của Go là một ngôn ngữ đơn giản và chỉ cung cấp tất cả các tính năng cần thiết tối thiểu để phát triển các hệ thống phần mềm một hiệu quả.&lt;/p&gt;

&lt;p&gt;Mặc dù Go có ít tính năng hơn nhưng năng suất không bị ảnh hưởng bởi hạn chế đó. Nhờ sự đơn giản tối thiểu đó, tốc độ tiếp cận Go cũng là rất nhanh, một lập trình viên có thể nhanh chóng học được ngôn ngữ này và có thể dễ dàng bắt đầu phát triển các ứng dụng chất lượng trong vài tuần.&lt;/p&gt;

&lt;p&gt;Trên thực tế có thể gọi Go là một ngôn ngữ lập trình hướng đối tượng (OOP). Tuy nhiên cách tiếp cận hướng đối tượng của Go khác với các ngôn ngữ lập trình như C++, Java và C#. Trên lí thuyết Go không phải là một ngôn ngữ OOP chính thống. Không giống như các ngôn ngữ OOP hiện có, Go không hỗ trợ kế thừa và thậm chí không có từ khóa class, extends…. Nó sử dụng các thành phần thừa kế thông qua hệ thống kiểu đơn giản của nó(sử dụng nested struct chẳng hạn hoặc ưu tiên composition hơn inheritance).&lt;/p&gt;

&lt;p&gt;Thiết kế kiểu interface của Go cho thấy tính độc đáo của nó khi so sánh với các ngôn ngữ lập trình hướng đối tượng khác, Go không có từ khoá implement mà các implementation của một interface được tự ngầm định khi implement đủ các phương thức của interface.&lt;/p&gt;

&lt;p&gt;Vậy cuối cùng Go có phãi là một ngôn ngữ OOP? Câu trả lời là có thể có cũng có thể không. Ngôn ngữ Go bao gồm tất cả các quy tắc cần thiết để viết các ứng dụng bằng một phương pháp hướng đối tượng, nhưng nó không phải là một ngôn ngữ OOP hoàn chỉnh vì nó thiếu một số tính năng OOP truyền thống.&lt;/p&gt;

&lt;h3 id=&quot;static-language-với-hiệu-suất-cao&quot;&gt;Static language với hiệu suất cao&lt;/h3&gt;

&lt;p&gt;Go là static, compiled language với cú pháp giống gần như 70% ngôn ngữ C. Giống như C và C ++, nó tự động biên dịch code thành mã máy do đó có tốc độ cực kì nhanh.&lt;/p&gt;

&lt;p&gt;Phát triển phần mềm với một dynamic language mang lại cho chúng ta nhiều năng suất và sự thoải mái hơn một bởi vì bạn không phải lo lắng về các kiểu dữ liệu của các biến bạn sử dụng, tuy nhiên hiệu suất và khả năng maintain của các ứng dụng phần nào bị ảnh hưởng. Đôi khi việc debug của một ứng dụng được viết bằng một ngôn ngữ động rất khó khăn do chúng thiếu các kiểu an toàn, dễ xãy ra các runtime error. Gần đây chúng ta còn phãi sử dụng luôn static language cho mục đích check type cho ngôn ngữ động ví dụ như sử dụng TypeScript để đảm bảo an toàn cho kiểu dữ liệu, cuối cùng mới biên dịch ra code JavaScript chẳng hạn.&lt;/p&gt;

&lt;p&gt;Mặc dù ngôn ngữ tĩnh có thể cho ta sự an toàn và hiệu suất của kiểu dữ liệu, nhưng làm việc với chúng có thể ảnh hưởng đến năng suất phát triển ứng dụng và việc biên soạn các chương trình lớn có thể mất nhiều thời gian.&lt;/p&gt;

&lt;p&gt;Là một static, compiled language Go cho ta sự an toàn và hiệu suất tốt, nhưng chưa thực sự mang lại hiệu năng làm việc tốt cho lắm. 
chúng có thể ảnh hưởng đến năng suất phát triển ứng dụng và việc biên soạn các chương trình lớn có thể mất nhiều thời gian. Là ngôn ngữ tĩnh, ngôn ngữ biên dịch đôi lúc Go cũng có một số thiếu xót, đơn cử như Go không support Generic Type vì một số lí do về hiệu năng mà Go Team chưa tìm ra hướng giải quyết, cá nhân mình thấy việc thiếu xót generic trong một static language như Go thực sự là thật ức chế khi làm việc với các array, slice, map…Cũng có một số giải pháp khắc phục như sử dụng Code Generator, sài Higher-Order Functions, Closures và kể cả Reflect. Tuy nhiên vẫn chưa thực sự thoải mái như có thêm generic.&lt;/p&gt;

&lt;h3 id=&quot;concurrency---xử-lí-đồng-thời&quot;&gt;Concurrency - Xử lí đồng thời&lt;/h3&gt;

&lt;p&gt;Ngày nay phần cứng máy tính đã phát triển để có nhiều lõi CPU và nhiều sức mạnh hơn, nhưng sức mạnh của máy tính hiện đại không thể được tận dụng bằng cách sử dụng các ngôn ngữ lập trình chỉ support đơn core. Khi các ứng dụng được chạy trên các máy chủ công suất cao, có những vấn đề về hiệu suất mặc dù mới chỉ mới sử dụng có một ít CPU. Trong một số môi trường lập trình, concurrency và parallelism cho hiệu quả và hiệu năng tốt hơn, nhưng các tính năng này là một thư viện hay framework riêng biệt, chứ không phải là một tính năng tích hợp sẳn ở cấp độ ngôn ngữ. Do đó để lập trình concurrency hay parallelism đôi lúc lại làm tăng thêm sự phức tạp khi bạn viết các ứng dụng concurrent.&lt;/p&gt;

&lt;p&gt;Trong Go, concurrency được xây dựng sẳn và được thiết kế để viết các ứng dụng concurrent hiệu suất cao cho các máy tính hiện đại, có thể tận dụng multi proccessor. Concurrency là một trong những tính năng độc đáo của ngôn ngữ Go và nó được coi là điểm mạnh lớn nhất của ngôn ngữ này. Go hổ trợ việc xử lí concurrency dựa trên &lt;a href=&quot;https://en.wikipedia.org/wiki/Communicating_sequential_processes&quot;&gt;CSP Model&lt;/a&gt;(Communicating sequential processes) mà hai chức năng chính để implement model đó là goroutines và channel.&lt;/p&gt;

&lt;p&gt;Gorountine có thể được hiểu là một thread gọn nhẹ(chỉ tốn khoản 2KB stack size và có thể scale lên đến 1GB).&lt;/p&gt;

&lt;p&gt;Go cung cấp các channel về bản chất là thằng có thể quản lí các goroutine và context switching(thông qua các câu lệnh slect) giữa chúng đồng thời cho phép giao tiếp giữa các goroutines và đồng bộ hóa các hành động của chúng. Với các channel, ta có thể gửi dữ liệu qua lại giữa các goroutine khác nhau. Channel cũng cung cấp mức độ đồng bộ hóa cao hơn giữa các goroutines và đảm bảo rằng hai goroutines đang chạy trong một state xác định.&lt;/p&gt;

&lt;p&gt;Nhiều ngôn ngữ lập trình cung cấp hỗ trợ viết các chương trình đồng thời, nhưng chúng giới hạn trong việc giao tiếp và đồng bộ hóa giữa các threads đang được thực thi. Và hầu hết các ngôn ngữ hiện tại cung cấp hỗ trợ concurrency thông qua framework chứ đa phần không phải là một tính năng tích hợp trong ngôn ngữ, vì vậy nó làm hạn chế khi concurrency được implemented với các ngôn ngữ khác. Build-in Concurrency là lý do chính cho việc sử dụng Go như một ngôn ngữ để xây dựng các hệ thống phần mềm hiệu quả cao với hiệu năng cao hơn.&lt;/p&gt;

&lt;h3 id=&quot;go-biên-dịch-nhanh-hơn&quot;&gt;Go biên dịch nhanh hơn&lt;/h3&gt;

&lt;p&gt;Một trong những thách thức khi viết các ứng dụng C/C ++ là thời gian cho việc biên dịch chương trình thực sự lâu, điều này rất khó chịu đối với Dev khi làm việc với các ứng dụng lớn với C và C ++. Go là một ngôn ngữ đã giải quyết được vấn đề đó. Trình biên dịch của Go thực sự rất hiệu quả cho việc biên dịch các chương trình một cách nhanh chóng; một ứng dụng lớn với Go có thể được biên dịch chỉ trong vài giây, do đó Go thực sự thu hút các Dev C/C++ chuyển qua.&lt;/p&gt;

&lt;h3 id=&quot;go-là-ngôn-ngữ-đa-năng&quot;&gt;Go là ngôn ngữ đa năng&lt;/h3&gt;

&lt;p&gt;Hiện tại có rất nhiều ngôn ngữ khác nhau được dùng để phát triển các loại ứng dụng khác nhau với ưu nhược điểm khác nhau.&lt;/p&gt;

&lt;p&gt;C và C++ thường được sử dụng cho các chương trình hệ thống và cho các hệ thống đòi hỏi hiệu suất cao nhưng làm việc với C/C++ ảnh hưởng đến năng suất phát triển ứng dụng.&lt;/p&gt;

&lt;p&gt;Một số ngôn ngữ lập trình chẳng hạn như Ruby, Node.js và Python, cho phép phát triển ứng dụng nhanh chóng và tăng năng suất ví dụ như nền tảng Node.js tốt cho việc xây dựng các API JSON và các ứng dụng real-time, nhưng nó sẽ thất bại khi các xử lí các CPU-intensive programming tasks(tác vụ tính toán chuyên sâu như for-loop này nọ chẳng hạn).&lt;/p&gt;

&lt;p&gt;Một số ngôn ngữ được dùng để xây dựng native mobile app như Objective C hay Swift tuy nhiên hai ngôn ngữ này dường như chỉ có thể làm mobile.&lt;/p&gt;

&lt;p&gt;Một số ngôn ngữ được dùng cho nhiều trường hợp sử dụng như lập trình các network system, distributed system, web app, xây dựng ứng dụng doanh nghiệp(ERP), mobile app…&lt;/p&gt;

&lt;p&gt;Thì Go là ngôn ngữ làm được tất cả điều đó, nó có thể được dùng để xây dựng một loạt các loại ứng dụng bao gồm hệ thống đòi hỏi hiệu năng cao, mobile app, web app…đặc biệt nó được sử dụng để xây dựng các Enterprise Application, các hệ thống back-end mạnh mẻ. Go cung cấp hiệu suất cao đồng thời vẫn giữ được năng suất cao cho việc phát triển ứng dụng nhờ thiết kế đơn giản và thực dụng. Hệ sinh thái Go (bao gồm Go tool, thư viện chuẩn Go và thư viện của bên thứ ba đi) cung cấp các công cụ và thư viện thiết yếu để xây dựng một loạt các ứng dụng Go. Dự án Go Mobile hỗ trợ xây dựng ứng dụng di động cho cả nền tảng Android và iOS, cho phép nhiều cơ hội hơn với Go.&lt;/p&gt;

&lt;p&gt;Trong thời đại điện toán đám mây, Go là một ngôn ngữ lập trình hiện đại có thể được sử dụng để xây dựng các ứng dụng hệ thống; các ứng dụng phân tán(distributed applications); networking system; game; ứng dụng web; RESTful services; back-end servers; các ứng dụng di động. Go là sự lựa chọn của nhiều hệ thống mới nổi trội như Docker và Kubernetes. Phần lớn các công cụ về hệ sinh thái Docker đang được viết bằng Go.&lt;/p&gt;

&lt;p&gt;Chúng ta là dân TIN-HỌC, nghĩa là tin đã rồi mới học, rõ ràng nhìn vào profile nổi trội của Go có lẻ đã thấy được sức mạnh và xu hướng của Golang và cơ bản nắm được những đặc điểm chính của Golang. OK tin rồi thì học và sử dụng thôi nào…..&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="nodejs" /><category term="eventloop" /><category term="singlethreaded" /><summary type="html">Dạo gần đây Golang nổi lên mạnh mẻ như một ngôi sao trong làng lập trình hệ thống với các lợi ích, chức năng cực kì powerful. Chúng ta cùng lượt qua các điểm đáng chú ý của Go để xem xem vì sao nên cân nhắc chọn Go trong dự án của mình nhé.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry></feed>