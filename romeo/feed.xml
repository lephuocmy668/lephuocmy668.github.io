<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://romeo.vn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://romeo.vn/" rel="alternate" type="text/html" /><updated>2019-03-12T10:42:29-05:00</updated><id>https://romeo.vn/feed.xml</id><title type="html">Le Phuoc My</title><subtitle>A blog about technology and stuff related</subtitle><entry><title type="html">Kafka note</title><link href="https://romeo.vn/kafka-note/" rel="alternate" type="text/html" title="Kafka note" /><published>2018-09-16T21:10:00-05:00</published><updated>2018-09-16T21:10:00-05:00</updated><id>https://romeo.vn/kafka-note</id><content type="html" xml:base="https://romeo.vn/kafka-note/">&lt;h2 id=&quot;tại-sao-phãi-sài-kafka&quot;&gt;Tại sao phãi sài kafka?&lt;/h2&gt;
&lt;p&gt;Chúng ta bắt đầu bằng việc có một bài toán như sau: Nếu có 1 triệu người đặt hàng trên trang web của bạn cùng lúc nó có thể tạo ra một số vấn đề concurrency và việc đảm bảo việc sử lí các yêu cầu theo thứ tự ngay lập tức chúng ta nghix đến việc xếp các order vào một message queue để có thể đảm bảo thứ tự của chúng và kiểm soát được số lượng được xử lí đồng thời đó, kafka là một trong những lựa chọn tốt giúp chúng ta xử lí được bài toán trên.&lt;/p&gt;

&lt;h3 id=&quot;đối-với-mô-hình-event-driven&quot;&gt;Đối với mô hình event driven:&lt;/h3&gt;
&lt;p&gt;Các ngôn ngữ lập trình truyền thống thường dựa trên thread và threadpools để xử lí các tác vụ đồng thời đơn cử như là Java theo mặc định mỗi thread thường chiếm 1MB trong stack size(trên JVM 64bit) và chúng ta có thể config stack size tuỳ ý. Việc cấp phát một thread thường khá đắt đỏ trong CPU cho nên chúng ta thường sẻ phãi config size của threadpools trước, mỗi khi có request tới, web server sẻ pick một thread trong threadpools và kêu nó xử lí reuqest,các thread trên sẻ xử lí các tác vụ một cách song song. Nếu bạn giữ các giá trị như mặc định thì nếu config 1k thread trong thread pool đồng nghĩa với việc bạn sẻ dùng hết gần 1G Ram.&lt;/p&gt;

&lt;p&gt;Đối với hệ thống lớn chúng ta sẻ gặp phãi hai vấn đề về thread đó là stack size và threadpools size. Nếu config stack size mỗi thread nhỏ xuống thì sẻ tiết kiệm được nhiều bộ nhớ nhưng khi một thread nào đó đòi hỏi tính toán nhiều thì dễ gây ra stack overflow. Cũng như vậy đối với threadpools size, khi chúng ta giữ một lượng lớn thread trong threadpool thì memory cost và switching context cost sẻ là rất cao và hệ thống sẻ trở nên khó kiểm soát, ngược lại khi giữ một số lượng thread nhỏ hơn thì lại làm giảm tính available của hệ thống.&lt;/p&gt;

&lt;p&gt;Nếu hệ thống chúng ta có các tác vụ tính toán mất thời gian, tốn tài nguyên, khó thể ước tính thời gian và tài nguyên cho mỗi yêu cầu nhưng lại không nhất thiết phãi response ngay lập tức thì chúng ta có thể sử dụng mô hình trên. Khi thiết kế hệ thống dựa trên mô hình event driven thì Kafka là một lựa chọn khá tốt để xử lí các event. Bạn có thể sử dụng kafka để lưu trử các request message và các worker xử lí request sau đó.&lt;/p&gt;

&lt;h3 id=&quot;đối-với-kiến-trúc-microservice&quot;&gt;Đối với kiến trúc microservice&lt;/h3&gt;
&lt;p&gt;Khi làm việc với kiến trúc Microservice chúng ta thường đối mặt với các vấn đề liên quan đến internal communication và xử lí lỗi trong communication giữa các services. Những dạng giao tiếp thường thấy có thể là call trực tiếp(thông qua http rest/gRPC/thrift….), giao tiếp thông qua việc sử dụng asynchronous messaging, và có thể cao hơn đó là dùng các giao thức đặc biệt dành riêng cho hệ thống. Tuy nhiên đối với các hệ thống phãi xử lí một lượng lớn request trên kiến trúc microservice cũng như kiến trúc monolic truyền thống thì những lỗi như lỗi mạng, timeout, lỗi do bug….là điều không thể tránh khỏi. Message queue nói chung và kafka nói riêng giúp hệ thống của chúng ta xử lí các lỗi trên một cách hiệu quả bằng cách lưu lại trạng thái các request lúc nào xử lí xong mới xoá request đó đi bất cứ lỗi nào xãy ra thì chúng ta đều có thể xử lí lại request đó.
Trong kiến trúc microservice thì chúng ta thường sử dụng nhiều ngôn ngữ khác nhau tuỳ thuộc vào mục đích từng service, hơn nữa việc duy trì dependencies cứng nhắc giữa các services đôi lúc không cần thiết. Bằng cách giao tiếp thông qua kafka giữa các services với các format hợp lí và khớp lệ bạn có có thể tách biệt được dependencies giữa các service, mỗi thành phần của hệ thống đều có thể phát triển, mở rộng một cách độc lập.&lt;/p&gt;

&lt;h2 id=&quot;kiến-trúc-kafka&quot;&gt;Kiến trúc kafka:&lt;/h2&gt;
&lt;p&gt;Cơ chế hoạt động cơ bản của Kafka hình dung đơn giản giống như Logs system, các log record được lưu lên đĩa và sắp xếp theo thứ tự thời gian, Kafka tổ chức phân loại các messages theo khái niệm Topic hình dung giống như tag trong việc quản lí Log của chúng ta. Mỗi khi cài đặt kafka một trong những việc ta cần làm là setup nơi mà log sẻ được lưu xuống-url của log.dir, mỗi topic sẻ được map với thư mục con bên trong thư mục log của chúng ta và cũng có thêm nhiều thư mục con nữa đó là các thư mục topic partitions với tên thư mục format là topic-name_partition-number, bên trong mỗi thư mục sẻ là file log nơi mà message tới sẻ được append vào. Mỗi Topic có một nhiều Partitions và mỗi Partition là một list các messages, khi một message được chia sẻ lên Kafka theo Topic, message sẻ được gửi vào một Partition của Topic, việc lưu message xuống Partition nào được quyết định bởi các producers. Nếu ta muốn message xuống Partition cụ thể nào đó thì ta phãi set partition_key cho message đó ứng với Partition ta muốn message xuống, nếu không mặc định message sẻ được phân phối theo giải thuật round-robin.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicA_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicB_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topicC_2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Như trên chúng ta có thể thấy rằng topic A có 1 partition, topic B có 2 partitions và C có 3 partitions. Vậy partition đó là gì, dùng để làm gì? Partitions là một phần quan trọng trong thiết kế của kafka. Các partitions chia luồng message đến một topic vào các luồng song song và đó là chìa khoá giúp Kafka achieves một lượng message khổng lồ. Tuy nhiên thứ tự message đến từ các partitions khác nhau không được đảm bảo, Kafka chỉ đảm bảo thứ tự message trong cùng một partition, do đó trong trường hợp chúng ta cần đảm bảo thứ tự message cho nhiều tác vụ nào đó, chắc chắn các message xử lí các tác vụ đó phãi được sắp xếp vào cùng 1 topic và cùng một partion_key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mỗi Partition có thể được phân tán trên nhiều máy và mỗi máy như thế được gọi là một Broker, mỗi Broker có thể có 0 1 hoặc nhiều Partitions của cùng 1 Topic hoặc thậm chí các topic khác nhau.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka hổ trợ Replication để đảm bảo tính high-availability và tính fault-tolerance. Mỗi partition có thể có nhiều bản replicas tuỳ thuộc vào số replication factor mà ta config.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ có các leader partitions mới được cho phép nhận message sau đo mới đồng bộ lên các replicas partitions khác và khi một leader partition chết thì một trong những replica của partition được chọn để làm leader partition cho đến khi partition kia sống lại thì nó trở thành replica và phãi fetch lại tất cả data chưa đồng bộ được trong quá trình chết đi từ các partition khác. Kafka dùng ZOOKEEPER để handle chuyện đó, Kafka dùng nó để thực hiện việc leadership electron các kafka broker và các cặp Topic Partition, ZOOKEEPER giúp quản lí việc Service Discovery cho các Kafka Brokers từ các cluster, handle các trường hợp broker nào join vào, broker nào chết đi, topic nào được add vào topic nào bị remove đi….
Rõ ràng kafka thoã mãn hai đặc điểm đó là High-availability và Durability.&lt;/p&gt;

&lt;p&gt;Cách hoạt động của Kafka producers khá đơn giản, ban đầu các producers phãi fetch các metadata lên ví dụ như chúng cần biết có các topics nào đang tồn tại? có bao nhiêu partition mỗi topic đang có? leader broker hiện tại của mỗi partition là node nào? host và port của mỗi broker đó là sao? Sau đó chúng làm việc trực tiếp với các broker khác nhau mà không có một sự điều phối nào.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế đó kafka producers đã loại bỏ triệt để vấn đề write-bottleneck, đồng thời giúp cho mỗi broker nhận được một số lượng messages hợp lí, dễ dàng mở rộng tuyến tính, khi muốn mở rộng chỉ cần thêm partition và broker vào.&lt;/p&gt;

&lt;p&gt;Như vậy nhìn chung thì Kafka producers tương đối đơn giản tuy nhiên đối với Kafka consumers thì phức tạp hơn nhiều. Cũng giống như Kafka producer, Kafka consumers bắt đầu các hoạt động của chúng bằng việc fetch các metadata, mỗi consumer có thể kết nối tới nhiều brokers và đọc từ nhiều replicas. Mỗi broker xử lí một tập hợp các partition của các topics mà consumer subsribe tới cùng lúc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nhờ thiết kế đó mà workload giữa các broker được cân bằng đồng thời giảm thiểu vấn đề read-bottleneck. Hơn nữa mỗi consumer có nhiều replicas để đọc giúp tăng tính availability và cân bằng workload giữa các consumer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tuy nhiên chỉ với thiết kế đó thì vẫn chưa đảm bảo tính scale, khái niệm consumer group sinh ra giúp chúng ta dễ dàng scale các consumers. Theo đó mỗi consumer sẻ thuộc về một consumer group hay nói cách khác một consumer group sẻ chứa các consumer và message sẻ được phân phát đến tất cả consumer group, mỗi member của group sẻ xử lí message từ một hoặc nhiều partitions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-08-26-kafka-note/7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Với thiết kế này, mỗi consumer có thể xử lí message từ nhiều partitions, đảm bảo cover hết tất cả các partition cũng như thứ tự xử lí message trong mỗi partition đồng thời cân bằng tải giữa các consumers trong cùng một group. Khi chúng ta muốn scale lên chỉ cần tăng số brokers, tăng số partitions và tăng số consumers. Nhìn lại một lần nữa vào ví dụ trên, chúng ta có thể thấy rằng thiết kế trên cho phép mỗi consumer có thể xử lí nhiều partitions cùng lúc chứ không cho phép nhiều consumers cùng lúc xử lí một partition cho nên giả dụ như chúng ta có 5 partitions nhưng có đến 6 cunsumers thì hiển nhiên 1 consumer ngồi chơi làm phí phạm tài nguyên hệ thống, cho nên khi scale thì nên lưu ý rằng số consumers luôn bé hơn hoặc bằng số partitions mà tốt nhất là bằng nhau thì hơn.&lt;/p&gt;

&lt;p&gt;Updating….&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="kafka" /><category term="event-driven" /><category term="microservice" /><summary type="html">Tại sao phãi sài kafka? Chúng ta bắt đầu bằng việc có một bài toán như sau: Nếu có 1 triệu người đặt hàng trên trang web của bạn cùng lúc nó có thể tạo ra một số vấn đề concurrency và việc đảm bảo việc sử lí các yêu cầu theo thứ tự ngay lập tức chúng ta nghix đến việc xếp các order vào một message queue để có thể đảm bảo thứ tự của chúng và kiểm soát được số lượng được xử lí đồng thời đó, kafka là một trong những lựa chọn tốt giúp chúng ta xử lí được bài toán trên.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/2018-07-16-nhung-van-de-kafka-giai-quyet/1.png" /></entry><entry><title type="html">Introduce GoKit</title><link href="https://romeo.vn/introduce-gokit/" rel="alternate" type="text/html" title="Introduce GoKit" /><published>2018-08-06T20:15:00-05:00</published><updated>2018-08-06T20:15:00-05:00</updated><id>https://romeo.vn/introduce-gokit</id><content type="html" xml:base="https://romeo.vn/introduce-gokit/">&lt;p&gt;Golang là ngôn ngữ tuyệt vời cho Microservices về hiệu xuất lẫn sự thân thiện đối với developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất có ích và làm cho việc phát triển phần mềm với Go trở nên dễ dàng hơn. Gokit là một bộ toolkit tuyệt vời cho việc xây dựng các microservices với Go, cung cấp cho chúng ta các quy tắc, ý tưởng về kiến trúc nhằm giúp developer tập trung hơn vào việc phát triển business logic và tránh khỏi các mối quan tâm chung về operational lẫn infrastructural.&lt;/p&gt;

&lt;p&gt;Gokit là bộ toolkit nhẹ nhàng nhưng cung cấp gần như đầy đủ các thư viện đồ chơi cho một hệ thống service mesh, từ Logging, Metrics, Tracing, Rate-Limiting, Circuit Breaking cho đến Service Discovery, Pub/Sub…&lt;/p&gt;

&lt;p&gt;Tuy ban đầu được giới thiệu là dùng cho việc build các microservices nhưng trong qúa trình làm việc mình thấy Gokit dường như phù hợp với monolith không kém. Với Gokit, developer cần tuân theo một số nguyên tắc sau:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Phãi nắm bắt và tuân thủ các nguyên tắc thiết kế như SOLID, DDD, Clean Architecture và áp dụng chặt chẻ.&lt;/li&gt;
  &lt;li&gt;Các interfaces được sử dụng như là các quy ước, không có global state, declarative composition và các Dependencies phãi rõ ràng.&lt;/li&gt;
  &lt;li&gt;Composition over inheritance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kiến-trúc-của-gokit&quot;&gt;Kiến trúc của Gokit:&lt;/h3&gt;
&lt;p&gt;Gokit được chia làm ba layer chính đó là&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Transport layer&lt;/li&gt;
  &lt;li&gt;Endpoint layer&lt;/li&gt;
  &lt;li&gt;Service layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tầng Service là tầng quan trọng nhất, nơi mà developer quan tâm nhất, là nơi chứa các domain của ứng dụng cũng như implementation của tất cả business logic cho ứng dụng, nó tách biệt hoàn toàn với các phần còn lại. Hai tầng Transport và Endpoint nằm ở tầng Interface của Clean Architect như bài trước mình đã giới thiệu về Clean Architecture https://romeo.vn/clean-architecture/. Tầng transaport được liên kết với các giao thức cụ thể như Http, gRPC, Pub/Sub nhằm lấy request từ client và encoding/decoding request. Trong Gokit, RPC là giao thức chính được ưu tiên nhất, mỗi service method trong Gokit sẻ được chuyển đổi thành một endpoint để giao tiếp giữa client và server. Mỗi endpoint sẻ expose một service method ra ngoài bằng cách sử dụng Transport liên kết với một giao thức Transport cụ thể như Http Rest/gRPC hay Pub/Sub.&lt;/p&gt;

&lt;p&gt;Một thành phần khác không kém phần quan trọng trong Gokit đó là các &lt;strong&gt;Middlewares&lt;/strong&gt;. Gokit thực hiện nghiêm ngặt việc separate các concerns, các &lt;strong&gt;cross-cutting concern components&lt;/strong&gt; của tầng services và endpoints được implement bằng việc sử dụng các Middlewares. Middleware là một thành phần mạnh mẻ nhằm bọc các services và endpoints lại để thêm các các &lt;strong&gt;cross-cutting concern components&lt;/strong&gt; như Logging, Circuit Breakers, Rate Limiting, Load Balancing, hay Distributed tracing…&lt;/p&gt;

&lt;p&gt;Dưới đây là một hình ảnh mô tả kiến trúc của Gokit mình copy từ trang web chính thức của Gokit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gokit.io/faq/onion.png&quot; alt=&quot;Atom&quot; /&gt;&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="golang" /><category term="gokit" /><category term="microservices" /><summary type="html">Golang là ngôn ngữ tuyệt vời cho Microservices về hiệu xuất lẫn sự thân thiện đối với developer. Sự phát triển mạnh mẽ của cộng đồng Gopher ngày càng mang đến cho chúng ta những Open Source rất có ích và làm cho việc phát triển phần mềm với Go trở nên dễ dàng hơn. Gokit là một bộ toolkit tuyệt vời cho việc xây dựng các microservices với Go, cung cấp cho chúng ta các quy tắc, ý tưởng về kiến trúc nhằm giúp developer tập trung hơn vào việc phát triển business logic và tránh khỏi các mối quan tâm chung về operational lẫn infrastructural.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Clean Architecture</title><link href="https://romeo.vn/clean-architecture/" rel="alternate" type="text/html" title="Clean Architecture" /><published>2018-07-20T09:01:00-05:00</published><updated>2018-07-20T09:01:00-05:00</updated><id>https://romeo.vn/clean-architecture</id><content type="html" xml:base="https://romeo.vn/clean-architecture/">&lt;p&gt;Trước khi đi vào nội dung chính của bài viết này, mình xin nói qua về quá trình mình đã tiếp cận với các kiểu kiến trúc trong việc xây dựng các ứng dụng web. Điểm xuất phát của mình dường như nó không đi theo con đường “chính đạo” như các bạn các anh chị đi trước thường tiếp cận với Java, C#, Scala,…và đa số những bạn xuất phát theo con đường Java thường có cái nhìn cũng như tư duy về kiến trúc từ sớm, mình thì ngược lại, xuất phát một cách quán tính, mình bắt đầu sự nghiệp coder với một dự án startup với công nghệ chính là Node.js, code không theo một paradigm cụ thể nào cả, OOP cũng không hẳn là OOP, Functional cũng không hẳn là Functional, Functional Reactive cũng không ra Functional Reactive, qua một thời gian thì mọi thứ trở nên rối hết cả lên và dường như không còn cơ hội cứu chữa, sau một thời gian dài code quán tính thì không những không xây dựng được tư duy kiến trúc, tư duy tổ chức mà còn làm mình “hư tay hư chân” và khó nhồi nhét tư duy design sau này. Thật may lúc đó mình có cơ hội cho công việc mới, giai đoạn đầu bắt đầu công việc mới mình được yêu cầu tìm hiểu và áp dụng Clean Architect vào dự án với Golang với một tài liệu duy nhất là bài viết này https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html. Ôi thôi một thằng coder đang trong guồng ảo tưởng, tư duy tổ chức kém, kém design partern, kém OOP, kém tất cả và quả thực Clean Architecture đối với mình lúc đó quả là một bài học quá khó, nó yêu cầu phãi xâu chuổi tất cả kiến thức tổ chức code như OOP, nó yêu cầu những nền tảng cơ bản từ sự hiểu biết về các Programming paradigms, cho đến các Design Parterns ở OOP cũng như ở các paradigms khác, tiếp đến mới là các Design Principles như SOLID Principles, Component Principles rồi mới đến các nguyên tắc, các mẫu xây dựng một kiến trúc cho phần mềm. Không chỉ là Clean Architecture mà tất cả các kiến trúc khác đều dựa trên những nguyên tắc chung đó mà xây dựng nên. Chính vì vậy đến bây giờ đây, sau một năm với nhiều may mắn được làm việc với các dự án từ Golang đến Typescript mình tóm tắt lại quá trình mình tiếp cận với Clean Architecture nói riêng và các quy tắc lập trình, tổ chức code nói chung cũng và cũng là dịp để mình ôn lại kiến thức, kĩ năng lẫn thói quen nhằm ghi nhớ sâu hơn hoặc ai đó đang tìm hiểu hoặc đang implement Clean Architecture vô tình đọc bài này có thể cảm nhận và phản biện giúp mình cũng cố kiến thức hơn.&lt;/p&gt;

&lt;h2 id=&quot;1-vì-sao-phãi-tìm-hiểu-các-software-architecture-hay-nói-cách-khác-các-software-architecture-sinh-ra-làm-gì-vì-sao-các-software-engineer-chúng-ta-phãi-tìm-hiểu-chúng&quot;&gt;1. Vì sao phãi tìm hiểu các Software Architecture hay nói cách khác các Software Architecture sinh ra làm gì? Vì sao các Software Engineer chúng ta phãi tìm hiểu chúng?&lt;/h2&gt;

&lt;p&gt;Như chúng ta đều biết thì với yêu cầu của việc phát triển phần mềm thì việc phát triển đội ngủ về số lượng luôn là điều hiển nhiên. Tuy nhiên sự phát triển của số lượng chưa hẳn sẻ kéo theo sự phát triển chất lượng và tốc độ phát triển phần mềm. Một sự thật đớn đau là theo các con số thống kê thì đa số phần mềm khi phát đến một mức nào đó thì cho dù tăng thêm số lượng engineer đến bao nhiêu cũng không thể kéo tốc độ cũng như chất lượng lên được nữa và có thể là tốc độ và chất lượng lại đi xuống, tức nhiên là chẳng ai muốn điều đó xãy ra, ai cũng luôn luôn cố gắn phát triển cả nhưng với việc tổ chức kém code base ban đầu, việc out of control chất lượng code, độ phình to của software mà không có một chiến lược tái cấu trúc hợp lí….tất cả các nguyên nhân đó tạo ra một đống hổn độn mà không một cá nhân nào trong đó không muốn “đập đi làm lại cmn đi” ^^. Các Software Architecture sinh ra để giải quyết bài toán đầu tiên về tổ chức cũng như độ dễ của việc duy trì một code base sạch sẻ gọn gàn, nhằm giảm tối đa resource để xây dựng phát triển cũng như maintain hệ thống phần mềm đó.&lt;/p&gt;

&lt;h2 id=&quot;2-các-programming-paradigms&quot;&gt;2. Các Programming Paradigms:&lt;/h2&gt;
&lt;p&gt;Như chúng ta đều biết thì các Architectures đều bắt đầu từ code cho nên các Paradigms sẻ nói cho chúng ta biết cách tổ chức nào sẻ được sử dụng, đến nay thì mình chỉ mới tiếp cận được 3 Programming Paradigms nên có thể nêu lên quan điểm cá nhân của mình như sau:&lt;/p&gt;

&lt;h4 id=&quot;object-oriented-programming&quot;&gt;Object Oriented Programming:&lt;/h4&gt;
&lt;p&gt;Đây dường như là Paradigm thịnh hành nhất hiện tại với các ưu điểm đáng kể&amp;gt; Việc hiểu rõ các tính chất cũng như các nguyên tắc design trong OOP giúp chúng ta dễ tổ chức và phát triển và maintain, dễ module hoá, tính reusable cao và cũng như cho phép chúng ta dễ dàng phát triển các module song song. Tuy nhiên về nhược điểm OOP cũng có nhiều hạn chế. Về coding style, OOP nhìn chung là quá imperative, tập trung trả lời câu hỏi “How?”(làm sao để làm điều đó) hơn là câu hỏi “What?”(chúng ta muốn gì ở đây), khi đọc code chúng ta khó nhanh chóng hiểu được người viết muốn gì. Nhược điểm thứ hai đó là về vấn đề race condition, trong concurrent programming đây là vấn đề thường gặp và rất tốn công giải quyết, việc chia sẻ trạng thái trong lập trình hướng đối tượng là một trong các nguyên nhân chủ yếu dẫn đến race condition và khiến ta khó debug cũng như fix bug.&lt;/p&gt;

&lt;h4 id=&quot;functional-programmingfp&quot;&gt;Functional Programming(FP):&lt;/h4&gt;
&lt;p&gt;Những năm gần đây FP nổi lên như một xu hướng mà các lập trình viên đang theo đuổi và dần chuyển đổi, không chỉ mang lại những trải nghiệm mới mà FP xử lí một số vấn đề hạn chế của OOP.&lt;/p&gt;

&lt;p&gt;Về coding style nhìn chung FP theo trường phái declarative, tập trung trả lời câu hỏi “What?”(chúng ta muốn gì), giúp chúng ta nhanh chóng hiểu code trong lúc maintain, fix bug.&lt;/p&gt;

&lt;p&gt;Việc sử dụng các pure functions mang lại cho chúng ta các functions đáng tin cậy hơn, không một side effect nào xãy ra, các hàm luôn luôn chỉ trả đúng kết quả mà chúng ta mong đợi.&lt;/p&gt;

&lt;p&gt;Về mặt Architecture, tính IMMUTABILITY là tính chất rất quan trọng mà chúng ta cần xem xét, tại sao chúng ta lại quan tâm nhiều đến tính chất này?&lt;/p&gt;

&lt;p&gt;Đứng ở vị trí là một Backend Engineer ngoài các vấn đề thuật toán, architectures/design thì mình coi trọng nhất các vấn đề về concurency như race condition, deadlock conditions và concurrent update, mà tất cả chúng sinh ra do đâu? do tính mutable của biến chứ đâu nữa. Chúng ta sẻ không dính bất cứ race condition hoặc concurrent update nào khi không có một biến/shared memory nào được cập nhật, chúng ta sẻ không dính bất cứ deadlocks nào nếu không có mutable locks, nói cách khác tất cả vấn đề concurrency, tất cả vấn đề chúng ta đối mặt trong hệ thống multiple threads/multiple processors sẻ không bao giờ xãy ra nếu không có bất cứ mutable variables nào. Ở vị trí Backend Enginner chúng ta luôn muốn thiết kế một hệ thống mạnh mẻ với sự có mặt của multi threads multi processors sau đó câu hỏi mà chúng ta tự hỏi chính mình đó là tính immutability có luôn được thực hiện được hay không? Câu trả lời tức nhiên sẻ là không rồi, tuy nhiên chúng ta sẻ có những kĩ thuật nhằm phân tích các thành phần mutable và các thành phần immutable sau đó tách biệt chúng ra. Các thành phần immutable bắt buộc chúng ta phãi implement một cách purely functional và các thành phần mutable bắt buộc chúng ta phãi cân nhắc sử dụng một số loại transaction memory để tránh khỏi vấn đề concurrent updates và race conditions. Tuy nhiên nó vẫn chưa được bảo vệ hoàn toàn khỏi vấn đề concurrent updates và deadlocks khi có quá nhiều biến phụ thuộc xuất hiện, khi đó chúng ta lại phãi phân tách và chuyển các thành phần mutable thành các thành phần immutable nhiều nhất có thể và tập trung đẩy càng nhiều tài nguyên nhất có thể vào các thành phần immutable. Ngoài ra việc thay đổi, tận dụng sức mạnh xử lí của hệ thống máy tính hiện đại kết hợp cùng các kĩ thuật xử lí theo event, cron job,…. có thể giúp chúng ta giải quyết phần nào hiệu quả các vấn đề trên.&lt;/p&gt;

&lt;p&gt;Ở Paradigm này mình sẻ không nêu nhược điểm vì mình là fan cuồng của Functional mà ^^.&lt;/p&gt;

&lt;h4 id=&quot;reactive--functional-reactive-programmingfrp&quot;&gt;Reactive &amp;amp; Functional Reactive Programming(FRP):&lt;/h4&gt;

&lt;p&gt;Đối với hầu hết các lập trình viên Javascript thì đây là một Paradigm không quá xa lạ, là sự hợp thành của 2 Paradigms Functional và Reactive(Events/Data stream Driven, Push, Asynchronous).&lt;/p&gt;

&lt;p&gt;Đây là một Paradigm giúp chúng ta code Declarative hơn, dễ hiểu hơn theo hướng event, giúp đơn giản hoá việc xử lí bất đồng bộ đồng thời tránh đi việc gọi quá nhiều callback gây callback hell hoặc dùng promise/async-await mà quên đi tính event driven khi code. Ngoài ra đây cũng là một Paradigm giúp engineer xử lí concurent với một mô hình khác(event driven) ở mức low-level thông qua các khái niệm như observables, observers, operators, scheduler….&lt;/p&gt;

&lt;p&gt;Ở Paradigm này mình cũng sẻ không nêu nhược điểm vì mình cũng mê hơn OOP ^^.&lt;/p&gt;

&lt;h2 id=&quot;3các-design-principles&quot;&gt;3.Các design principles:&lt;/h2&gt;
&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng việc clean code, nó cũng giống như việc xây nhà, khi bắt đầu điều tiên quyết chúng ta cần có đó là những viên gạch tốt, những viên gạch đã không tốt thì cho dù kiến trúc tổ chức tốt đến nhừng nào cũng chỉ là trên bản vẻ mà thôi, khi xây nên hoàn toàn dễ dàng sụp đổ. Một mặt khác khi bạn đã có các viên gạch đủ tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn. 
Để cấu nên một toà nhà lớn chúng ta nên chia nhỏ phát triển từng components bằng cách abstract hoá lên rồi lại separate ra một cách thích hợp đê tạo thành các components nhỏ dễ cho việc quản lí tái, tái sử dụng hay gỡ bỏ khi cần. Các Design Principles sinh ra nhằm giúp chúng ta thực hiện việc đó ở mức độ hight level và ở mức độ mid-level/low-level như việc tổ chức tốt các thành phần nhỏ từ đơn vị nhỏ như ghép nối các viên gạch thành cấu trúc từng bức tường, cho chúng ta biết cách xắp xếp các hàm, các cấu trúc dữ liệu vào các class, các struct và kết nối chúng lại với nhau để xây dựng nên các module hoàn chỉnh dễ dàng tiếp nhận sự thay đổi, dễ hiểu cho người mới, dễ sử dụng lại. Các Principles phãi kể đến như Component Principles, SOLID Principles,… Các bạn có thể xem lại SOLID Principles tại đây https://romeo.vn/solid-principle/ .&lt;/p&gt;

&lt;h2 id=&quot;4-clean-architect&quot;&gt;4. Clean Architect:&lt;/h2&gt;

&lt;p&gt;Clean Architect là gì cơ chứ? Chẳng qua là tập hợp các principles, partern nhằm separate các components/dependencies/concerns để chia phần mềm thành nhiều lớp và tổ chức các lớp đó sao cho thoả mãn các yêu cầu chung của một kiến trúc có thể gọi là “SẠCH”, một số yêu cầu của một kiến trúc gọi là sạch phãi kể đến là:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Độc lập với các Frameworks: Kiến trúc phần mềm là không phụ thuộc vào bất cứ Framework/Tool-kit nào, các Frameworks có sẳn sinh ra nhằm giúp chúng ta một phần nào đó trong việc tổ chức hệ thống chứ không nhất nhất là chúng ta cần gì cũng kéo Framework vào để rồi phãi nhồi nhét nhiều thứ quy tắc rối rắm mà mỗi Framework yêu cầu.&lt;/li&gt;
  &lt;li&gt;Dễ test: Các thành phần trong phần mềm của chúng ta phãi dễ test mà không phãi phụ thuộc vào interface(UI/console UI), database hay bất cứ thành phần nào.&lt;/li&gt;
  &lt;li&gt;Độc lập với UI hay bất cứ interface nào: Các interface hổ trợ người dùng có thể thay đổi một cách dễ dàng mà không ảnh hưởng đến phần còn lại của hệ thống. Chẳng hạn, một giao diện web có thể được thay đổi thành giao diện command mà không làm ảnh hưởng đến các business rule.&lt;/li&gt;
  &lt;li&gt;Độc lập với Database, bạn có thể thay đổi từ Oracle hoặc Sql Server thành Mongo, BigTable, CouchDB, Cassandra hoặc bất kỳ hệ quản trị cơ sở dữ liệu nào mà không làm ảnh hưởng đến Business Rule ban đầu.&lt;/li&gt;
  &lt;li&gt;Độc lập với các thành phần third-party: Phần mềm của chúng ta sẻ không phụ thuộc vào bất cứ libraries/frameworks hay bất cứ thành phần third-party nào, chúng ta phãi có một tư duy rằng các frameworks/libraries sinh ra để chúng ta chọn cho việc phục vụ nhu cầu nghiệp vụ của chúng ta chứ không phãi chúng ta phụ thuộc vào các thứ đó để implement các logic nghiệp vụ của mình.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để đạt được những điều trên, tác giả Uncle Bob đề ra các ý tưởng, quy tắc được mô tả trong hình dưới:
&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và để dễ dàng tiếp cận chúng ta sẻ cùng phân tích các thành phần của một ứng dụng đơn giản để làm rõ những mục tiêu nguyên tắc của Clean Architect. Giả sử chúng ta có một ứng dụng đơn giản với một mô hình data-flow đơn giản như sau:
&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi đó chúng ta sẻ đặt các thành phần lên các vòng tròn cơ bản như sau:
&lt;img src=&quot;/assets/images/2018-01-20-clean-architecture/3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Chia theo mức độ tổng quát chúng ta sẻ có hai tầng như sau:&lt;/p&gt;

&lt;h4 id=&quot;interface-layer&quot;&gt;Interface Layer:&lt;/h4&gt;
&lt;p&gt;Hai vòng tròn ngoài cùng mình tạm đặt nó vào tầng Interface. Đây là tầng chứa các  cổng giao tiếp:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Giao tiếp từ client đến hệ thống(Controller vs Presenter), tuỳ thuộc vào yêu cầu của hệ thống mà chúng ta sẻ implement các cổng Interfaces cụ thể để phục vụ client, có thể là giao tiếp dựa trên Rest/gRPC/TCP…. từ đó chúng ta có thêm các quyết định separate tầng này ra thành các tầng nhỏ dựa vào các lớp endpoints, transports cụ thể.&lt;/li&gt;
  &lt;li&gt;Giao tiếp với các thành phần infrastructure như Database System, Log System, Message Queue System, Search Engine,…. . Đây là nơi chứa các implementations của các Infrastructure Interfaces(Repository Interfaces, Search Interfaces…) mà Domain Layer yêu cầu để thực hiện. Tuỳ vào yêu cầu cũng như loại infrastructure mà chúng ta implement và separate tầng này một cách phù hợp dựa vào các parterns và toolkit(DAO, Repository, Data mapper, ORM, Query builder…..).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domain-layer&quot;&gt;Domain Layer:&lt;/h4&gt;
&lt;p&gt;Là hai vòng tròn trong cùng, hai vòng tròn này sẻ chứa các Entities, Use cases, Infrastructure Interfaces.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Các Entities đóng gói các business rules. Một Entity có thể là một class/struct với các phương thức hoặc có thể là một tập hợp các cấu trúc dữ liệu và hàm, miễn là nó có thể được sử dụng bởi nhiều ứng dụng khác nhau trong toàn bộ phần mềm của chúng ta. Nếu chúng ta chỉ viết một ứng dụng đơn lẻ, thì các Entities chính là các đối tượng business của ứng dụng. Chúng đóng gói các quy tắc chung và cao cấp nhất. Chúng ít có khả năng thay đổi do ảnh hưởng từ những thay đổi bên ngoài. Chẳng hạn, bạn không thể mong những đối tượng này bị ảnh hưởng bởi một thay đổi đến từ UI, security hay kể cả việc thay đổi công nghệ.&lt;/li&gt;
  &lt;li&gt;Các Use Case: Domain Layer sẻ chứa các business rules cụ thể của ứng dụng. Nó đóng gói và implement tất cả các use cases của hệ thống. Các use cases này sẽ điều chỉnh luồng dữ liệu đến và đi từ các Entities và chỉ đạo Entities thể đó sử dụng các business rules của doanh nghiệp để đạt được các mục tiêu của mỗi use case.
Chúng ta không mong muốn những thay đổi trong các use cases sẽ ảnh hưởng đến các thực thể, chúng ta cũng không mong muốn lớp use cases bị ảnh hưởng bởi những thay đổi của các yếu tố bên ngoài như cơ sở dữ liệu, giao diện người dùng hoặc bất kỳ framework nào, lớp này phãi cô lập với những mối lo ngại đó.
Đây là layer vô cùng quan trọng, chứa nhiều logic do đó chúng ta phãi chú trọng tổ chức một cách hợp lí để không bị rối sau quá trình phình to. Tuỳ vào mục đích và tình huống cụ thể mà chúng ta có thể lựa chọn các partern cho phù hợp.&lt;/li&gt;
  &lt;li&gt;Các Infrastructure Interfaces: Ở đây là các Repository Interfaces, Search Engine Interface,… mà các Use Cases cần để phục vụ việc vận hành business logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Với tất cả hệ thống thì thành phần quan trọng nhất của nó luôn là Domain Layer, đây là nơi tập trung các Domain, các Use Cases, là nơi sẻ quyết định hệ thống này làm gì cho khách hàng, quyết định giá trị gì mà chúng ta tạo ra, quyết định sống còn của hệ thống. Mọi thứ bên ngoài như Databases, Frameworks, Protocols,…. đó có thể quy chung lại là các thành phần infrastructures giúp chúng ta implement và vận hành business logic mà thôi.&lt;/p&gt;

&lt;h4 id=&quot;quy-tắc-về-dependencythe-dependency-rule&quot;&gt;Quy tắc về Dependency(The Dependency Rule)&lt;/h4&gt;
&lt;p&gt;Chính sự phân cấp về độ quan trọng của các thành phần của hệ thống, chúng ta phãi có một quy tắc để tổ chức chúng quy tắc về Dependency(The Dependency Rule):
Quy tắc này yêu cầu chúng ta phãi tổ chức code làm sao mà chúng chỉ có thể hướng vào bên trong, tức là những thứ ở bên trong không cần biết về những thứ ở bên ngoài, những thứ ở bên ngoài sinh ra nhằm phục vụ việc hiện thực business logic bên trong.
Cụ thể, tên của một cái gì đó khai báo trong một vòng tròn bên ngoài không được tham chiếu đến hoặc sử dụng bởi mã nguồn trong một vòng tròn bên trong bao gồm, các hàm, các class, biến, hoặc bất kỳ thực thể phần mềm khác. Cũng giống như vậy, các định dạng dữ liệu(Class/Struct/….) được sử dụng trong vòng ngoài không nên được sử dụng bởi những thứ ở vòng tròn bên trong, đặc biệt nếu các định dạng đó được tạo ra bởi một framework trong vòng tròn bên ngoài. Chúng ta không muốn bất cứ điều gì trong một vòng tròn bên ngoài tác động vào vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;OK! Vậy phãi làm sao khi mà các thứ nằm trong vòng tròn bên trong không hề biết việc tồn tại các thứ ở bên ngoài lại có thể sử dụng được những thứ được implement bên ngoài. Ví dụ như các Use Cases nằm ở tầng Domain cần database implementation ở tầng bên ngoài cho việc hiện thực Use Case. Lúc này thay vì chúng ta sử dụng trực tiếp các Repository implementation thì chúng ta sẻ sử dụng Repository Interface/Abstraction ở tầng domain. Đây cũng là một ví dụ về nguyên tắc Dependency Inversion trong SOLID về việc phân tách các layers, các modules. Các high-level modules sẻ không phụ thuộc vào các low-level modules mà cả hai nên phụ thuộc vào các Abstractions nằm tại các hight-level modules.&lt;/p&gt;

&lt;h4 id=&quot;interface-adapters&quot;&gt;Interface Adapters&lt;/h4&gt;

&lt;p&gt;Một thành phần không kém phần quan trọng trong hệ thống  phần mềm của chúng ta đó là Interface Adapters. Đây là một bộ các adapters có nhiệm vụ chuyển dữ liệu từ đầng này sang  tầng khác. Ví dụ như adapter chuyển đổi dữ liệu từ các use cases và Entities thành dữ liệu cho Database và ngược lại(Data Mapper). Hoặc đối với các bạn quen thuộc với Gokit sẻ thấy đó là các Endponts, chuyển đổi các cấu trúc dữ liệu từ định dạng của request sang cấu trúc dữ liệu đầu vào cho các Use Case Logics. Và các Presenters sẻ encode response với định dạng phù hợp cho client.&lt;/p&gt;

&lt;h4 id=&quot;framework-và-driver&quot;&gt;Framework và Driver&lt;/h4&gt;

&lt;p&gt;Đây là một số thành phần có thể nằm trong các vòng tròn ngoài cùng, nói chung bạn không viết nhiều code trong layer này ngoại trừ code để connect với các vòng tròn ở bên trong. Layer này là nơi tập trung của các chi tiết. Chúng ta sẻ giữ những thứ này ở bên ngoài, nơi chúng khó có thể gây ảnh hưởng đến các phần ở vòng tròn bên trong.&lt;/p&gt;

&lt;p&gt;Tuân theo các quy tắc đơn giản trên không phải là một việc quá khó khăn nhưng nó sẻ giúp chúng ta tiết kiệm được nhiều thời gian trong tương lai. Bằng việc tách hệ thống thành các layer, đồng thời tuân theo Dependency Rule, chúng ta sẽ xây dựng được một hệ thống dễ test, cùng với những lợi ích kèm theo như đã đề cập ở trên. Khi bất kỳ bộ phận bên ngoài của hệ thống trở nên lỗi thời, chẳng hạn như database, hoặc web framework, bạn hoàn toàn có thể thay thế chúng với một effort tối thiểu.&lt;/p&gt;

&lt;h2 id=&quot;chỉ-chừng-đó-là-đủ-ư&quot;&gt;Chỉ chừng đó là đủ ư?&lt;/h2&gt;
&lt;p&gt;Tất nhiên là không rồi. Các vòng tròn đó mới chỉ là một mẫu đơn giản, nhiều lúc bạn cần nhiều hơn 4 vòng tròn đó hoặc mỗi vòng tròn chúng ta phãi chia nhỏ thành các vòng tròn khác nữa để đảm bảo sự rõ ràng và “CLEAN”, hơn nữa không có quy tắc nào nói rằng bạn luôn phải có chỉ 4 vòng tròn, có thể có, có thể nhiều hơn và cũng có thể ít hơn, nhiều hơn khi kiến trúc monolith của bạn ngày càng phình to và trở nên phức tạp, ít hơn khi bạn đã chia chúng được thành các microservices một cách mượt mà, chỉ tập trung là logic và loại bỏ đi những thứ rườm rà không đáng quan trọng. Cũng có thể bạn tách ra thành miroservices nhưng vẫn giữ nguyên kiến trúc với đầy đủ ban bệ của mẫu monolith củ, tuỳ vào việc bạn muốn quản lí một củ hành bự hoặc một rỗ hành hoặc một rỗ các tép hành mà thôi. Nhưng một điều mà chúng ta phãi ghi nhớ nếu không muốn bị ăn hành đó là Dependency Rule luôn phãi được áp dụng, sự phụ thuộc luôn phãi được hướng vào bên trong. Khi chúng ta nhìn sâu vào tâm vòng tròn thì mức độ abstract phãi tăng lên, vòng tròn trong cùng chỉ chứa những gì chung nhất, khó có thể chia nhỏ được nữa như các interface chẳng hạn. Các vòng tròn ngoài cùng phãi là các chi tiết được implement cụ thể ở mức thấp nhất và không ngại phãi thay đổi.
Clean Architecture hay ông trời Architecture nó vẫn chỉ là tập hợp các quy tắc, để giữ cho source code hệ thống phần mềm của chúng ta luôn được “Clean” thì chừng đó thôi không đủ, tất cả member cần có những thói quen code tổ chức code dựa vào các design parterns, các kĩ thuật Inheritance(Abstraction), Composition…, khi đặc tay xuống code thì luôn có thói quen suy nghĩ design sao cho tối ưu hoá cách tổ chức nhất, tuân thủ nghiêm ngặc các quy tắc để không bao giờ bị out of control. Tất cả chuyện đó là một quá trình dài trong suốt vòng đời của một phần mềm.&lt;/p&gt;

&lt;h2 id=&quot;implement-clean-architecture&quot;&gt;Implement Clean Architecture:&lt;/h2&gt;
&lt;p&gt;Đây là hai ví dụ nhỏ mình implement Clean Architecture với Golang và Typescript các bạn có thể tham khảo:
https://github.com/lephuocmy668/daily-problems-solving/tree/master/golang/workspace/tiktok-clean-microservice
https://github.com/lephuocmy668/nodejs-typescript-clean-architecture&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><category term="functional programming" /><category term="functional reactive programming" /><category term="declarative programming" /><category term="clean architecture" /><category term="concurrency" /><summary type="html">Trước khi đi vào nội dung chính của bài viết này, mình xin nói qua về quá trình mình đã tiếp cận với các kiểu kiến trúc trong việc xây dựng các ứng dụng web. Điểm xuất phát của mình dường như nó không đi theo con đường “chính đạo” như các bạn các anh chị đi trước thường tiếp cận với Java, C#, Scala,…và đa số những bạn xuất phát theo con đường Java thường có cái nhìn cũng như tư duy về kiến trúc từ sớm, mình thì ngược lại, xuất phát một cách quán tính, mình bắt đầu sự nghiệp coder với một dự án startup với công nghệ chính là Node.js, code không theo một paradigm cụ thể nào cả, OOP cũng không hẳn là OOP, Functional cũng không hẳn là Functional, Functional Reactive cũng không ra Functional Reactive, qua một thời gian thì mọi thứ trở nên rối hết cả lên và dường như không còn cơ hội cứu chữa, sau một thời gian dài code quán tính thì không những không xây dựng được tư duy kiến trúc, tư duy tổ chức mà còn làm mình “hư tay hư chân” và khó nhồi nhét tư duy design sau này. Thật may lúc đó mình có cơ hội cho công việc mới, giai đoạn đầu bắt đầu công việc mới mình được yêu cầu tìm hiểu và áp dụng Clean Architect vào dự án với Golang với một tài liệu duy nhất là bài viết này https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html. Ôi thôi một thằng coder đang trong guồng ảo tưởng, tư duy tổ chức kém, kém design partern, kém OOP, kém tất cả và quả thực Clean Architecture đối với mình lúc đó quả là một bài học quá khó, nó yêu cầu phãi xâu chuổi tất cả kiến thức tổ chức code như OOP, nó yêu cầu những nền tảng cơ bản từ sự hiểu biết về các Programming paradigms, cho đến các Design Parterns ở OOP cũng như ở các paradigms khác, tiếp đến mới là các Design Principles như SOLID Principles, Component Principles rồi mới đến các nguyên tắc, các mẫu xây dựng một kiến trúc cho phần mềm. Không chỉ là Clean Architecture mà tất cả các kiến trúc khác đều dựa trên những nguyên tắc chung đó mà xây dựng nên. Chính vì vậy đến bây giờ đây, sau một năm với nhiều may mắn được làm việc với các dự án từ Golang đến Typescript mình tóm tắt lại quá trình mình tiếp cận với Clean Architecture nói riêng và các quy tắc lập trình, tổ chức code nói chung cũng và cũng là dịp để mình ôn lại kiến thức, kĩ năng lẫn thói quen nhằm ghi nhớ sâu hơn hoặc ai đó đang tìm hiểu hoặc đang implement Clean Architecture vô tình đọc bài này có thể cảm nhận và phản biện giúp mình cũng cố kiến thức hơn.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Solid Principle</title><link href="https://romeo.vn/solid-principle/" rel="alternate" type="text/html" title="Solid Principle" /><published>2017-12-12T01:01:00-06:00</published><updated>2017-12-12T01:01:00-06:00</updated><id>https://romeo.vn/solid-principle</id><content type="html" xml:base="https://romeo.vn/solid-principle/">&lt;p&gt;Hệ thống phần mềm tốt phãi bắt đầu bằng code sạch. Cũng giống như việc xây nhà, bắt đầu chúng ta cần những viên gạch tốt đã, nhưng những viên gạch đã không tốt thì kiến ​​trúc của tòa nhà không còn quan trọng nữa vì nó đã dễ dàng sụp đổ rồi. Một mặt khác, khi bạn có các viên gạch tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn từ những viên gạch tốt đó. Do đó Solid đến và giúp chúng ta xây dựng các kiến trúc tốt dựa trên các viên gạch tốt.&lt;/p&gt;

&lt;p&gt;Nguyên tắc SOLID cho chúng ta biết cách sắp xếp các hàm, cấu trúc dữ liệu của chúng ta vào các lớp và kết nối chúng lại với nhau để xây dựng nên hệ thống. Việc sử dụng từ class không có nghĩa rằng các nguyên tắc này chỉ áp dụng cho phần mềm hướng đối tượng. Một class đơn giản là một nhóm các hàm và dữ liệu được ghép đôi. Mọi hệ thống phần mềm đều có các nhóm như vậy cho dù chúng có được gọi là các class hay không thì nguyên tắc SOLID vẫn sẻ áp dụng được cho các nhóm đó.&lt;/p&gt;

&lt;p&gt;Vậy mục tiêu của các nguyên tắc trong SOLID là gì? Là tạo ra các cấu trúc ở mức mid-level của phần mềm có các yêu cầu như dễ dàng tiếp nhận sự thay đổi, dễ hiểu cho người mới, dễ sử dụng lại. Từ mid-level đề cập đến thực tế là các nguyên tắc này được áp dụng bởi các lập trình viên làm việc ở cấp modules, SOLID được áp dụng ngay trên mức của code implement và giúp xác định các loại cấu trúc phần mềm được sử dụng trong các modules và các components.&lt;/p&gt;

&lt;p&gt;Chỗ này hơi khó hiểu nhể, có thể tưởng tượng rằng một ngôi nhà nên được chia đầu tiên thành các components như các bức tường nhỏ, sau đó ghép nối lại thì SOLID được dùng ở mức các Engineer tạo nên các bức tường đó. Nói cách khác, khi muốn xây dựng kiến trúc tốt cho một ngôi nhà hay phần mềm chúng ta phãi thiết kế tốt từ từng bức tường, từng modules từng component để sao cho nó có thể dễ dàng tiếp nhận sự thay đổi, dễ dùng dễ hiểu cho người mới và hơn nữa là dễ dàng tái sử dụng module/component đó.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SOLID&lt;/strong&gt; được &lt;strong&gt;Robert C. Martin&lt;/strong&gt; đưa ra với năm nguyên tắc thiết kế hướng đối tượng (OOD) sau:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Single responsibility principle (SRP)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Open/closed principle (O)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Liskov substitution principle (L)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Interface segregation principle (I)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Dependency inversion principle (D)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta sẻ tiếp tục phân tích rõ từng nguyên tắc.&lt;/p&gt;

&lt;h3 id=&quot;1-the-single-responsibility-principlesrp&quot;&gt;1. The Single Responsibility Principle(SRP):&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;The Single Responsibility Principle(SRP)&lt;/strong&gt;: Mỗi một class chỉ đảm nhiệm một trách nhiệm duy nhất,một hệ thống phần mềm có cấu trúc tốt là hệ thống có các module/component mà chúng chỉ có một và chỉ một lý do để thay đổi.
Đọc đến đây chúng ta sẻ có thể dễ nhầm lẩn với một nguyên tắc khác đó là việc các hàm nên làm một và chỉ một việc duy nhất, đó là một nguyên tắc chúng ta thường sử dụng khi tái cấu trúc các hàm lớn thành các hàm nhỏ. Đó không phãi là SRP.&lt;/p&gt;

&lt;p&gt;Để hiểu rõ nguyên tắc này chúng ta sẻ xét một ví dụ mà ta đã vi phạm nguyên tắc này:
Giả sử hệ thống quản lí tiền lương nhân viên của chúng ta có chứa 4 thực thể sau: Employee, CTO, CFO, COO. Class Employee của chúng ta sẻ có chứa ba phương thức sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;caculatePay()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reportHours()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;save()&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cách thiết kế class Employee của chúng ta đã vi phạm SRP bởi vì nó có ba phương thức chịu trách nhiệm với 3 thực thể rất khác nhau.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức caculatePay() được gọi bởi phòng kế toán và báo cáo cho CFO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức reportHours() được gọi bởi phòng HR và báo cáo cho COO.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Phương thức save() được gọi bởi database admin và báo cáo cho CTO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bằng việc đưa ba phương thức trên vào một class Employee đơn lẻ, chúng ta đã vô tình kết hợp sự phụ thuộc của các thực thể khác lại với nhau, ở đây có thể là CFO, COO, CTO đã vô tình phụ thuộc vào nhau. Lấy ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử rằng hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; và hàm &lt;strong&gt;reportHours()&lt;/strong&gt; cần có giờ làm việc của từng nhân viên và chúng dùng chung một thuật toán để tính giờ làm việc, rõ ràng là khi đó chúng ta sẻ không muốn việc duplicate code xãy ra ở đây, chúng ta sẻ viết một hàm &lt;strong&gt;regularHours()&lt;/strong&gt; cho việc sử dụng của hai hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; và &lt;strong&gt;reportHours()&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Đến một ngày đẹp trời, nhóm CFO quyết định rằng việc tính toán giờ làm việc &lt;strong&gt;regularHours()&lt;/strong&gt; cần được tinh chỉnh lại trong lúc nhóm COO vẫn thấy hàm &lt;strong&gt;regularHours()&lt;/strong&gt; như thế là ổn rồi không muốn bất cứ thay đổi gì đối với nó nữa.&lt;/p&gt;

&lt;p&gt;Một developer được giao nhiệm vụ tinh chỉnh lại hàm &lt;strong&gt;regularHours()&lt;/strong&gt; theo một mục đích mới nào đó, anh ta làm việc nhưng đâu biết rằng hàm &lt;strong&gt;reportHours()&lt;/strong&gt; cũng gọi đến nó, việc tinh chỉnh được thực hiện xong, hàm &lt;strong&gt;caculatePay()&lt;/strong&gt; chạy trơn tru đúng yêu cầu và được áp dụng ngay. Sau một thời gian người ta nhận thấy hàm &lt;strong&gt;reportHours()&lt;/strong&gt; đã đi sai hướng, các số liệu báo cáo lên sai lệch ảnh hưởng đến tài chính công ty.&lt;/p&gt;

&lt;p&gt;Đó là một ví dụ vi phạm, khi gặp các trường hợp đó chúng ta nên phân tách các phương thức ra các class riêng lẻ và ngược lại, cách dễ nhất để phá các ứng dụng là tạo ra các GOD classes(một GOD class là một class biết quá nhiều hoặc làm quá nhiều, GOD class là một ví dụ về một ví dụ về anti pattern), một God class giữ reference đến nhiều thực thể khác cũng như giữ nhiều trách nhiệm đâm ra dễ gây ra các vấn đề tương tự như ví dụ trên.&lt;/p&gt;

&lt;h3 id=&quot;2-openclosed-principle-ocp&quot;&gt;2. Open/closed principle (OCP):&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Theo nguyên lý này, mỗi khi ta muốn thêm chức năng cho chương trình, chúng ta nên viết class mới mở rộng từ class cũ ( bằng cách kế thừa hoặc sở hữu class cũ) không nên sửa đổi class cũ:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tất nhiên rồi phãi không nào, đây là lý do cơ bản nhất mà chúng ta nghiên cứu software architecture. Rõ ràng là nếu muốn mở rộng chức năng một cách đơn gỉan mà phãi thay đổi lớn đối với phần mềm thì các kiến ​​trúc sư của hệ thống phần mềm đó đã thất bại rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mục đích là thế nhưng làm thì như nào để đạt được mục đích nguyên tắc đó, chúng ta cùng xét một ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử hệ thống của bạn đang có một chức năng báo cáo tóm tắt tài chính, dữ liệu được hiển thị trên giao diện web và có thể cuộn cho bản tóm tắt dài. Rồi một ngày đẹp trời khách hàng muốn bạn thêm chức năng thể hiện báo cáo đó trên trên PDF với tiêu đề và phân trang hợp lí, các số liệu cần được làm nổi bật và gửi cho người dùng.&lt;/p&gt;

&lt;p&gt;Rõ ràng, một lượng code sẻ phãi được viết lại để đáp ứng yêu cầu trên nhưng bao nhiêu code củ sẻ phãi thay đổi? Kiến trúc tốt sẻ giảm thiểu lượng code phãi thay đổi xuống mức tối thiểu nhất và lí tưởng nhất là không có dòng code nào phãi thay đổi.&lt;/p&gt;

&lt;p&gt;Làm thế nào để đạt được điểu đó? Đầu tiên phãi tách biệt những thực thể mà chúng có thể phãi thay đổi vì các lí do khác nhau(áp dụng SRP) sau đó bố trí sự phụ thuộc của chúng đúng cách(sử dụng DIP nói sau). Bằng cách đó chúng ta sẻ đưa luồng dữ liệu hướng như dưới, mô tả một số quy trình kiểm tra xử lí dữ liệu có thể trình bày, sau đó trình bày theo định dạng phù hợp để thể hiện trên web và trên PDF.&lt;/p&gt;

&lt;p&gt;Thông tin chi tiết cần thiết ở đây là việc tạo báo cáo liên quan đến hai trách nhiệm riêng biệt: tính toán thông tin số liệu tài chính và việc trình bày data đó thành các model thân thiện với web và pdf.&lt;/p&gt;

&lt;p&gt;Sau khi thực hiện sự tách biệt này, chúng ta cần phải tổ chức các phụ thuộc code để đảm bảo rằng những thay đổi đối với một trong những trách nhiệm đó không gây ra những thay đổi ở bên kia. Ngoài ra, cách tổ chức mới phải đảm bảo rằng hành vi có thể được mở rộng mà không huỷ bỏ các sửa đổi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/2.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta thực hiện điều này bằng cách phân vùng các quy trình thành các class và tách các class đó thành các component, như được thể hiện bằng các dòng kép trong sơ đồ trong hình dưới.&lt;/p&gt;

&lt;p&gt;Trong hình này, thành phần ở phía trên bên trái là Controller, phía trên bên phải là Interactor, phía dưới bên phải là database, ở phía dưới bên trái có bốn thành phần đại diện cho đối tượng hiển thị và data hiển thị.&lt;/p&gt;

&lt;p&gt;Các  được đánh dấu bằng &lt;i&gt; là các interface; những người được đánh dấu bằng &lt;DS&gt; là các cấu trúc dữ liệu.&lt;/DS&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Các mũi tên đang sử dụng để thể hiện các mối quan hệ. Đầu mũi tên trỏ tới thể hiện mối quan hệ thừa kế. Điều đầu tiên cần lưu ý là tất cả các phụ thuộc là các phụ thuộc code. Một mũi tên chỉ từ class A đến class B có nghĩa là code của lớp A reference đế class B, nhưng class B không cần biết gì đến class A.&lt;/p&gt;

&lt;p&gt;Như vậy, trong hình trên, FinancialDataMapper reference đến FinancialDataGateway thông qua một mối quan hệ implement interface, nhưng FinancialGateway không biết gì về FinancialDataMapper.
&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/3.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều tiếp theo cần lưu ý là tất cả mỗi quan hệ đều là một chiều và mỗi đối tượng chỉ chịu sự phụ thuộc đến duy nhất một thực thể khác như thể hiện trong hình dưới, những mũi tên hướng tới các thành phần mà chúng ta muốn bảo vệ khỏi thay đổi.&lt;/p&gt;

&lt;p&gt;Nghĩa là sao? là nếu thành phần A cần được bảo vệ khỏi những thay đổi trong thành phần B, thì thành phần B sẽ phụ thuộc vào thành phần A. Chúng ta muốn bảo vệ Controller khỏi những thay đổi trong Presenters. Chúng ta muốn bảo vệ các Presenters khỏi những thay đổi trong Views. Chúng tôi muốn bảo vệ Interactor khỏi những thay đổi trong bất cứ điều gì. Interactor ở vị trí phù hợp nhất với OCP.&lt;/p&gt;

&lt;p&gt;Các thay đổi đối với Database hoặc Controller hoặc Presenters hoặc Views sẽ không ảnh hưởng đến Interactor.
Tại sao Interactor nên giữ một vị thế đặc quyền như vậy? Bởi vì nó chứa các business rule. Interactor chứa các chính sách cao nhất của ứng dụng. Tất cả các thành phần khác đang xử lý các mối quan tâm ngoại vi còn interactor giao dịch với mối quan tâm trung tâm. Mặc dù Controller là ngoại vi với Interactor, nhưng nó vẫn là trung tâm của các Presenters và Views. Và trong khi các diễn giả có thể là ngoại vi với Controller nhưng chúng là trung tâm của Views.&lt;/p&gt;

&lt;p&gt;Lưu ý cách thức này tạo ra một hệ thống phân cấp bảo vệ dựa trên khái niệm “level”. Các tác nhân tương tác là khái niệm mức cao nhất, vì vậy chúng được bảo vệ nhất. View nằm trong số các khái niệm cấp thấp nhất, vì vậy chúng được bảo vệ ít nhất. Presenters có cấp độ cao hơn Views nhưng cấp thấp hơn Controller hoặc Interactor.&lt;/p&gt;

&lt;p&gt;Đây là cách OCP hoạt động ở cấp kiến ​​trúc. Các kiến trúc chia chức năng riêng biệt dựa trên cách thức – tại sao và khi nào chúng thay đổi, sau đó tổ chức chức năng được phân tách thành một hệ thống phân cấp các thành phần. Các thành phần cấp cao hơn trong phân cấp đó được bảo vệ khỏi những thay đổi được thực hiện cho các thành phần cấp thấp hơn.&lt;/p&gt;

&lt;p&gt;Nói tóm lại OCP là một trong nhưng sức mạnh đứng đằng sau kiến trúc hệ thống tốt, giúp hệ thống dễ dàng mở rộng mà không phãi chịu sức ép từ những thay đổi trong mã nguồn, mục tiêu này đạt được khi chúng ta chia phân vùng hệ thống thành các component và sắp xếp chúng thành một hệ thống phân cấp sự phụ thuộc để bảo vệ các thành phần cấp cao khỏi sự thay đổi của các thành phần cấp thấp.&lt;/p&gt;

&lt;h3 id=&quot;3-liskov-substitution-principlelsp&quot;&gt;3. Liskov Substitution Principle(LSP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này được phát biểu như sau:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trong một chương trình, các object của class con có thể thay thế class cha mà không làm thay đổi tính đúng đắn của chương trình&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Không hiểu đúng không nào? Có thể nghĩ như này: Khi các class A kế thừa từ class B thì phãi có hai điều kiện sau:&lt;/p&gt;

&lt;p&gt;– Class B có các behaviors nào thì A phãi có các behaviors đó.&lt;/p&gt;

&lt;p&gt;– Các phương thức của class cơ sở thì phãi đảm bảo có thể sử được trong các class con của nó hay nói cách khác các phương thức của các class cha phãi luôn hoạt động được và chính xác trên tất cả các class kế thừa từ nó.&lt;/p&gt;

&lt;p&gt;Để hiểu hơn ta xét ví dụ như sau:&lt;/p&gt;

&lt;p&gt;Giả xử ta có class Chim có phương thức là Bay()&lt;/p&gt;

&lt;p&gt;– Class Đại Bàng thừa kế class Chim cũng có đủ phương thức Bay() và hoạt động đúng như class chim() trường hợp này thoả mãn LSP.&lt;/p&gt;

&lt;p&gt;– Class Chim Cánh cụt thừa kế class Chim nhưng phương thức Bay không khả dụng cho nên là vi phạm LSP.&lt;/p&gt;

&lt;p&gt;– Class Chim Điện thừa kế class Chim cũng có phương thức bay, nhưng phương thức Bay này có thêm yêu cầu là phãi có điện thì mới bay được cho nên vi phạm LSP.&lt;/p&gt;

&lt;p&gt;LSP cần được mở rộng đến mức kiến trúc. Một sự vi phạm đơn giản về khả năng thay thế, có thể làm cho kiến trúc của hệ thống bị ô nhiễm với một số lượng đáng kể các cơ chế bổ sung.&lt;/p&gt;

&lt;h3 id=&quot;4-interface-segregation-principleisp&quot;&gt;4. Interface segregation principle(ISP):&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/4.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nguyên tắc này có thể nói ngắn gọn là thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ, với nhiều mục đích cụ thể, để dễ hiểu hơn chúng ta cùng xét ví dụ như hình trên, mỗi user sử dụng các phương thức của class OPS, giả sử rằng User1 chỉ sử dụng op1, User2 chỉ sử dụng op2, User3 chỉ sử dụng op3.&lt;/p&gt;

&lt;p&gt;Khi đó User1 vô tình phụ thuộc vào op2 và op3 mặc dù nó không gọi chúng, sự phụ thuộc này khiến cho User1 phãi được implement lại khi op2 và op3 bị thay đổi mặc dù nó không dùng hai hàm đó, hơn thế nữa việc gom quá nhiều phương thức vào một đối tượng khiến cho chúng ta nhọc nhằng trong việc implement cho nên chúng ta nên giải quyết bằng cách tách biệt các phương thức thành các interface nhỏ như hình bên dưới.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/5.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu vấn đề này được triển khai trên ngôn ngữ tỉnh như Golang thì code của User1 sẻ phụ thuộc vào U1Ops và op1 nhưng sẻ không phụ thuộc vào OPS do đó khi có thay đổi đối với OPS mà User1 không quan tâm sẻ không làm cho User1 bị biên dịch lại và triển khai lại.&lt;/p&gt;

&lt;h3 id=&quot;5-dependency-inversion-principledip&quot;&gt;5. DEPENDENCY INVERSION PRINCIPLE(DIP):&lt;/h3&gt;

&lt;p&gt;Nguyên tắc này cho chúng ta biết rằng các hệ thống linh hoạt nhất là các hệ thống phụ thuộc vào mã nguồn chỉ tham chiếu đến trừu tượng hóa, chứ không chỉ các concretions.&lt;/p&gt;

&lt;p&gt;Hãy tưởng tượng phần mềm của chúng ta sẻ như thế nào trước khi có một cơ chế an toàn và thuận tiện cho đa hình, luồng đi của phần mềm này sẻ như cây mô tả bên dưới, các hàm main được gọi là các hàm level cao chúng gọi các hàm level trung bình và các hàm level trung bình gọi các hàm ở level thấp. Tuy nhiên có thể thấy rằng trong cây đó các phụ thuộc code không đi theo hướng của luồng gọi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/6.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/7.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để hàm main gọi một trong các hàm level cao, nó phải reference đến tên của module chứa hàm đó. Trong C chúng ta dùng #include trong Java và Go ta dùng câu lệnh import. Thật vậy, mỗi phần chứa hàm gọi buộc phải refer đến tên của module có chứa hàm được gọi. Rõ ràng sự phụ thuộc được thể hiện rằng hàm Main sẻ phụ thuộc vào các hàm dưới nó. Tuy nhiên, khi đa hình được đưa vào sử dụng, một điều rất khác sẻ xảy ra như sau.&lt;/p&gt;

&lt;p&gt;Chúng ta có thể thấy rằng module HL1 vẫn gọi hàm F () trong module ML1 nhưng thực tế là nó gọi hàm này thông qua một interface mà khi chạy thì interface thực sự không tồn tại. HL1 đơn giản gọi F () trong ML1 mặc dù là thể hiện gián tiếp.&lt;/p&gt;

&lt;p&gt;Tuy nhiên lưu ý rằng sự phụ thuộc mã nguồn (mối quan hệ thừa kế) giữa ML1 và interface trỏ theo hướng ngược lại so với luồng điều khiển. Điều này được gọi là sự đảo ngược phụ thuộc và các tác động của nó đối với kiến trúc phần mềm là rất sâu sắc. Thực tế là các ngôn ngữ OOP cung cấp tính đa hình an toàn và thuận tiện cho nên bất kỳ sự phụ thuộc mã nguồn nào bất kể nó ở đâu đều có thể đảo ngược.&lt;/p&gt;

&lt;p&gt;Bây giờ hãy nhìn lại luồng đi trong hình 6 và các phụ thuộc mã nguồn của nó thì bất kỳ phụ thuộc mã nguồn nào đều có thể được quay lại bằng cách chèn một interface giữa chúng. Với cách tiếp cận này các kiến trúc implement trong các hệ thống được viết bằng ngôn ngữ OOP có thể kiểm soát hướng của tất cả các phụ thuộc mã nguồn trong hệ thống. Đó là sức mạnh mà OOP cung cấp. Bạn có thể làm gì với sức mạnh đó? Ví dụ, bạn có thể sắp xếp lại các phụ thuộc mã nguồn của hệ thống để cơ sở dữ liệu và giao diện người dùng (UI) phụ thuộc vào các quy tắc nghiệp vụ chứ không phải là cách khác.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12-solid-principle/8.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Điều này có nghĩa là gì? Là giao diện người dùng và cơ sở dữ liệu có thể được implement để bổ sung cho thể hiện các business logic, mã nguồn của business logic không bao giờ cần biết đến giao diện người dùng hoặc cơ sở dữ liệu. Kết quả là, các business logic cũng như giao diện người dùng và cơ sở dữ liệu có thể được biên dịch thành ba thành phần hoặc đơn vị triển khai riêng biệt và thành phần chứa business logic sẽ không phụ thuộc vào các thành phần có chứa giao diện người dùng và cơ sở dữ liệu, các thay đổi đối với giao diện người dùng hoặc cơ sở dữ liệu không có bất kỳ ảnh hưởng nào đến business logic. Tóm lại, khi mã nguồn trong một thành phần thay đổi thì chỉ thành phần đó cần phải được triển khai lại. Đây là khả năng triển khai độc lập, nếu các module trong hệ thống của bạn có thể được triển khai độc lập, thì chúng có thể được phát triển độc lập bởi các nhóm khác nhau.&lt;/p&gt;

&lt;p&gt;Qua việc tìm hiểu nguyên tắc này chúng ta cũng có thể thấy được sức mạnh của OOP đặc biệt là tính đa hình, thông qua việc sử dụng đa hình chúng ta có thể giành quyền kiểm soát tuyệt đối đối với mọi phụ thuộc mã nguồn trong hệ thống.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">Hệ thống phần mềm tốt phãi bắt đầu bằng code sạch. Cũng giống như việc xây nhà, bắt đầu chúng ta cần những viên gạch tốt đã, nhưng những viên gạch đã không tốt thì kiến ​​trúc của tòa nhà không còn quan trọng nữa vì nó đã dễ dàng sụp đổ rồi. Một mặt khác, khi bạn có các viên gạch tốt rồi nhưng đôi lúc từ chúng bạn vẫn tạo ra một mớ hổn độn từ những viên gạch tốt đó. Do đó Solid đến và giúp chúng ta xây dựng các kiến trúc tốt dựa trên các viên gạch tốt.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Hiểu Về Call Stack - Heap - Queue</title><link href="https://romeo.vn/hieu-ve-call-stack-heap-queue/" rel="alternate" type="text/html" title="Hiểu Về Call Stack - Heap - Queue" /><published>2017-08-14T12:45:00-05:00</published><updated>2017-08-14T12:45:00-05:00</updated><id>https://romeo.vn/hieu-ve-call-stack-heap-queue</id><content type="html" xml:base="https://romeo.vn/hieu-ve-call-stack-heap-queue/">&lt;h2 id=&quot;1-stack&quot;&gt;1. Stack:&lt;/h2&gt;

&lt;p&gt;Ứng với mỗi thread (hoặc 1 goruntine đối với Golang) của chương trình thường có một call stack. Khi ứng dụng bắt đầu được thực thi, các biến cục bộ, địa chỉ hàm, biến tham chiếu đối tượng….sẻ được lưu trữ trong Stack, tùy theo thứ tự gọi mà các thành phần đẩy vào stack được sắp xếp theo đúng thứ tự.
Khi 1 phương thức kết thúc cũng là lúc các giá trị biến và các tham chiếu đối tương được hủy bỏ — và địa chỉ hàm cũng được hủy bỏ ngay sau đó. Stack lưu trữ dung lượng thấp hơn rất nhiều so với heap.&lt;/p&gt;

&lt;p&gt;Khi lập trình với các ngôn ngữ như Java, Golang… chúng ta thường quan tâm đến stack size. Với Java trong môi trường 64-bit thì JVM mặc định có stack size cho mỗi thread là 1MB và Golang thì mặc định là 2kb.&lt;/p&gt;

&lt;p&gt;Trong Javascript, Golang và đa số các ngôn ngữ lập trình khác, khi chúng ta gọi một hàm để thực thi đồng nghĩa với việc chúng ta push một hàm vào stack, đến khi nào hàm đó thực thi xong và trả về thì mới được pop ra khỏi stack. Thao tác đó được mô tả như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/1.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Như hình trên, khi chúng ta thực thi một chương trình, đầu tiên chúng ta sẻ tìm đến hàm main, nơi mà mọi thực thi đều bắt đầu từ đây. Trong chương trình trên ta sẻ có các bước như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;console.log(bar(6))&lt;/strong&gt; được đưa vào stack. Hàm này gọi đến hàm &lt;strong&gt;bar&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp theo, &lt;strong&gt;bar(6)&lt;/strong&gt; được đưa vào stack, hàm &lt;strong&gt;bar&lt;/strong&gt; lại tiếp tục gọi hàm &lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tiếp đó &lt;strong&gt;foo(x,y)&lt;/strong&gt; lại được đưa vào stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;foo&lt;/strong&gt; thực thi xong trả kết quả về cho hàm &lt;strong&gt;bar&lt;/strong&gt; và được pop ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;bar&lt;/strong&gt; nhận được kết quả từ hàm foo, thực thi xong trả về kết quả cho hàm &lt;strong&gt;console.log()&lt;/strong&gt; và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hàm &lt;strong&gt;console.log()&lt;/strong&gt; thực thi và được loại bỏ ra khỏi stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cuối cùng hàm &lt;strong&gt;main&lt;/strong&gt; cũng được loại bỏ ra khỏi stack, chương trình kết thúc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Đôi lúc chúng ta tạo ra một vòng lặp vô hạn khi chúng ta gọi nhiều đệ quy, với chrom thì thường giới hạn bởi 16.000 frames, nếu vượt ra khỏi con số đó thì sẻ sinh ra lỗi như sau :v&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-14-hieu-ve-call-stack-heap-queue/2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-heap&quot;&gt;2. Heap:&lt;/h3&gt;

&lt;p&gt;Bộ nhớ Heap dùng để cấp phát bộ nhớ cho object, biến toàn cục.
Bất cứ khi nào khai báo đối tượng thì các giá trị của đối tượng sẽ được lưu trữ trong Heap (chú ý giá trị đối tượng chứ ko phải biến tham chiếu đối tượng) và có thể truy cập bất cứ khi nào trong chương trình, bộ nhớ tồn tại trong suốt quá trình thực thi chương trình&lt;/p&gt;

&lt;p&gt;Khi kết thúc 1 phương thức các biến tham chiếu đối tượng bị hủy trong stack và các tham chiếu tới các dữ liệu lưu trong Heap cũng bị hủy bỏ javascript sẻ dùng trình thu dọn rác để thực hiện kiểm tra các tham chiếu.. nếu ko còn tham chiếu nào tới biến lưu trữ trên vùng nhớ Heap thì các vùng nhớ đó sẽ được thu gom.&lt;/p&gt;

&lt;h3 id=&quot;3-queue&quot;&gt;3. Queue:&lt;/h3&gt;

&lt;p&gt;Đối với Javascript runtime thì có thêm một thành phần nữa đó là queue, đây là danh sách các message cần được sử lí và các hàm callback liên quan thực thi. Nói dễ hiểu hơn là các message này sẻ được lưu vào queue để phản hồi các sự kiện async bên ngoài chẳng hạn như sự kiện nhấp chuột hay một http reuquest với một callback được cung cấp.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="solid" /><category term="ood" /><category term="oop" /><summary type="html">1. Stack:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Tại sao lại dùng Golang?</title><link href="https://romeo.vn/stacks-trong-golang/" rel="alternate" type="text/html" title="Tại sao lại dùng Golang?" /><published>2017-02-10T11:20:00-06:00</published><updated>2017-02-10T11:20:00-06:00</updated><id>https://romeo.vn/stacks-trong-golang</id><content type="html" xml:base="https://romeo.vn/stacks-trong-golang/">&lt;p&gt;Khi bắt đầu làm việc với Golang mình được giới thiệu rằng Golang rất chi là ngon cho backend, nào là nó cung cấp một thứ gọi là Goruntine - Một thread nhỏ nhẹ với chỉ 2kb stack size rồi đơn giản, dễ học….
Tuy nhiên lúc đó đọc giới thiệu xong thì nãy sinh một số câu hỏi:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Vấn đề stack size: Mặc định Java nó cấp phát tận 1MB vẫn thường xãy ra stack overflow, đây stack size mỗi Goruntine 2kb có mà nát hết à?&lt;/li&gt;
  &lt;li&gt;Vấn đề switching context: Các ngôn ngữ dựa trên thread based vẫn luôn chịu một ảnh hưởng không thể tránh khỏi đó là switching context cost của CPU, thế ếu nào người ta giới thiệu Golang xử lí cái này ngon lắm, có gì đó không ổn ở đây.&lt;/li&gt;
  &lt;li&gt;Có chắc Golang sử dụng hiệu quả CPU đa lõi như giới thiệu?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tuy nhiên Go nó có cách implement để điều đó không xãy ra và có thể hay hơn nũa.&lt;/p&gt;

&lt;h2 id=&quot;segmented-stacks&quot;&gt;Segmented stacks:&lt;/h2&gt;

&lt;p&gt;Trong Go 1.2, nó sử dụng cái gọi là Segmented Stacks, trong cách tiếp cận này, stack không liên tục và lớn dần. Mỗi stack bắt đầu bởi một segment duy nhất. Khi stack cần lớn lên một segment sẻ được cấp phát và được liên kết với phần trước. Một stack là một danh sách được liên kết từ hai hoặc nhiều segments.
&lt;img src=&quot;/assets/images/2017-02-10-stacks-trong-golang/1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ưu điểm của phương pháp này là stack có thể bắt đầu nhỏ và phát triển hoặc thu nhỏ khi cần thiết. Tuy nhiên khi đó sẻ có một vấn đề nãy sinh:
Hãy tưởng tượng có các lời gọi hàm xãy ra khi stack gần đầy, bắt buộc stack phãi phát triển và segment mới phãi được phân bổ. Khi hàm đó return segments sẻ được giải phóng và stack co lại. Các cuộc gọi hàm đó xãy ra thường xuyên như sau:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;byte&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// do something with x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Gọi đến hàm &lt;strong&gt;big ()&lt;/strong&gt; sẻ khiến segment mới được cấp phát, stack phình ra và segment sẻ được giải phóng và stack thu lại khi hàm return. Công đoạn đó xãy ra liên tục vì nó đang trong vòng for. Chi phí cho việc cấp phát và thu hồi các segment trở nên đáng kể. Đây gọi là “hot split” trong cộng đồng Go và người Rust gọi đó là “stack thrashing”.&lt;/p&gt;

&lt;h3 id=&quot;contiguous-stacks&quot;&gt;Contiguous stacks&lt;/h3&gt;

&lt;p&gt;“Hot split” đã được giải quyết trong Go 1.3 bằng cách tạo ra &lt;strong&gt;contiguous stacks&lt;/strong&gt;.
Bây giờ khi một stack cần phát triển, thay vì cấp phát một segment mới, runtime sẽ:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Tạo một stack mới lớn hơn một chút.&lt;/li&gt;
  &lt;li&gt;Sao chép nội dung của stack sang stack mới&lt;/li&gt;
  &lt;li&gt;Điều chỉnh lại mọi con trỏ được sao chép để trỏ đến địa chỉ mới&lt;/li&gt;
  &lt;li&gt;Phá hủy stack cũ đi.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="Golang" /><category term="Event Loop" /><category term="Event Driven" /><summary type="html">Khi bắt đầu làm việc với Golang mình được giới thiệu rằng Golang rất chi là ngon cho backend, nào là nó cung cấp một thứ gọi là Goruntine - Một thread nhỏ nhẹ với chỉ 2kb stack size rồi đơn giản, dễ học…. Tuy nhiên lúc đó đọc giới thiệu xong thì nãy sinh một số câu hỏi: Vấn đề stack size: Mặc định Java nó cấp phát tận 1MB vẫn thường xãy ra stack overflow, đây stack size mỗi Goruntine 2kb có mà nát hết à? Vấn đề switching context: Các ngôn ngữ dựa trên thread based vẫn luôn chịu một ảnh hưởng không thể tránh khỏi đó là switching context cost của CPU, thế ếu nào người ta giới thiệu Golang xử lí cái này ngon lắm, có gì đó không ổn ở đây. Có chắc Golang sử dụng hiệu quả CPU đa lõi như giới thiệu?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Giới Thiệu Ngôn Ngữ Golang</title><link href="https://romeo.vn/gioi-thieu-ngon-ngu-golang/" rel="alternate" type="text/html" title="Giới Thiệu Ngôn Ngữ Golang" /><published>2017-01-28T21:20:00-06:00</published><updated>2017-01-28T21:20:00-06:00</updated><id>https://romeo.vn/gioi-thieu-ngon-ngu-golang</id><content type="html" xml:base="https://romeo.vn/gioi-thieu-ngon-ngu-golang/">&lt;p&gt;Hiện tại có rất nhiều ngôn ngữ mạnh mẻ cho việc xây dựng ứng dụng web phía back-end như Java, C#, Php, Javascript(Node.js), Ruby, Python…, trước đó thì mình làm việc với Javascript-Node.js tuy nhiên hôm nay, mình sẻ giới thiệu với các bạn một ngôn ngữ có vẻ mới một chút đó là Golang(Go).&lt;/p&gt;

&lt;p&gt;Go là ngôn ngữ lập trình được phát triển bởi Google và cộng đồng mã nguồn mở bắt đầu từ năm 2007 và ra phiên bản đầu tiên vào tháng 12 năm 2012. Go là một ngôn ngữ tỉnh, có khả năng tự động dọn dẹp rác, biên dịch tự nhiên, concurrent và rất giống C về cú pháp. Sau đây là một vài đặc điểm đáng chú ý của nó:&lt;/p&gt;

&lt;h3 id=&quot;go-là-ngôn-ngữ-tối-giản-với-thiết-kế-thực-dụng-&quot;&gt;Go là ngôn ngữ tối giản với thiết kế thực dụng :&lt;/h3&gt;

&lt;p&gt;Ngôn ngữ lập trình Go có thể được mô tả đơn giản bằng ba từ: &lt;strong&gt;đơn giản–tối thiểu–thực dụng&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Nếu bạn nhìn sâu vào thiết kế ngôn ngữ của Go, bạn sẽ thấy cách tiếp cận đơn giản và tối giản của nó, cùng với thiết kế thực dụng. Bạn có thể quan sát sự đơn giản này với tất cả các tính năng của Go bao gồm cả hệ thống kiểu dữ liệu. Nhiều ngôn ngữ lập trình cung cấp quá nhiều tính năng làm cho nó trở nên phức tạp hơn cho các nhà phát triển nên mục tiêu thiết kế của Go là một ngôn ngữ đơn giản và chỉ cung cấp tất cả các tính năng cần thiết tối thiểu để phát triển các hệ thống phần mềm hiệu quả.&lt;/p&gt;

&lt;p&gt;Mặc dù Go có ít tính năng hơn nhưng năng suất không bị ảnh hưởng bởi thiết kế thực dụng của nó. Một lập trình viên Go mới có thể nhanh chóng học được ngôn ngữ và có thể dễ dàng bắt đầu phát triển các ứng dụng chất lượng.&lt;/p&gt;

&lt;p&gt;Trên thực tế có thể gọi Go là một ngôn ngữ lập trình hướng đối tượng (OOP). Tuy nhiên cách tiếp cận hướng đối tượng của Go khác với các ngôn ngữ lập trình như C++, Java và C #. Trên lí thuyết Go không phải là một ngôn ngữ OOP chính thống. Không giống như các ngôn ngữ OOP hiện có, Go không hỗ trợ thừa kế và thậm chí không có từ khóa class. Nó sử dụng các thành phần thừa kế thông qua hệ thống kiểu đơn giản của nó(kế thừa làm sao thì mình sẻ trình bày trong các bài sau). Thiết kế kiểu interface của Go cho thấy tính độc đáo của nó khi so sánh với các ngôn ngữ lập trình hướng đối tượng khác(mình cũng sẻ giới thiệu sâu sau). Đến đây chắc bạn tự hỏi Go có phãi là một ngôn ngữ OOP? Câu trả lời là có thể có cũng có thể không. Ngôn ngữ Go bao gồm tất cả các quy tắc cần thiết để viết các ứng dụng bằng một phương pháp hướng đối tượng, nhưng nó không phải là một ngôn ngữ OOP hoàn chỉnh vì nó thiếu một số tính năng OOP truyền thống.&lt;/p&gt;

&lt;h3 id=&quot;ngôn-ngữ-tĩnh-với-hiệu-suất-cao&quot;&gt;Ngôn ngữ tĩnh với hiệu suất cao&lt;/h3&gt;

&lt;p&gt;Go là một ngôn ngữ lập trình tĩnh, với cú pháp giống gần như 70% ngôn ngữ C. Giống như C và C ++, nó tự động biên dịch mã nguồn thành máy cho nên biên dịch just-In-Time (JIT) là không cần thiết để chạy chương trình của nó(Các ngôn ngữ lập trình như Java và C # sử dụng biên dịch JIT để chạy các ứng dụng.)&lt;/p&gt;

&lt;p&gt;Đối với việc viết ứng dụng, một ngôn ngữ động cho ta rất nhiều năng suất và sự thoải mái bởi vì bạn không phải lo lắng về các kiểu dữ liệu của các biến bạn sử dụng. Nhưng khi làm việc với một ngôn ngữ động, hiệu suất và khả năng maintain của các ứng dụng bị ảnh hưởng. Đôi khi việc debug của một ứng dụng được viết bằng một ngôn ngữ động rất khó khăn do chúng thiếu các kiểu an toàn. Ngay cả bây giờ, các nhà phát triển sử dụng ngôn ngữ tĩnh để tạo code cho ngôn ngữ động của họ ví dụ như các nhà phát triển JavaScript sử dụng ngôn ngữ tĩnh TypeScript để đảm bảo an toàn cho kiểu dữ liệu, cuối cùng biên dịch ra code JavaScript.&lt;/p&gt;

&lt;p&gt;Mặc dù ngôn ngữ tĩnh có thể cung cấp sự an toàn và hiệu suất của kiểu dữ liệu, nhưng làm việc với chúng có thể ảnh hưởng đến năng suất phát triển ứng dụng và việc biên soạn các chương trình lớn có thể mất nhiều thời gian. Sẽ rất tuyệt khi có một ngôn ngữ cung cấp sức mạnh của cả tĩnh và ngôn ngữ động để kết hợp hiệu suất và an toàn của một ngôn ngữ tĩnh với năng suất của một ngôn ngữ động.&lt;/p&gt;

&lt;p&gt;Go là sự kết hợp hoàn hảo của sức mạnh của ngôn ngữ tĩnh và năng suất của ngôn kiểu động. Go có thể được gọi là ngôn ngữ C hiện đại cung cấp hiệu suất gần như C, cùng với năng suất của một ngôn ngữ kiểu động.&lt;/p&gt;

&lt;h3 id=&quot;concurrency---xử-lí-đồng-thời&quot;&gt;Concurrency - Xử lí đồng thời&lt;/h3&gt;

&lt;p&gt;Ngày nay phần cứng máy tính đã phát triển để có nhiều lõi CPU và nhiều sức mạnh hơn, nhưng sức mạnh của máy tính hiện đại không thể được tận dụng bằng cách sử dụng các ngôn ngữ lập trình hiện tại và các công cụ. Khi các ứng dụng được chạy trên các máy chủ công suất cao, có những vấn đề về hiệu suất, mặc dù mới chỉ sử dụng một ít CPU. Trong một số môi trường lập trình, concurrency(sự đồng thời) và parallelism(song song) cho hiệu quả và hiệu năng tốt hơn, nhưng các tính năng này là một thư viện hay framework riêng biệt, chứ không phải là một tính năng tích hợp sẳn ở cấp độ ngôn ngữ, làm tăng thêm sự phức tạp khi bạn viết các ứng dụng concurrent.&lt;/p&gt;

&lt;p&gt;Trong Go, concurrency được xây dựng sẳn và được thiết kế để viết các ứng dụng concurrent hiệu suất cao cho các máy tính hiện đại. Concurrency là một trong những tính năng độc đáo của ngôn ngữ Go và nó được coi là điểm mạnh lớn nhất của ngôn ngữ này.&lt;/p&gt;

&lt;p&gt;Concurrency trong Go được thực hiện bằng hai tính năng độc đáo đó là : goroutines và channel. Một goroutine là một chức năng có thể chạy đồng thời với goroutines khác. Đây là một thread gọn nhẹ(tốn khoản 2kb stack size), trong đó nhiều goroutines thực hiện trong một thread duy nhất cho phép thực thi chương trình và hiệu quả. Tính năng quan trọng nhất của goroutine là nó được quản lý và thực thi bởi Go runtime.&lt;/p&gt;

&lt;p&gt;Nhiều ngôn ngữ lập trình cung cấp hỗ trợ viết các chương trình đồng thời, nhưng chúng chỉ giới hạn trong giao tiếp và đồng bộ hóa giữa các threads đang được thực thi. Và hầu hết các ngôn ngữ hiện tại cung cấp hỗ trợ cho đồng thời thông qua một framework, nhưng không phải là một tính năng tích hợp trong ngôn ngữ, vì vậy nó làm hạn chế khi concurrency được implemented với các ngôn ngữ này.&lt;/p&gt;

&lt;p&gt;Go cung cấp các channel(kênh) cho phép giao tiếp giữa các goroutines và đồng bộ hóa các hành động của chúng. Với các channel, bạn có thể gửi dữ liệu qua lại giữa các goroutine khác nhau. Channel cũng cung cấp mức độ đồng bộ hóa cao hơn giữa các goroutines và đảm bảo rằng hai goroutines đang chạy trong một state xác định. Concurrency là lý do chính cho việc sử dụng Go như một ngôn ngữ để xây dựng các hệ thống phần mềm hiệu quả cao với hiệu năng cao hơn. Mình sẻ giới thiệu cách dùng các chức năng này trong các bài viết tiếp theo.&lt;/p&gt;

&lt;h3 id=&quot;go-biên-dịch-nhanh-hơn&quot;&gt;Go biên dịch nhanh hơn&lt;/h3&gt;

&lt;p&gt;Một trong những thách thức khi viết các ứng dụng C/C ++ là thời gian cần thiết cho việc biên dịch chương trình, điều này rất khó chịu đối với các nhà phát triển khi họ làm việc với các ứng dụng C và C ++ lớn. Go là một ngôn ngữ được thiết kế để giải quyết các thách thức lập trình của các môi trường lập trình hiện tại. Trình biên dịch của nó rất hiệu quả cho việc biên dịch các chương trình một cách nhanh chóng; một ứng dụng Go lớn có thể được biên dịch trong vài giây, điều đó là hấp dẫn đối với nhiều nhà phát triển C và C ++ chuyển sang môi trường lập trình Go.&lt;/p&gt;

&lt;h3 id=&quot;go-là-ngôn-ngữ-đa-năng&quot;&gt;Go là ngôn ngữ đa năng&lt;/h3&gt;

&lt;p&gt;Các ngôn ngữ khác nhau được dùng để phát triển các loại ứng dụng khác nhau với ưu nhược điểm khác nhau. C và C++ thường được sử dụng cho các chương trình hệ thống và cho các hệ thống đòi hỏi hiệu suất cao nhưng làm việc với C/C++ ảnh hưởng đến năng suất phát triển ứng dụng. Một số ngôn ngữ lập trình khác, chẳng hạn như Ruby, Node.js và Python, cho phép phát triển ứng dụng nhanh chóng và tăng năng suất ví dụ như nền tảng Node.js tốt cho việc xây dựng các API JSON và các ứng dụng real-time, nhưng nó sẽ thất bại khi các CPU-intensive programming tasks được thực hiện. Một số ngôn ngữ khác được dùng để xây dựng native mobile app như Objective C hay Swift tuy nhiên hai ngôn ngữ này dường như chỉ có thể làm mobile. Nhiều ngôn ngữ lập trình được dùng cho nhiều trường hợp sử dụng như lập trình hệ thống, hệ thống phân tán(distributed computing), lập trình web app, xây dựng ứng dụng doanh nghiệp(ERP), mobile app… Thì Go là ngôn ngữ làm được điều đó, nó có thể được dùng để xây dựng một loạt các loại ứng dụng bao gồm hệ thống đòi hỏi hiệu năng cao, mobile app, web app…đặc biệt nó được sử dụng để xây dựng các ứng dụng doanh nghiệp và các máy chủ back-end mạnh mẻ. Go cung cấp hiệu suất cao đồng thời vẫn giữ được năng suất cao cho việc phát triển ứng dụng nhờ thiết kế đơn giản và thiết thực. Hệ sinh thái Go (bao gồm Go tool, thư viện chuẩn Go và thư viện của bên thứ ba đi) cung cấp các công cụ và thư viện thiết yếu để xây dựng một loạt các ứng dụng Go. Dự án Go Mobile hỗ trợ xây dựng ứng dụng di động cho cả nền tảng Android và iOS, cho phép nhiều cơ hội hơn với Go.&lt;/p&gt;

&lt;p&gt;Trong thời đại điện toán đám mây, Go là một ngôn ngữ lập trình hiện đại có thể được sử dụng để xây dựng các ứng dụng hệ thống; các ứng dụng phân tán(distributed applications); các chương trình networking; Trò chơi; ứng dụng web; RESTful services; back-end servers; các ứng dụng di động; và cloud-optimized – thế hệ ứng dụng kế tiếp . Go là sự lựa chọn của nhiều hệ thống cách tân sáng tạo như Docker và Kubernetes. Phần lớn các công cụ về hệ sinh thái Docker đang được viết bằng Go.&lt;/p&gt;

&lt;p&gt;OK! chúng ta là dân TIN-HỌC, nghĩa là tin đã rồi mới học, đến đây có lẻ bạn đã thấy được sức mạnh và xu hướng của Golang đồng thời nắm được những đặc điểm chính của Golang, tin rồi thì học thôi nào, cùng tiếp tục đọc các bài viết về Golang tiếp theo của mình nhé! cám ơn các bạn.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="nodejs" /><category term="eventloop" /><category term="singlethreaded" /><summary type="html">Hiện tại có rất nhiều ngôn ngữ mạnh mẻ cho việc xây dựng ứng dụng web phía back-end như Java, C#, Php, Javascript(Node.js), Ruby, Python…, trước đó thì mình làm việc với Javascript-Node.js tuy nhiên hôm nay, mình sẻ giới thiệu với các bạn một ngôn ngữ có vẻ mới một chút đó là Golang(Go).</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Javascript – Prototype Và Kế Thừa</title><link href="https://romeo.vn/javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class/" rel="alternate" type="text/html" title="Javascript – Prototype Và Kế Thừa" /><published>2016-09-29T12:18:00-05:00</published><updated>2016-09-29T12:18:00-05:00</updated><id>https://romeo.vn/javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class</id><content type="html" xml:base="https://romeo.vn/javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class/">&lt;p&gt;Prototype là khái niệm rất rất quan trọng mà các Javascript Engineer phãi hiểu và tận dụng nó tốt. Đây là thành phần mà theo bản thân mình nghĩ gần như là cốt lõi của Javascript. Trong bài viết này chúng ta sẻ thảo luận và làm rõ những điểm cơ bản của thành phần này.&lt;/p&gt;

&lt;p&gt;Ban đầu Javascript cung cấp hàm Object() và một Object nặc danh có thể được tham chiếu đến bằng cú pháp &lt;strong&gt;Object.prototype&lt;/strong&gt;, bật console lên và thử là biết ngay á mà:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Object &lt;strong&gt;Object.prototype&lt;/strong&gt; có những thuộc tính có sẳn như &lt;strong&gt;valueOf&lt;/strong&gt;, &lt;strong&gt;toString&lt;/strong&gt;, &lt;strong&gt;toLocaleString&lt;/strong&gt;, &lt;strong&gt;propertyIsEnumerable&lt;/strong&gt;, &lt;strong&gt;isPrototypeOf&lt;/strong&gt;, &lt;strong&gt;hasOwnProperty&lt;/strong&gt;, &lt;strong&gt;constructor&lt;/strong&gt;. Trong đó thuộc tính &lt;strong&gt;constructor&lt;/strong&gt; là thuộc tính trỏ ngược lại hàm &lt;strong&gt;Object()&lt;/strong&gt;, thử cái để thấy nè:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ƒ Object() { [native code] }&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ƒ Object() { [native code] }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Giả sử vòng tròn đại diện cho hàm &lt;strong&gt;Object()&lt;/strong&gt; và hình vuông đại diện cho đối tượng &lt;strong&gt;Object.prototype&lt;/strong&gt;. Hình dưới đây minh họa mối quan hệ giữa hàm &lt;strong&gt;Object()&lt;/strong&gt; và đối tượng Object:
&lt;img src=&quot;/assets/images/2016-09-29-javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ok, bây giờ chúng ta sẻ định nghĩa và sử dụng một cái giống như class trong các ngôn ngữ như Java, C#,…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Animal class&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Implement method for animal class&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my name is &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my age is &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// create a new instance of the Animal object.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEXDY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//my name is TEXDY&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//my age is 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Trong đoạn code trên ta đã dễ dàng định nghĩa và sử dụng cơ bản môt cái giống như class, đó là hàm Animal(name,age) chấp nhận hai đối số, thêm thuộc tính name và age cho đối tượng và đặt giá trị của thuộc tính name bằng đối số name, age bằng đối số age. Nhìn việc định nghĩa Animal đơn giản như thế, tuy nhiên phía sau nó Javascript thực hiện không hề đơn giản, Javascript tạo ra hàm Animal và thêm một đối tượng nặc danh nữa. Giống như đối tượng hàm Object ban đầu, hàm Animal có một thuộc tính có tên là prototype tham chiếu đến đối tượng nặc danh và đối tượng nặc danh có thuộc tính constructor trỏ về hàm Animal(). Ngoài ra, đối tượng Animal.prototype được liên kết với đối tượng Object.prototype thông qua [[Prototype]], được gọi là prototype linkage. Prototype linkage được ký hiệu bằng [[Prototype]], chúng được mô tả ở hình bên dưới:
&lt;img src=&quot;/assets/images/2016-09-29-javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class/2.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và khi thêm phương thức cho Animal chỉ đơn giản là thêm phương thức cho đối tượng nặc danh mà Animal.prototype tham chiếu đến:
&lt;img src=&quot;/assets/images/2016-09-29-javascript-prototype-va-ke-thua-trong-javascript-thuankhong-es6-class/3.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;
Khi tạo 1 instance của object Animal:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEXDY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Khi thực thi dòng code trên thì Javascript tạo ra một Object mới tên là texDy, object này link đến Animal.prototype thông qua prototype linkage, việc link từ texDy đến Animal.prototype đến Object.prototype được gọi là prototype chain.&lt;/p&gt;

&lt;p&gt;Khi một instance của một Object hay một Object nào đó gọi một phương thức, đầu tiên nó sẻ tìm xem nó hiện tại có giữ phương thức thức đó không, nếu không có thì sẻ duyệt từng prototype trong prototype chain từ dưới lên trên để tìm phương thức đó nếu có thì gọi. Lấy ví dụ như chương trình trên, đối tượng texDy vốn dĩ không chứa phương thức getName và getAge nên khi gọi hai phương thức đó texDy sẻ duyệt prototype chain để tìm và duyệt đến Animal.prototype thì gặp hai phương thức và gọi.&lt;/p&gt;

&lt;p&gt;Nếu chúng ta gọi lệnh texDy.hasOwnProperty() thì nó sẻ tìm không có trong đối tượng texDy, Animal.prototype nên nó sẻ tìm lên đến Object.prototype, thấy phương thức đó và sẻ gọi Object.prototype,.hasOwnProperty().&lt;/p&gt;

&lt;p&gt;Giả xử ta định nghĩa thêm một phương thức mới cho:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getFullInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;My name is&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; ,i'm &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; years old&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Thì khi gọi phương thức texDy.getFullInfo(); sẻ trả về ngay “My name isTEXDY ,i’m 3 years old”, đây là phương thức đã được định nghĩa ở Object texDy nên Javascript sẻ không phãi tìm trong prototype chain, đồng thời các instance khác của Animal sẻ không dùng được phương thức đó.&lt;/p&gt;

&lt;p&gt;Cũng tương tự vậy, nếu chúng ta định nghĩa một phương thức getName mới cho texDy như sau:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;texDy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Toi la &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Thì khi gọi texDy.getName() sẻ không còn in ra “my name is TEXDY” nữa mà sẻ in ra “Toi la TEXDY”, vì sao vậy, vì đơn giản là texDy đã có phương thức getName rồi, nó sẻ không phãi gọi lên prototype của cha nó nữa.&lt;/p&gt;

&lt;p&gt;Ok, tới đây chắc clear rồi. Tóm lượt lại một lần nữa, Javascript sẻ kế thừa các phương thức, thuộc tính bằng cách tìm trong prototype chain đến các prototype của cha, ông, cố,…. của nó.&lt;/p&gt;</content><author><name>My Le Phuoc</name></author><category term="blog" /><category term="Javascript" /><category term="Prototype" /><summary type="html">Prototype là khái niệm rất rất quan trọng mà các Javascript Engineer phãi hiểu và tận dụng nó tốt. Đây là thành phần mà theo bản thân mình nghĩ gần như là cốt lõi của Javascript. Trong bài viết này chúng ta sẻ thảo luận và làm rõ những điểm cơ bản của thành phần này.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry><entry><title type="html">Node.JS – Single Thread Và Event Loop</title><link href="https://romeo.vn/nodejs-single-threaded-va-event-loop/" rel="alternate" type="text/html" title="Node.JS – Single Thread Và Event Loop" /><published>2016-09-24T22:48:00-05:00</published><updated>2016-09-24T22:48:00-05:00</updated><id>https://romeo.vn/nodejs-single-threaded-va-event-loop</id><content type="html" xml:base="https://romeo.vn/nodejs-single-threaded-va-event-loop/">&lt;p&gt;“Bạn biết gì về Node.js?Nói mình nghe về những thứ bạn biết về Node.js đi nào?” – Đó là câu hỏi phổ biến nhất trong các buổi phỏng vấn lập trình viên Node.js và quan trọng nhất đó cũng là câu hỏi mà các bạn thường phãi đặt ra đầu tiên cho chính mình khi bắt đầu làm việc với Node.js, thế phần đầu tiên mà mình nên biết đó là gì, theo mình đó là một trong những đặc điểm đặc trưng và kiến trúc cơ bản của nodejs – Single Threaded và Event Loop.&lt;/p&gt;

&lt;p&gt;Lúc bắt đầu làm việc với Nodejs mình đã tự đặt ra câu hỏi với mình như này: “Nghe nói nodejs nó là Single Threaded thế Single Threaded thì làm sao mà handle được nhiều request cùng lúc được ta?”, ok bây giờ mình sẻ trình bày câu trả lời của mình(có thể sai có thể đúng, mong các bạn góp ý và phản biện bên dưới để giúp nhau hoàn thiện hơn :v)&lt;/p&gt;

&lt;h4 id=&quot;mô-hình-xử-lý-web-truyền-thốngthread-base&quot;&gt;Mô hình xử lý web truyền thống(thread base):&lt;/h4&gt;

&lt;p&gt;Như chúng ta đã biết thì các hệ thống server của các ngôn ngữ phổ biến như Java, C#,… thường sẻ xử lí các request dựa trên thread base như sau:
&lt;img src=&quot;/assets/images/2016-09-24-nodejs-single-threaded-va-event-loop/1.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;
Nhìn vào diagram trên bạn sẻ thấy rằng cứ mỗi request tới thì web server của chúng ta sẻ phãi khởi tạo 1 thread để handle request đó, các thread pool này sẻ được thực thi một cách song song và chúng sẻ bị block lại cho đến khi response về cho client.&lt;/p&gt;

&lt;p&gt;Việc bạn thao tác các tác vụ blocking I/O như đọc database hay đọc file…. sẻ khiến thread bạn bị block lâu hơn, mà ví dụ như Java thì stack size dành cho 1 thread trên JVM mặc định là 1MB, như thế thì theo logic có thể để xử lí 1 request chúng ta sẻ tốn ít nhất 1MB và với n request đồng thời thì chúng ta sẻ phãi tốn ít nhất n(MB) đắt đỏ vcl đúng không nào, vì sự đắt đỏ đó nên số lượng thread pool thường được set cứng một số lượng cố định.&lt;/p&gt;

&lt;p&gt;Tuy nhiên nếu là một hệ thống có lượng truy cập lớn thì chúng ta sẻ đối mặt ngay với vấn đề là nếu thread pool của chúng ta duy trì quá nhiều thread thì hệ thống của chúng ta sẻ rất khó kiểm soát đồng thời cost dành cho context switch(mình sẻ nói về vấn đề này sau nếu có cơ hội :v) tăng lên.&lt;/p&gt;

&lt;p&gt;Nhưng nếu chúng ta duy trì quá ít thread trong thread pool thì lại làm tăng độ trể, khó đáp ứng cho người dùng. Hơn nữa việc xây dựng ứng dụng dựa trên thread lại đối mặt thêm một vấn đề đó là callstack, quá khó đúng không nào.
Ngoài ra trong thực tế việc xử lí tác vụ multi threads cũng chẳng như lí thuyết chúng ta thường nghĩ đâu, liên tưởng như hình dưới đây :v
&lt;img src=&quot;/assets/images/2016-09-24-nodejs-single-threaded-va-event-loop/2.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Node.js và event base sẻ phần nào giải quyết các vấn đề nói trên tuy nhiên sẻ có những điểm yếu khác sẻ lòi ra với Node.js mình sẻ nói sau.&lt;/p&gt;

&lt;h3 id=&quot;nodejs-và-event-base&quot;&gt;Node.js và event base:&lt;/h3&gt;

&lt;p&gt;Có thể chúng ta đã nghe nhiều về Node.js và có nhiều nhận định và câu hỏi trong đầu như sau: Nodejs là một Javascript runtime chạy trên máy chủ V8 của chrome, Nodejs sử dụng mô hình event-driven với cơ chế callback của Javascript và mô hình non blocking I/O giúp cho nó nhẹ và hiệu quả, nodejs không dựa trên mô hình đa threads mà là đơn thread với Event Loop.&lt;/p&gt;

&lt;p&gt;OK, khi mình đọc ngang đó thì đéo hiểu gì hết ahihi. Mô hình event-driven trong Node.js nó như thế nào, Event Loop là gì, non blocking i/o nó ra sao, nghe nói nó single thread màsao nó xử lí được nhiểu request đồng thời…., đó là những điều mình thắc mắc khi mới tìm hiểu. Bây giờ chúng ta sẻ bàn vào kiến trúc của Nodejs để làm rõ điều đó.&lt;/p&gt;

&lt;p&gt;Thực ra, Node.js vẫn duy trì một thread pool có số thread giới hạn để phục vụ các yêu cầu từ client.
Để xử lí các request từ client, đầu tiên Nodejs sẻ tiếp nhận các request đó một cách tuần tự và đặt vào một cái queue chúng ta có thể gọi nó là event queue. Nodejs có một thành phần mà nó được coi là trái tim của Node đó là Event Loop, cũng như cái tên của nó, event loop sử dụng một vòng lặp vô hạn để tiếp nhận và xử lí các yêu cầu. Event loop kiểm tra trong event queue xem có request nào không, nếu không có thì cứ lặp mãi, nếu có thì sẻ có hai hướng sử lí sau:&lt;/p&gt;

&lt;p&gt;– Nếu request không có yêu cầu gì đến blocking io thì xử lí mọi thứ từ yêu cầu sau đó event loop phản hồi lại cho client.&lt;/p&gt;

&lt;p&gt;– Nếu request có một hoặc nhiều yêu cầu blocking i/o như đọc file/query database thì nó phãi kiễm tra xem trong Thread Pool có sẳn thread nào không, nếu có thread sẳn thì quăng request đó cho nó xử lí, xử lí xong thì quăng ngược lại cho event loop trả về cho client.
Để dễ hiểu các bạn tham khảo diagram sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2016-09-24-nodejs-single-threaded-va-event-loop/3.jpg&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Đến đây có lẽ bạn đã hiểu kiến trúc Nodejs làm việc nhưng có thể bạn sẻ thắc mắc rằng thread pool của Nodejs nó giới hạn bao nhiêu threads, điều này phụ thuộc vào các thành phần blocking io mà Nodejs sẻ handle, ví dụ như handle file system, node sẻ dùng libuv để xử lí dụ đó và theo một số tài liệu thì số theads “mặc định” mà libuv giới hạn sẻ là 4. Có nghĩa là khi có 5 request yêu cầu làm việc với file system dồng thời thì request thứ 5 sẻ bị block cho đến khi 4 thread xử lí 4 request đầu tiên thực hiện xong.&lt;/p&gt;

&lt;p&gt;Đến đây có thể là các bạn đã có thể hiểu một cách tương đối đầy đủ cách thức hoạt động của Node.js, cám ơn các bạn đọc bài viết, nếu có thắc mắc mong các bạn góp ý và phản biện bên dưới, cám ơn.&lt;/p&gt;</content><author><name>Le Phuoc My</name></author><category term="blog" /><category term="nodejs" /><category term="eventloop" /><category term="singlethreaded" /><summary type="html">“Bạn biết gì về Node.js?Nói mình nghe về những thứ bạn biết về Node.js đi nào?” – Đó là câu hỏi phổ biến nhất trong các buổi phỏng vấn lập trình viên Node.js và quan trọng nhất đó cũng là câu hỏi mà các bạn thường phãi đặt ra đầu tiên cho chính mình khi bắt đầu làm việc với Node.js, thế phần đầu tiên mà mình nên biết đó là gì, theo mình đó là một trong những đặc điểm đặc trưng và kiến trúc cơ bản của nodejs – Single Threaded và Event Loop.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://romeo.vn/assets/images/" /></entry></feed>